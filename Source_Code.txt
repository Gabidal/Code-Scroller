
C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Cpp\main.cpp" 
#include "../H/UI/Usr.h"
#include "../H/UI/Safe.h"
#include "../H/UI/Producer.h"
#include "../H/UI/Satellite.h"
#include "../H/UI/Service.h"
#include "../H/Lexer/Lexer.h"
#include "../H/PreProsessor/PreProsessor.h"
#include "../H/Parser/Parser.h"
#include "../H/Parser/PostProsessor.h"
#include "../H/Parser/Analyzer.h"
#include "../H/Nodes/Node.h"
#include "../H/Flags.h"
#include "../H/Docker/Mangler.h"
#include "../H/Docker/Docker.h"
#include "../H/Docker/HTTPS.h"
#include "../H/Docker/OBJ.h"
#include "../H/BackEnd/BackEnd.h"
#include "../H/BackEnd/IRGenerator.h"
#include "../H/BackEnd/Selector.h"
#include "../H/BackEnd/x86.h"
#include "../H/BackEnd/ARM.h"
#include "../H/BackEnd/IRPostProsessor.h"
#include "../H/BackEnd/DebugGenerator.h"

#include <sstream>
#include <iostream>
#include <map>
#include <fstream>
#include <vector>
#include <ctime>
using namespace std; 

Usr* sys;
Node* Global_Scope;
Selector* selector;
x86_64 X86_64;
ARM_64 _ARM_64;
int _SYSTEM_BIT_SIZE_ = 4;

string Output; 

extern string VT_API;
//Evie.exe -in ~/test.e -out ~/test.asm -f exe -os win32 -arch x86 -mode 32 -d
//Evie.exe -in ~/test.e
int Build(int argc, const char* argv[])
{
    if (argc == 1) {
        //this happends when no parameter are given
        cout << "Argument types are: \n";
        cout << "-in [relative path/source file]\n";
        cout << "-out [relative path/output file name]\n";
        cout << "-os [target operating system (win32/unix)]\n";
        cout << "-host [the host operating system (win32/unix)]\n";
        cout << "-arch [output assembly type (x86/arm)]\n";
        cout << "-lib [relative path/lib name]\n";
        cout << "-repo-dir [relative/absolute path for saving git repos]\n";
        cout << (string)"-f [\n  supported output file formats are:\n" +
            "  exe(executable (works for unix as well)),\n" +
            "  lib(static lib),\n" +
            "  dll(dynamic library (support is not made yet!))\n" +
            "]\n";
        cout << "-mode [bit mode for assembly output (32/64)]\n";
        cout << (string)"-debug [\n supported debug symbol types:\n" +
            "  dwarf2\n" +
            "]\n";
        cout << "-vt [virus total API-key]\n";
        cout << "-reference-count-size [reference count size]\n";
        cout << "-service [starts Evie as a service with a port returned in standard out]\n";
        cout << endl;
        return -1;
    }
    Lexer::DecimalSeparator = '.';
    Lexer::ExponentSeparator = 'e';
    Lexer::SingleLineCommentIdentifier = '#';
    Lexer::StringIdentifier = '\"';
    Lexer::Keywords = {
        "type", "func", "export", "import", "use", "if", "while", "else", "ptr", "ref", "jump", /*"size", size and deciaml and integer and format is no more a keyword because it can be also a variable name, only special in a class scoope*/ "return", "state", "const",
        "cpp", "evie", "vivid", "plain", "static"
    };
    sys = new Usr(argv, argc);
    if (VT_API != "")
        sys->Info.VT_API = VT_API;
    _SYSTEM_BIT_SIZE_ = atoi(sys->Info.Bits_Mode.c_str());
    if (sys->Info.Architecture == "x86")
        Output = ".intel_syntax noprefix\n";
    string start_file = sys->Info.Source_File.c_str();

    Satellite satellite;

    MANGLER::Add_ID("cpp", { "P",{MANGLER::PREFIX, "ptr"} });
    MANGLER::Add_ID("cpp", { "R",{MANGLER::PREFIX, "ref"} });
    MANGLER::Add_ID("cpp", { "c",{MANGLER::VARIABLE, "1 integer"} });
    MANGLER::Add_ID("cpp", { "s",{MANGLER::VARIABLE, "2 integer"} });
    MANGLER::Add_ID("cpp", { "i",{MANGLER::VARIABLE, "4 integer"} });
    MANGLER::Add_ID("cpp", { "f",{MANGLER::VARIABLE, "4 decimal"} });
    MANGLER::Add_ID("cpp", { "d",{MANGLER::VARIABLE, "8 decimal"} });
    MANGLER::Add_ID("cpp", { "l",{MANGLER::VARIABLE, "4 integer"} });
    MANGLER::Add_ID("cpp", { "x",{MANGLER::VARIABLE, "8 integer"} });
    MANGLER::Add_ID("cpp", { { "N" }, { MANGLER::CLASS, "" } });
    MANGLER::Add_ID("cpp", { { "E" }, { MANGLER::END_CLASS, "" } });
    //temporary
    MANGLER::Add_ID("cpp", { "t",{MANGLER::VARIABLE, "type"} });

    MANGLER::Add_ID("vivid", { "P",{MANGLER::PREFIX, "ptr"} });
    MANGLER::Add_ID("vivid", { "R",{MANGLER::PREFIX, "ref"} });
    MANGLER::Add_ID("vivid", { "h",{MANGLER::VARIABLE, "1 integer"} });
    MANGLER::Add_ID("vivid", { "c",{MANGLER::VARIABLE, "1 integer"} });
    MANGLER::Add_ID("vivid", { "t",{MANGLER::VARIABLE, "2 integer"} });
    MANGLER::Add_ID("vivid", { "s",{MANGLER::VARIABLE, "2 integer"} });
    MANGLER::Add_ID("vivid", { "j",{MANGLER::VARIABLE, "4 integer"} });
    MANGLER::Add_ID("vivid", { "i",{MANGLER::VARIABLE, "4 integer"} });
    MANGLER::Add_ID("vivid", { "f",{MANGLER::VARIABLE, "4 decimal"} });
    MANGLER::Add_ID("vivid", { "d",{MANGLER::VARIABLE, "8 decimal"} });
    MANGLER::Add_ID("vivid", { "x",{MANGLER::VARIABLE, "8 integer"} });
    MANGLER::Add_ID("vivid", { "y",{MANGLER::VARIABLE, "8 integer"} });
    MANGLER::Add_ID("vivid", { { "N" }, { MANGLER::CLASS, "" } });
    MANGLER::Add_ID("vivid", { { "E" }, { MANGLER::END_CLASS, "" } });
    MANGLER::Add_ID("vivid", { { "_r" }, { MANGLER::RETURN, "" } });
    //temporary
    //MANGLER::Add_ID("vivid", { "t",{MANGLER::VARIABLE, "type"} });

    DOCKER::Slicer = TXT::Unwrap;
    DOCKER::Set_Default_Translator(TXT::TXT_Analyzer);
    DOCKER::Add_Translator(Location::Header, "\x7F" "ELF", ELF::ELF_Analyzer);
    DOCKER::Add_Translator(Location::Header, "!<arch>", LIB::LIB_Analyzer);
    DOCKER::Add_Translator(Location::Header, "#analyze", ASM::ASM_Analyzer);
    DOCKER::Add_Translator(Location::Header, "https", HTTPS::HTTPS_Analyser);
    DOCKER::Add_Translator(Location::Header, "L\x1", OBJ::OBJ_Analyser);
    DOCKER::Add_Translator(Location::Header, "\x64\x86", OBJ::OBJ_Analyser);
    DOCKER::Add_Translator(Location::Header, "\x32\x86", OBJ::OBJ_Analyser);

    DOCKER::Add_Translator(Location::File_Name, "asm", ASM::ASM_Analyzer);

    vector<Component> Input;
    PreProsessor preprosessor(Input);

    Global_Scope = new Node(CLASS_NODE, new Position());
    Global_Scope->Name = "GLOBAL_SCOPE";
    Global_Scope->Inheritted.push_back("static");

    selector = new Selector();
    
    preprosessor.Defined_Constants =
    {
        {"SOURCE_FILE",         Component("\"" + sys->Info.Source_File + "\"", Flags::STRING_COMPONENT)},
        {"DESTINATION_FILE",    Component("\"" + sys->Info.Destination_File + "\"", Flags::STRING_COMPONENT)},
        {"OS",                  Component("\"" + sys->Info.OS + "\"", Flags::STRING_COMPONENT)},
        {"ARCHITECTURE",        Component("\"" + sys->Info.Architecture + "\"", Flags::STRING_COMPONENT)},
        {"FORMAT",              Component("\"" + sys->Info.Format + "\"", Flags::STRING_COMPONENT)},
        {"BITS_MODE",           Component(sys->Info.Bits_Mode, Flags::NUMBER_COMPONENT)},
        {"true",                Component("1", Flags::NUMBER_COMPONENT)},
        {"false",               Component("0", Flags::NUMBER_COMPONENT)},
    };
    
    if (sys->Info.Is_Service) {
        Service service = Service();
        return 0;
    }

    preprosessor.Include(sys->Info.Source_File.c_str());
    
    preprosessor.Factory();

    Parser p(Global_Scope);
    p.Input = Input;
    p.Factory();

    Safe s;
    s.Parser_Factory();

    PostProsessor postprosessor(Global_Scope);
    postprosessor.Components = p.Input;
    postprosessor.Factory();
    Global_Scope->Append(Global_Scope->Childs, postprosessor.Input);

    Analyzer analyzer = Analyzer();

    vector<IR*> IRs;
    IRGenerator g(Global_Scope, Global_Scope->Childs, &IRs);

    IRPostProsessor IRpost(&IRs);

    if (sys->Info.Debug)
        DebugGenerator DG(IRs);

    BackEnd Back(IRs, Output);

    ofstream o(sys->Info.Destination_File.c_str());
    o << Output;
    o.close();

    Producer pr;
    pr.Assemble_Command();
    return 0;
}

#ifndef Test
//Evie.exe -in ~/test.e -out ~/test.asm -f exe -os win32 -arch x86 -mode 32 -debug dwarf2
//Evie.exe -in ~/test.e
int main(int argc, const char* argv[])
{
    Build(argc, argv);
    return 0;
}
#endif
C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Cpp\BackEnd\ARM.cpp" 
#include "../../H/BackEnd/ARM.h"
extern unsigned long long Reg_Random_ID_Addon;

void ARM_64::Init() {
	size = 8;	//64 bit arch

	Seperator = ",";
	Register_Pre_Fix = "";
	Number_Pre_Fix = "";
	Label_Post_Fix = ":";

	using namespace TOKEN;
	Token* Register = new Token(REGISTER | NONVOLATILE | VOLATILE | RETURNING | QUOTIENT | REMAINDER | PARAMETER | STACK_POINTTER);
	Token* Register_Float = new Token(REGISTER | NONVOLATILE | VOLATILE | RETURNING | DECIMAL | PARAMETER);
	Token* Scalar = new Token(NUM, {
		new Token(NUM, "1"),
		new Token(NUM, "2"),
		new Token(NUM, "4"),
		new Token(NUM, "8")
		}, "scaler");
	Token* Const = new Token(NUM, "const");
	Token* Decimal = new Token(DECIMAL | NUM, "const");
	Token* Memory = new Token(MEMORY, {
			{ new Token(REGISTER), 2},
			{ new Token(SCALER | ALL_ARGS_SAME_SIZE, {
				{{Register, {1, 8}}, {Scalar, {1, 8}}},
				{{Scalar, {1, 8}}, {Register, {1, 8}}},
				{{Scalar, {1, 8}}, {Scalar, {1, 8}}}
				}), 1},
			{ new Token(OFFSETTER | ALL_ARGS_SAME_SIZE, {
				{{Register, {1, 8}}, {Register, {1, 8}}},
				{{Register, {1, 8}}, {Const, {1, 8}}},
				{{Const, {1, 8}}, {Register, {1, 8}}},
				{{Const, {1, 8}}, {Const, {1, 8}}},
				}), INT32_MAX},
			{ new Token(DEOFFSETTER | ALL_ARGS_SAME_SIZE, {
				{{Register, {1, 8}}, {Register, {1, 8}}},
				{{Register, {1, 8}}, {Const, {1, 8}}},
				{{Const, {1, 8}}, {Register, {1, 8}}},
				{{Const, {1, 8}}, {Const, {1, 8}}},
				}), INT32_MAX}
		}, "memory");
	Token* Memory_Float = new Token(MEMORY | DECIMAL, {
			{ new Token(REGISTER), 2},
			{ new Token(SCALER | ALL_ARGS_SAME_SIZE, {
				{{Register, {1, 8}}, {Scalar, {1, 8}}},
				{{Scalar, {1, 8}}, {Register, {1, 8}}},
				{{Scalar, {1, 8}}, {Scalar, {1, 8}}}
				}), 1},
			{ new Token(OFFSETTER | ALL_ARGS_SAME_SIZE, {
				{{Register, {1, 8}}, {Register, {1, 8}}},
				{{Register, {1, 8}}, {Const, {1, 8}}},
				{{Const, {1, 8}}, {Register, {1, 8}}},
				{{Const, {1, 8}}, {Const, {1, 8}}},
				}), INT32_MAX},
			{ new Token(DEOFFSETTER | ALL_ARGS_SAME_SIZE, {
				{{Register, {1, 8}}, {Register, {1, 8}}},
				{{Register, {1, 8}}, {Const, {1, 8}}},
				{{Const, {1, 8}}, {Register, {1, 8}}},
				{{Const, {1, 8}}, {Const, {1, 8}}},
				}), INT32_MAX}
		}, "memory");
	Token* Label = new Token(LABEL | GLOBAL_VARIABLE, "label");
	Token* Data = new Token(NUM | STRING);
	Utility = {
		Register,
		Scalar,
		Const,
		Memory,
		Label,
		Data
	};

	Token* BYTE = new Token(SIZE_INDENTIFIER, "", 1);
	Token* WORD = new Token(SIZE_INDENTIFIER, "", 2);
	Token* DWORD = new Token(SIZE_INDENTIFIER, "", 4);
	Token* QWORD = new Token(SIZE_INDENTIFIER, "", 8);
	Size_Identifiers = {
		BYTE,
		WORD,
		DWORD,
		QWORD
	};


	Token* W0B = new Token(TOKEN::VOLATILE | TOKEN::RETURNING, "w0", 1, {});
	Token* W0W = new Token(TOKEN::VOLATILE | TOKEN::RETURNING, "w0", 2, {W0B});
	Token* W0D = new Token(TOKEN::VOLATILE | TOKEN::RETURNING, "w0", 4, {W0W});
	Token* X0 = new Token(TOKEN::VOLATILE | TOKEN::RETURNING, "x0", 8, { W0D });

	Token* W1B = new Token(TOKEN::VOLATILE, "w1", 1, {});
	Token* W1W = new Token(TOKEN::VOLATILE, "w1", 2, { W1B });
	Token* W1D = new Token(TOKEN::VOLATILE, "w1", 4, { W1W });
	Token* X1 = new Token(TOKEN::VOLATILE, "x1", 8, { W1D });

	Token* W2B = new Token(TOKEN::VOLATILE, "w2", 1, {});
	Token* W2W = new Token(TOKEN::VOLATILE, "w2", 2, { W2B });
	Token* W2D = new Token(TOKEN::VOLATILE, "w2", 4, { W2W });
	Token* X2 = new Token(TOKEN::VOLATILE, "x2", 8, { W2D });

	Token* W3B = new Token(TOKEN::VOLATILE, "w3", 1, {});
	Token* W3W = new Token(TOKEN::VOLATILE, "w3", 2, { W3B });
	Token* W3D = new Token(TOKEN::VOLATILE, "w3", 4, { W3W });
	Token* X3 = new Token(TOKEN::VOLATILE, "x3", 8, { W3D });

	Token* W4B = new Token(TOKEN::VOLATILE, "w4", 1, {});
	Token* W4W = new Token(TOKEN::VOLATILE, "w4", 2, { W4B });
	Token* W4D = new Token(TOKEN::VOLATILE, "w4", 4, { W4W });
	Token* X4 = new Token(TOKEN::VOLATILE, "x4", 8, { W4D });

	Token* W5B = new Token(TOKEN::VOLATILE, "w5", 1, {});
	Token* W5W = new Token(TOKEN::VOLATILE, "w5", 2, { W5B });
	Token* W5D = new Token(TOKEN::VOLATILE, "w5", 4, { W5W });
	Token* X5 = new Token(TOKEN::VOLATILE, "x5", 8, { W5D });

	Token* W6B = new Token(TOKEN::VOLATILE, "w6", 1, {});
	Token* W6W = new Token(TOKEN::VOLATILE, "w6", 2, { W6B });
	Token* W6D = new Token(TOKEN::VOLATILE, "w6", 4, { W6W });
	Token* X6 = new Token(TOKEN::VOLATILE, "x6", 8, { W6D });

	Token* W7B = new Token(TOKEN::VOLATILE, "w7", 1, {});
	Token* W7W = new Token(TOKEN::VOLATILE, "w7", 2, { W7B });
	Token* W7D = new Token(TOKEN::VOLATILE, "w7", 4, { W7W });
	Token* X7 = new Token(TOKEN::VOLATILE, "x7", 8, { W7D });

	Token* W8B = new Token(TOKEN::VOLATILE, "w8", 1, {});
	Token* W8W = new Token(TOKEN::VOLATILE, "w8", 2, { W8B });
	Token* W8D = new Token(TOKEN::VOLATILE, "w8", 4, { W8W });
	Token* X8 = new Token(TOKEN::VOLATILE, "x8", 8, { W8D });

	Token* W9B = new Token(TOKEN::VOLATILE, "w9", 1, {});
	Token* W9W = new Token(TOKEN::VOLATILE, "w9", 2, { W9B });
	Token* W9D = new Token(TOKEN::VOLATILE, "w9", 4, { W9W });
	Token* X9 = new Token(TOKEN::VOLATILE, "x9", 8, { W9D });

	Token* W10B = new Token(TOKEN::VOLATILE, "w10", 1, {});
	Token* W10W = new Token(TOKEN::VOLATILE, "w10", 2, { W10B });
	Token* W10D = new Token(TOKEN::VOLATILE, "w10", 4, { W10W });
	Token* X10 = new Token(TOKEN::VOLATILE, "x10", 8, { W10D });

	Token* W11B = new Token(TOKEN::VOLATILE, "w11", 1, {});
	Token* W11W = new Token(TOKEN::VOLATILE, "w11", 2, { W11B });
	Token* W11D = new Token(TOKEN::VOLATILE, "w11", 4, { W11W });
	Token* X11 = new Token(TOKEN::VOLATILE, "x11", 8, { W11D });

	Token* W12B = new Token(TOKEN::VOLATILE, "w12", 1, {});
	Token* W12W = new Token(TOKEN::VOLATILE, "w12", 2, { W12B });
	Token* W12D = new Token(TOKEN::VOLATILE, "w12", 4, { W12W });
	Token* X12 = new Token(TOKEN::VOLATILE, "x12", 8, { W12D });

	Token* W13B = new Token(TOKEN::VOLATILE, "w13", 1, {});
	Token* W13W = new Token(TOKEN::VOLATILE, "w13", 2, { W13B });
	Token* W13D = new Token(TOKEN::VOLATILE, "w13", 4, { W13W });
	Token* X13 = new Token(TOKEN::VOLATILE, "x13", 8, { W13D });

	Token* W14B = new Token(TOKEN::VOLATILE, "w14", 1, {});
	Token* W14W = new Token(TOKEN::VOLATILE, "w14", 2, { W14B });
	Token* W14D = new Token(TOKEN::VOLATILE, "w14", 4, { W14W });
	Token* X14 = new Token(TOKEN::VOLATILE,  "x14", 8, { W14D });

	Token* W15B = new Token(TOKEN::VOLATILE, "w15", 1, {});
	Token* W15W = new Token(TOKEN::VOLATILE, "w15", 2, { W15B });
	Token* W15D = new Token(TOKEN::VOLATILE, "w15", 4, { W15W });
	Token* X15 = new Token(TOKEN::VOLATILE,  "x15", 8, { W15D });

	Token* W16B = new Token(TOKEN::VOLATILE, "w16", 1, {});
	Token* W16W = new Token(TOKEN::VOLATILE, "w16", 2, { W16B });
	Token* W16D = new Token(TOKEN::VOLATILE, "w16", 4, { W16W });
	Token* X16 = new Token(TOKEN::VOLATILE, "x16", 8, { W16D });

	Token* W17B = new Token(TOKEN::VOLATILE, "w17", 1, {});
	Token* W17W = new Token(TOKEN::VOLATILE, "w17", 2, { W17B });
	Token* W17D = new Token(TOKEN::VOLATILE, "w17", 4, { W17W });
	Token* X17 = new Token(TOKEN::VOLATILE, "x17", 8, { W17D });

	Token* W18B = new Token(TOKEN::VOLATILE, "w18", 1, {});
	Token* W18W = new Token(TOKEN::VOLATILE, "w18", 2, { W18B });
	Token* W18D = new Token(TOKEN::VOLATILE, "w18", 4, { W18W });
	Token* X18 = new Token(TOKEN::VOLATILE, "x18", 8, { W18D });

	Token* W19B = new Token(TOKEN::NONVOLATILE, "w19", 1, {});
	Token* W19W = new Token(TOKEN::NONVOLATILE, "w19", 2, { W19B });
	Token* W19D = new Token(TOKEN::NONVOLATILE, "w19", 4, { W19W });
	Token* X19 = new Token(TOKEN::NONVOLATILE, "x19", 8, { W19D });

	Token* W20B = new Token(TOKEN::NONVOLATILE, "w20", 1, {});
	Token* W20W = new Token(TOKEN::NONVOLATILE, "w20", 2, { W20B });
	Token* W20D = new Token(TOKEN::NONVOLATILE, "w20", 4, { W20W });
	Token* X20 = new Token(TOKEN::NONVOLATILE, "x20", 8, { W20D });

	Token* W21B = new Token(TOKEN::NONVOLATILE, "w21", 1, {});
	Token* W21W = new Token(TOKEN::NONVOLATILE, "w21", 2, { W21B });
	Token* W21D = new Token(TOKEN::NONVOLATILE, "w21", 4, { W21W });
	Token* X21 = new Token(TOKEN::NONVOLATILE, "x21", 8, { W21D });

	Token* W22B = new Token(TOKEN::NONVOLATILE, "w22", 1, {});
	Token* W22W = new Token(TOKEN::NONVOLATILE, "w22", 2, { W22B });
	Token* W22D = new Token(TOKEN::NONVOLATILE, "w22", 4, { W22W });
	Token* X22 = new Token(TOKEN::NONVOLATILE, "x22", 8, { W22D });

	Token* W23B = new Token(TOKEN::NONVOLATILE, "w23", 1, {});
	Token* W23W = new Token(TOKEN::NONVOLATILE, "w23", 2, { W23B });
	Token* W23D = new Token(TOKEN::NONVOLATILE, "w23", 4, { W23W });
	Token* X23 = new Token(TOKEN::NONVOLATILE, "x23", 8, { W23D });

	Token* W24B = new Token(TOKEN::NONVOLATILE, "w24", 1, {});
	Token* W24W = new Token(TOKEN::NONVOLATILE, "w24", 2, { W24B });
	Token* W24D = new Token(TOKEN::NONVOLATILE, "w24", 4, { W24W });
	Token* X24 = new Token(TOKEN::NONVOLATILE, "x24", 8, { W24D });

	Token* W25B = new Token(TOKEN::NONVOLATILE, "w25", 1, {});
	Token* W25W = new Token(TOKEN::NONVOLATILE, "w25", 2, { W25B });
	Token* W25D = new Token(TOKEN::NONVOLATILE, "w25", 4, { W25W });
	Token* X25 = new Token(TOKEN::NONVOLATILE, "x25", 8, { W25D });

	Token* W26B = new Token(TOKEN::NONVOLATILE, "w26", 1, {});
	Token* W26W = new Token(TOKEN::NONVOLATILE, "w26", 2, { W26B });
	Token* W26D = new Token(TOKEN::NONVOLATILE, "w26", 4, { W26W });
	Token* X26 = new Token(TOKEN::NONVOLATILE, "x26", 8, { W26D });

	Token* W27B = new Token(TOKEN::NONVOLATILE, "w27", 1, {});
	Token* W27W = new Token(TOKEN::NONVOLATILE, "w27", 2, { W27B });
	Token* W27D = new Token(TOKEN::NONVOLATILE, "w27", 4, { W27W });
	Token* X27 = new Token(TOKEN::NONVOLATILE, "x27", 8, { W27D });

	Token* W28B = new Token(TOKEN::NONVOLATILE, "w28", 1, {});
	Token* W28W = new Token(TOKEN::NONVOLATILE, "w28", 2, { W28B });
	Token* W28D = new Token(TOKEN::NONVOLATILE, "w28", 4, { W28W });
	Token* X28 = new Token(TOKEN::NONVOLATILE, "x28", 8, { W28D });

	Token* W29B = new Token(TOKEN::NONVOLATILE, "w29", 1, {});
	Token* W29W = new Token(TOKEN::NONVOLATILE, "w29", 2, { W29B });
	Token* W29D = new Token(TOKEN::NONVOLATILE, "w29", 4, { W29W });
	Token* X29 = new Token(TOKEN::NONVOLATILE, "x29", 8, { W29D });




	//FPU REGISTERS:	
	/*
		B0
		H0
		S0
		D0
		Q0
	*/
	Token* B0 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER | TOKEN::RETURNING, "b0", 1, {});
	Token* H0 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER | TOKEN::RETURNING, "h0", 2, { B0 });
	Token* S0 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER | TOKEN::RETURNING, "s0", 4, { H0 });
	Token* D0 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER | TOKEN::RETURNING, "d0", 8, { S0 });
	Token* Q0 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER | TOKEN::RETURNING, "q0", 12, { D0 });
														   
	Token* B1 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "b1", 1, {});
	Token* H1 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "h1", 2, { B1 });
	Token* S1 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "s1", 4, { H1 });
	Token* D1 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "d1", 8, { S1 });
	Token* Q1 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "q1", 12, { D1 });
														   
	Token* B2 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "b2", 1, {});
	Token* H2 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "h2", 2, { B2 });
	Token* S2 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "s2", 4, { H2 });
	Token* D2 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "d2", 8, { S2 });
	Token* Q2 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "q2", 12, { D2 });
														   
	Token* B3 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "b3", 1, {});
	Token* H3 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "h3", 2, { B3 });
	Token* S3 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "s3", 4, { H3 });
	Token* D3 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "d3", 8, { S3 });
	Token* Q3 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "q3", 12, { D3 });
												   		   
	Token* B4 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "b4", 1, {});
	Token* H4 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "h4", 2, { B4 });
	Token* S4 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "s4", 4, { H4 });
	Token* D4 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "d4", 8, { S4 });
	Token* Q4 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "q4", 12, { D4 });
												   		   
	Token* B5 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "b5", 1, {});
	Token* H5 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "h5", 2, { B5 });
	Token* S5 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "s5", 4, { H5 });
	Token* D5 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "d5", 8, { S5 });
	Token* Q5 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "q5", 12, { D5 });
												   		   
	Token* B6 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "b6", 1, {});
	Token* H6 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "h6", 2, { B6 });
	Token* S6 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "s6", 4, { H6 });
	Token* D6 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "d6", 8, { S6 });
	Token* Q6 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "q6", 12, { D6 });
												   		   
	Token* B7 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "b7", 1, {});
	Token* H7 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "h7", 2, { B7 });
	Token* S7 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "s7", 4, { H7 });
	Token* D7 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "d7", 8, { S7 });
	Token* Q7 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL | TOKEN::PARAMETER, "q7", 12, { D7 });
												   		  
	Token* B8 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "b8", 1, {});
	Token* H8 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "h8", 2, { B8 });
	Token* S8 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "s8", 4, { H8 });
	Token* D8 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "d8", 8, { S8 });
	Token* Q8 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "q8", 12, { D8 });
												   		  
	Token* B9 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "b9", 1, {});
	Token* H9 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "h9", 2, { B9 });
	Token* S9 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "s9", 4, { H9 });
	Token* D9 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "d9", 8, { S9 });
	Token* Q9 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "q9", 12, { D9 });
												   
	Token* B10 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "b10", 1, {});
	Token* H10 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "h10", 2, { B10 });
	Token* S10 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "s10", 4, { H10 });
	Token* D10 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "d10", 8, { S10 });
	Token* Q10 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "q10", 12, { D10 });
												   
	Token* B11 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "b11", 1, {});
	Token* H11 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "h11", 2, { B11 });
	Token* S11 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "s11", 4, { H11 });
	Token* D11 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "d11", 8, { S11 });
	Token* Q11 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "q11", 12, { D11 });
												   
	Token* B12 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "b12", 1, {});
	Token* H12 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "h12", 2, { B12 });
	Token* S12 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "s12", 4, { H12 });
	Token* D12 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "d12", 8, { S12 });
	Token* Q12 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "q12", 12, { D12 });
												   
	Token* B13 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "b13", 1, {});
	Token* H13 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "h13", 2, { B13 });
	Token* S13 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "s13", 4, { H13 });
	Token* D13 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "d13", 8, { S13 });
	Token* Q13 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "q13", 12, { D13 });
												   
	Token* B14 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "b14", 1, {});
	Token* H14 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "h14", 2, { B14 });
	Token* S14 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "s14", 4, { H14 });
	Token* D14 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "d14", 8, { S14 });
	Token* Q14 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "q14", 12, { D14 });
												   
	Token* B15 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "b15", 1, {});
	Token* H15 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "h15", 2, { B15 });
	Token* S15 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "s15", 4, { H15 });
	Token* D15 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "d15", 8, { S15 });
	Token* Q15 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "q15", 12, { D15 });
												   
	Token* B16 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "b16", 1, {});
	Token* H16 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "h16", 2, { B16 });
	Token* S16 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "s16", 4, { H16 });
	Token* D16 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "d16", 8, { S16 });
	Token* Q16 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "q16", 12, { D16 });
												   
	Token* B17 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "b17", 1, {});
	Token* H17 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "h17", 2, { B17 });
	Token* S17 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "s17", 4, { H17 });
	Token* D17 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "d17", 8, { S17 });
	Token* Q17 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "q17", 12, { D17 });
												   
	Token* B18 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "b18", 1, {});
	Token* H18 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "h18", 2, { B18 });
	Token* S18 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "s18", 4, { H18 });
	Token* D18 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "d18", 8, { S18 });
	Token* Q18 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "q18", 12, { D18 });
												   
	Token* B19 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "b19", 1, {});
	Token* H19 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "h19", 2, { B19 });
	Token* S19 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "s19", 4, { H19 });
	Token* D19 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "d19", 8, { S19 });
	Token* Q19 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "q19", 12, { D19 });
												   
	Token* B20 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "b20", 1, {});
	Token* H20 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "h20", 2, { B20 });
	Token* S20 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "s20", 4, { H20 });
	Token* D20 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "d20", 8, { S20 });
	Token* Q20 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "q20", 12, { D20 });
												   
	Token* B21 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "b21", 1, {});
	Token* H21 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "h21", 2, { B21 });
	Token* S21 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "s21", 4, { H21 });
	Token* D21 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "d21", 8, { S21 });
	Token* Q21 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "q21", 12, { D21 });
												   
	Token* B22 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "b22", 1, {});
	Token* H22 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "h22", 2, { B22 });
	Token* S22 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "s22", 4, { H22 });
	Token* D22 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "d22", 8, { S22 });
	Token* Q22 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "q22", 12, { D22 });
												   
	Token* B23 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "b23", 1, {});
	Token* H23 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "h23", 2, { B23 });
	Token* S23 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "s23", 4, { H23 });
	Token* D23 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "d23", 8, { S23 });
	Token* Q23 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "q23", 12, { D23 });
												   
	Token* B24 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "b24", 1, {});
	Token* H24 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "h24", 2, { B24 });
	Token* S24 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "s24", 4, { H24 });
	Token* D24 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "d24", 8, { S24 });
	Token* Q24 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "q24", 12, { D24 });
												   
	Token* B25 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "b25", 1, {});
	Token* H25 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "h25", 2, { B25 });
	Token* S25 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "s25", 4, { H25 });
	Token* D25 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "d25", 8, { S25 });
	Token* Q25 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "q25", 12, { D25 });
												   
	Token* B26 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "b26", 1, {});
	Token* H26 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "h26", 2, { B26 });
	Token* S26 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "s26", 4, { H26 });
	Token* D26 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "d26", 8, { S26 });
	Token* Q26 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "q26", 12, { D26 });
												   
	Token* B27 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "b27", 1, {});
	Token* H27 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "h27", 2, { B27 });
	Token* S27 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "s27", 4, { H27 });
	Token* D27 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "d27", 8, { S27 });
	Token* Q27 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "q27", 12, { D27 });
												   
	Token* B28 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "b28", 1, {});
	Token* H28 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "h28", 2, { B28 });
	Token* S28 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "s28", 4, { H28 });
	Token* D28 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "d28", 8, { S28 });
	Token* Q28 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "q28", 12, { D28 });
												   
	Token* B29 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "b29", 1, {});
	Token* H29 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "h29", 2, { B29 });
	Token* S29 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "s29", 4, { H29 });
	Token* D29 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "d29", 8, { S29 });
	Token* Q29 = new Token(TOKEN::DECIMAL | TOKEN::NONVOLATILE, "q29", 12, { D29 });



	Token* SP = new Token(TOKEN::STACK_POINTTER, "sp", 8, {});

	Parameter_Registers = { X0, X1, X2, X3, X4, X5, X6, X7 , Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7};
	Registers = {
		W0B, W0W, W0D, X0,
		W1B, W1W, W1D, X1,
		W2B, W2W, W2D, X2,
		W3B, W3W, W3D, X3,
		W4B, W4W, W4D, X4,
		W5B, W5W, W5D, X5,
		W6B, W6W, W6D, X6,
		W7B, W7W, W7D, X7,
		W8B, W8W, W8D, X8,
		W9B, W9W, W9D, X9,
		W10B, W10W, W10D, X10,
		W11B, W11W, W11D, X11,
		W12B, W12W, W12D, X12,
		W13B, W13W, W13D, X13,
		W14B, W14W, W14D, X14,
		W15B, W15W, W15D, X15,
		W16B, W16W, W16D, X16,
		W17B, W17W, W17D, X17,
		W18B, W18W, W18D, X18,
		W19B, W19W, W19D, X19,
		W20B, W20W, W20D, X20,
		W21B, W21W, W21D, X21,
		W22B, W22W, W22D, X22,
		W23B, W23W, W23D, X23,
		W24B, W24W, W24D, X24,
		W25B, W25W, W25D, X25,
		W26B, W26W, W26D, X26,
		W27B, W27W, W27D, X27,
		W28B, W28W, W28D, X28,
		W29B, W29W, W29D, X29,

		B0, H0, S0, D0, Q0,
		B1, H1, S1, D1, Q1,
		B2, H2, S2, D2, Q2,
		B3, H3, S3, D3, Q3,
		B4, H4, S4, D4, Q4,
		B5, H5, S5, D5, Q5,
		B6, H6, S6, D6, Q6,
		B7, H7, S7, D7, Q7,
		B8, H8, S8, D8, Q8,
		B9, H9, S9, D9, Q9,
		B10, H10, S10, D10, Q10,
		B11, H11, S11, D11, Q11,
		B12, H12, S12, D12, Q12,
		B13, H13, S13, D13, Q13,
		B14, H14, S14, D14, Q14,
		B15, H15, S15, D15, Q15,
		B16, H16, S16, D16, Q16,
		B17, H17, S17, D17, Q17,
		B18, H18, S18, D18, Q18,
		B19, H19, S19, D19, Q19,
		B20, H20, S20, D20, Q20,
		B21, H21, S21, D21, Q21,
		B22, H22, S22, D22, Q22,
		B23, H23, S23, D23, Q23,
		B24, H24, S24, D24, Q24,
		B25, H25, S25, D25, Q25,
		B26, H26, S26, D26, Q26,
		B27, H27, S27, D27, Q27,
		B28, H28, S28, D28, Q28,
		B29, H29, S29, D29, Q29,

		SP,
	};

	IR* MOV_ALL = new IR("=", new Token(OPERATOR), {
		//accepted arguments
		{{Register, {1, 8}}, {Memory, {1, 8}} },
		{{Memory, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Const, {1, 8}} },
		{{Memory, {1, 8}}, {Const, {1, 8}} },

		{{Register_Float, {1, 8}}, {Memory_Float, {1, 8}} },
		{{Memory_Float, {1, 8}}, {Register_Float, {1, 8}} },
		{{Register_Float, {1, 8}}, {Register_Float, {1, 8}} },
		{{Register_Float, {1, 8}}, {Decimal, {1, 8}} },
		{{Memory_Float, {1, 8}}, {Decimal, {1, 8}} },
		},
		[](vector<Token*> args) {
			vector<IR*> Result;
			Token* Left = args[0];
			Token* Right = args[1];
			string Move = "mov";	//some genious decided that every move operator must have its own opcode naming :/

			long long Fpu = 0;
			if (Left->is(TOKEN::DECIMAL) || Right->is(TOKEN::DECIMAL)) {
				Move = "fmov";
				Fpu = TOKEN::DECIMAL;
			}

			if (Right->is(NUM)) {
				if (Left->is(REGISTER)) {
					long long Num = atoll(Right->Get_Name().c_str());
					if (Right->is(DECIMAL)) {
						if (Right->Get_Size() == 8) {
							double tmp = atof(Right->Get_Name().c_str());
							Num = *(long long*)&tmp;
						}
						else {
							float tmp = atof(Right->Get_Name().c_str());
							Num = *(long*)&tmp;
						}
					}
					if (Num > UINT16_MAX) {
						/*
						mov w0, 0001 0000 0000 0000
						mov w1, 0000 0000 0000 0001 
						lsl w1, w1, 16
						orr w0, w0, w1
						*/
						long long Chunk1 = Num & 0xffff;
						Token* Reg1 = new Token(REGISTER | Fpu, "REG_" + to_string(Reg_Random_ID_Addon++), 4);
						Result.push_back(new IR(new Token(OPERATOR, Move), { Reg1, new Token(NUM | Fpu, to_string(Chunk1), Reg1->Get_Size()) }, nullptr));
					
						long long Chunk2 = (Num >> 16 ) & 0xffff;
						Token* Reg2 = new Token(REGISTER | Fpu, "REG_" + to_string(Reg_Random_ID_Addon++), 4);
						Result.push_back(new IR(new Token(OPERATOR, Move), { Reg1, new Token(NUM | Fpu, to_string(Chunk2), Reg1->Get_Size()) }, nullptr));

						Result.push_back(new IR(new Token(OPERATOR, "lsl"), { Reg2, Reg2, new Token(NUM, to_string(16), Reg2->Get_Size()) }, nullptr));
						Result.push_back(new IR(new Token(OPERATOR, "orr"), { Reg1, Reg1, Reg2 }, nullptr));

						Right = Reg1;
					}
				}
				else {
					//of memory
					Token* Reg1 = new Token(REGISTER | Fpu, "REG_" + to_string(Reg_Random_ID_Addon++), Right->Get_Size());
					Result.push_back(new IR(new Token(OPERATOR, "="), { Reg1, Right }, nullptr));

					Result.push_back(new IR(new Token(OPERATOR, "="), { Left, Reg1 }, nullptr));
				}
			}

			if (Left->is(MEMORY)) {
				Token* tmp = Left;
				Left = Right;	//because some genious decided that storing must be left to right :/
				Right = tmp;
				Move = "str";
			}
			else if (Right->is(MEMORY)) {
				Move = "ldr";
			}
			
			Result.push_back(new IR(new Token(OPERATOR, Move), { Left, Right }, nullptr));

			return Result;
		}
	);

	IR* MOVE = new IR(*MOV_ALL);
	MOVE->ID = "move";

	IR* MOV = new IR("mov", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "mov"), {
		{{Register, {1, 8}}, {Const, {1, 8}} },
		{{Register, {1, 8}}, {Register, {1, 8}} },
	});

	IR* FMOV = new IR("fmov", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "fmov"), {
		{{Register_Float, {1, 8}}, {Decimal, {1, 8}} },
		{{Register_Float, {1, 8}}, {Register_Float, {1, 8}} },
	});


	IR* LDR = new IR("ldr", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "ldr"), {
		{{Register, {1, 8}}, {Memory, {1, 8}} },

		{{Register_Float, {1, 8}}, {Memory_Float, {1, 8}} },
		});

	IR* STR = new IR("str", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "str"), {
		{{Register, {1, 8}}, {Memory, {1, 8}} },

		{{Register_Float, {1, 8}}, {Memory_Float, {1, 8}} },
		});

	IR* LSL = new IR("lsl", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "lsl"), {
		{{Register, {1, 8}}, {Register, {1, 8}}, { Const, {1, 8}} },
	});

	IR* LSR = new IR("lsr", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "lsr"), {
		{{Register, {1, 8}}, {Register, {1, 8}}, { Const, {1, 8}} },
	});

	IR* FLSL = new IR("lsl", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "lsl"), {
		{{Register_Float, {1, 8}}, {Register_Float, {1, 8}}, { Const, {1, 8}} },
	});

	IR* FLSR = new IR("lsr", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "lsr"), {
		{{Register_Float, {1, 8}}, {Register_Float, {1, 8}}, { Const, {1, 8}} },
	});

	IR* SHIFT_LEFT = new IR("<<", new Token(OPERATOR | ALL_ARGS_SAME_SIZE), {
		{{Memory, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Const, {1, 8}} },
		{{Memory, {1, 8}}, {Const, {1, 8}} },
	},
		[](vector<Token*> args) {
			vector<IR*> Result;
			Result.push_back(new IR(new Token(OPERATOR, "lsl"), { args[0], args[0], args[1] }, nullptr));
			return Result;
		}
	);

	IR* SHIFT_RIGHT = new IR(">>", new Token(OPERATOR | ALL_ARGS_SAME_SIZE), {
	{{Memory, {1, 8}}, {Register, {1, 8}} },
	{{Register, {1, 8}}, {Register, {1, 8}} },
	{{Register, {1, 8}}, {Const, {1, 8}} },
	{{Memory, {1, 8}}, {Const, {1, 8}} },
		},
		[](vector<Token*> args) {
			vector<IR*> Result;
			Result.push_back(new IR(new Token(OPERATOR, "lsr"), { args[0], args[0], args[1] }, nullptr));
			return Result;
		}
	);

	IR* ORR = new IR("orr", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "orr"), {
		{{Register, {1, 8}}, {Register, {1, 8}}, { Const, {1, 8}} },
		{{Register, {1, 8}}, {Const, {1, 8}}, { Register, {1, 8}} },
		{{Register, {1, 8}}, {Const, {1, 8}}, { Const, {1, 8}} },
	});

	IR* FORR = new IR("orr", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "orr"), {
		{{Register_Float, {1, 8}}, {Register_Float, {1, 8}}, { Register_Float, {1, 8}} },
		{{Register_Float, {1, 8}}, {Register_Float, {1, 8}}, { Decimal, {1, 8}} },
		{{Register_Float, {1, 8}}, {Decimal, {1, 8}}, { Register_Float, {1, 8}} },
		{{Register_Float, {1, 8}}, {Decimal, {1, 8}}, { Decimal, {1, 8}} },
	});

	IR* OR = new IR("|", new Token(OPERATOR | ALL_ARGS_SAME_SIZE), {
		{{Memory, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Const, {1, 8}} },
		{{Memory, {1, 8}}, {Const, {1, 8}} },
	},
		[](vector<Token*> args) {
			vector<IR*> Result;
			Result.push_back(new IR(new Token(OPERATOR, "orr"), { args[0], args[0], args[1] }, nullptr));
			return Result;
		}
	);

	IR* ADD_LAMBDA = new IR("+", new Token(OPERATOR | ALL_ARGS_SAME_SIZE), {
		{{Register, {1, 8}}, {Memory, {1, 8}} },
		{{Memory, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Const, {1, 8}} },
		{{Memory, {1, 8}}, {Const, {1, 8}} },

		{{Register_Float, {1, 8}}, {Memory_Float, {1, 8}} },
		{{Memory_Float, {1, 8}}, {Register_Float, {1, 8}} },
		{{Register_Float, {1, 8}}, {Register_Float, {1, 8}} },
		{{Register_Float, {1, 8}}, {Decimal, {1, 8}} },
		{{Memory_Float, {1, 8}}, {Decimal, {1, 8}} },
	},
		[](vector<Token*> args) {
			vector<IR*> Result;
			Token* Left = args[0];
			Token* Right = args[1];

			long long Fpu = 0;
			if (Left->is(TOKEN::DECIMAL) || Right->is(TOKEN::DECIMAL))
				Fpu = TOKEN::DECIMAL;

			if (Right->is(NUM) && atoll(Right->Get_Name().c_str()) > 4095) {	//max 12bit number
				Token* Reg1 = new Token(REGISTER | Fpu, "REG_" + to_string(Reg_Random_ID_Addon++), Right->Get_Size());
				Result.push_back(new IR(new Token(OPERATOR, "="), { Reg1, Right }, nullptr));

				Right = Reg1;
			}

			Result.push_back(new IR(new Token(OPERATOR, "add"), { Left, Left, Right }, nullptr));

			return Result;
		}
	);

	IR* SUB_LAMBDA = new IR("-", new Token(OPERATOR | ALL_ARGS_SAME_SIZE), {
		{{Register, {1, 8}}, {Memory, {1, 8}} },
		{{Memory, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Const, {1, 8}} },
		{{Memory, {1, 8}}, {Const, {1, 8}} },

		{{Register_Float, {1, 8}}, {Memory_Float, {1, 8}} },
		{{Memory_Float, {1, 8}}, {Register_Float, {1, 8}} },
		{{Register_Float, {1, 8}}, {Register_Float, {1, 8}} },
		{{Register_Float, {1, 8}}, {Decimal, {1, 8}} },
		{{Memory_Float, {1, 8}}, {Decimal, {1, 8}} },
		},
		[](vector<Token*> args) {
			vector<IR*> Result;
			Token* Left = args[0];
			Token* Right = args[1];

			long long Fpu = 0;
			if (Left->is(TOKEN::DECIMAL) || Right->is(TOKEN::DECIMAL))
				Fpu = TOKEN::DECIMAL;

			if (Right->is(NUM) && atoll(Right->Get_Name().c_str()) > 4095) {	//max 12bit number
				Token* Reg1 = new Token(REGISTER | Fpu, "REG_" + to_string(Reg_Random_ID_Addon++), Right->Get_Size());
				Result.push_back(new IR(new Token(OPERATOR, "="), { Reg1, Right }, nullptr));

				Right = Reg1;
			}

			Result.push_back(new IR(new Token(OPERATOR, "sub"), { Left, Left, Right }, nullptr));

			return Result;
		}
	);

	IR* ADD = new IR("add", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "add"), {
		{{Register, {1, 8}}, {Register, {1, 8}}, {Memory, {1, 8}} },
		{{Memory, {1, 8}}, {Memory, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Register, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Register, {1, 8}}, {Const, {1, 8}} },
		{{Memory, {1, 8}}, {Memory, {1, 8}}, {Const, {1, 8}} },
	});

	IR* SUB = new IR("sub", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "sub"), {
		{{Register, {1, 8}}, {Register, {1, 8}}, {Memory, {1, 8}} },
		{{Memory, {1, 8}}, {Memory, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Register, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Register, {1, 8}}, {Const, {1, 8}} },
		{{Memory, {1, 8}}, {Memory, {1, 8}}, {Const, {1, 8}} },
	});

	IR* FADD = new IR("add", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "fadd"), {
		{{Register_Float, {1, 8}}, {Register_Float, {1, 8}}, {Memory_Float, {1, 8}} },
		{{Memory_Float, {1, 8}}, {Memory_Float, {1, 8}}, {Register_Float, {1, 8}} },
		{{Register_Float, {1, 8}}, {Register_Float, {1, 8}}, {Register_Float, {1, 8}} },
		{{Register_Float, {1, 8}}, {Register_Float, {1, 8}}, {Decimal, {1, 8}} },
		{{Memory_Float, {1, 8}}, {Memory_Float, {1, 8}}, {Decimal, {1, 8}} },
	});

	IR* FSUB = new IR("sub", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "fsub"), {
		{{Register_Float, {1, 8}}, {Register_Float, {1, 8}}, {Memory_Float, {1, 8}} },
		{{Memory_Float, {1, 8}}, {Memory_Float, {1, 8}}, {Register_Float, {1, 8}} },
		{{Register_Float, {1, 8}}, {Register_Float, {1, 8}}, {Register_Float, {1, 8}} },
		{{Register_Float, {1, 8}}, {Register_Float, {1, 8}}, {Decimal, {1, 8}} },
		{{Memory_Float, {1, 8}}, {Memory_Float, {1, 8}}, {Decimal, {1, 8}} },
	});


	IR* MUL_LAMBDA = new IR("*", new Token(OPERATOR | ALL_ARGS_SAME_SIZE), {
		{{Register, {1, 8}}, {Memory, {1, 8}} },
		{{Memory, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Const, {1, 8}} },
		{{Memory, {1, 8}}, {Const, {1, 8}} },

		{{Register_Float, {1, 8}}, {Memory_Float, {1, 8}} },
		{{Memory_Float, {1, 8}}, {Register_Float, {1, 8}} },
		{{Register_Float, {1, 8}}, {Register_Float, {1, 8}} },
		{{Register_Float, {1, 8}}, {Decimal, {1, 8}} },
		{{Memory_Float, {1, 8}}, {Decimal, {1, 8}} },
		},
		[](vector<Token*> args) {
			vector<IR*> Result;
			Token* Left = args[0];
			Token* Right = args[1];

			long long Fpu = 0;
			if (Left->is(TOKEN::DECIMAL) || Right->is(TOKEN::DECIMAL))
				Fpu = TOKEN::DECIMAL;

			if (Right->is(NUM)) {
				Token* Reg1 = new Token(REGISTER | Fpu, "REG_" + to_string(Reg_Random_ID_Addon++), Right->Get_Size());
				Result.push_back(new IR(new Token(OPERATOR, "="), { Reg1, Right }, nullptr));

				Right = Reg1;
			}

			Result.push_back(new IR(new Token(OPERATOR, "mul"), { Left, Left, Right }, nullptr));

			return Result;
		}
	);

	IR* MUL = new IR("mul", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "mul"), {
		{{Register, {1, 8}}, {Register, {1, 8}}, {Memory, {1, 8}} },
		{{Memory, {1, 8}}, {Memory, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Register, {1, 8}}, {Register, {1, 8}} },
	});

	IR* FMUL = new IR("mul", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "fmul"), {
		{{Register_Float, {1, 8}}, {Register_Float, {1, 8}}, {Memory_Float, {1, 8}} },
		{{Memory_Float, {1, 8}}, {Memory_Float, {1, 8}}, {Register_Float, {1, 8}} },
		{{Register_Float, {1, 8}}, {Register_Float, {1, 8}}, {Register_Float, {1, 8}} },
	});

	IR* DIV_LAMBDA = new IR("/", new Token(OPERATOR | ALL_ARGS_SAME_SIZE), {
		{{Register, {1, 8}}, {Memory, {1, 8}} },
		{{Memory, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Const, {1, 8}} },
		{{Memory, {1, 8}}, {Const, {1, 8}} },

		{{Register_Float, {1, 8}}, {Memory_Float, {1, 8}} },
		{{Memory_Float, {1, 8}}, {Register_Float, {1, 8}} },
		{{Register_Float, {1, 8}}, {Register_Float, {1, 8}} },
		{{Register_Float, {1, 8}}, {Decimal, {1, 8}} },
		{{Memory_Float, {1, 8}}, {Decimal, {1, 8}} },
		},
		[](vector<Token*> args) {
			vector<IR*> Result;
			Token* Left = args[0];
			Token* Right = args[1];

			long long Fpu = 0;
			if (Left->is(TOKEN::DECIMAL) || Right->is(TOKEN::DECIMAL))
				Fpu = TOKEN::DECIMAL;

			if (Right->is(NUM)) {
				Token* Reg1 = new Token(REGISTER | Fpu, "REG_" + to_string(Reg_Random_ID_Addon++), Right->Get_Size());
				Result.push_back(new IR(new Token(OPERATOR, "="), { Reg1, Right }, nullptr));

				Right = Reg1;
			}

			Result.push_back(new IR(new Token(OPERATOR, "div"), { Left, Left, Right }, nullptr));

			return Result;
		}
	);

	IR* DIV = new IR("div", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "sdiv"), {
		{{Register, {1, 8}}, {Register, {1, 8}}, {Memory, {1, 8}} },
		{{Memory, {1, 8}}, {Memory, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Register, {1, 8}}, {Register, {1, 8}} },
	});

	IR* FDIV = new IR("div", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "fdiv"), {
		{{Register_Float, {1, 8}}, {Register_Float, {1, 8}}, {Memory_Float, {1, 8}} },
		{{Memory_Float, {1, 8}}, {Memory_Float, {1, 8}}, {Register_Float, {1, 8}} },
		{{Register_Float, {1, 8}}, {Register_Float, {1, 8}}, {Register_Float, {1, 8}} },
	});

	IR* LEA_MEM = new IR("evaluate", new Token(OPERATOR | ALL_ARGS_SAME_SIZE), {
		{{Register, {1, 8}}, {Memory, {1, 8}} },
	},
	[](vector<Token*> args) {
			vector<IR*> Result;
			//un-wrap memory contents into argument styled listing.
			string Eval_Type = "add";

			pair<vector<Token*>, bool> tmp = Un_Wrap_Content(args[1]);

			tmp.first.insert(tmp.first.begin(), args[0]);

			if (!tmp.second)
				Eval_Type = "sub";

			Result.push_back(new IR(new Token(OPERATOR, Eval_Type), tmp.first, nullptr));

			return Result;
		}
	);

	IR* LEA_LABEL = new IR("evaluate", new Token(OPERATOR | ALL_ARGS_SAME_SIZE), {
		{{Register, {1, 8}}, {Label, {0, 0}} },
	},
	[](vector<Token*> args) {
			vector<IR*> Result;

			//adrp reg1, :got:label
			//ldr reg1, [reg1, :got_lo12:label]

			Result.push_back(new IR(new Token(OPERATOR, "adrp"), {
				args[0], new Token(LABEL, ":got:" + args[1]->Get_Name(), 0)
			}, nullptr));

			Result.push_back(new IR(new Token(OPERATOR, "ldr"), {
				args[0], new Token(MEMORY, "MEM_" + args[1]->Get_Name(), _SYSTEM_BIT_SIZE_, {new Token(OFFSETTER, ",", args[0], new Token(LABEL, ":got_lo12:" + args[1]->Get_Name(), 0))})
			}, nullptr));

			return Result;
		}
	);

	IR* ADRP = new IR("adrp", new Token(OPERATOR | ALL_ARGS_SAME_SIZE), { {
		{Register, {1, 8}}, {Label, {0, 0}} },
	});

	IR* BL = new IR("call", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "bl"), {
		{{Label, {0, 0}}},
		{{Register, {_SYSTEM_BIT_SIZE_, _SYSTEM_BIT_SIZE_}}},
	});

	IR* CMP = new IR("compare", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "cmp"), {
		{{Register, {1, 8}}, {Register, {1, 8}}},
		{{Register, {1, 8}}, {Memory, {1, 8}}},
		{{Memory, {1, 8}}, {Register, {1, 8}}},
		{{Register,  {1, 8}}, {Const, {1, 8}}},

		{{Register_Float, {1, 8}}, {Memory_Float, {1, 8}} },
		{{Memory_Float, {1, 8}}, {Register_Float, {1, 8}} },
		{{Register_Float, {1, 8}}, {Register_Float, {1, 8}} },
		{{Register_Float, {1, 8}}, {Decimal, {1, 8}} },
		{{Memory_Float, {1, 8}}, {Decimal, {1, 8}} },
	});

	IR* B = new IR("jump", new Token(FLOW, "b"), { {{Label, {0, 0}}} });
	IR* BEQ = new IR("==", new Token(FLOW, "b.eq"), { {{Label, {0, 0}}} });
	IR* BNE = new IR("!=", new Token(FLOW, "b.ne"), { {{Label, {0, 0}}} });
	IR* BLE = new IR("<", new Token(FLOW, "b.lt"), { {{Label, {0, 0}}} });
	IR* BLT = new IR("<=", new Token(FLOW, "b.le"), { {{Label, {0, 0}}} });
	IR* BNL = new IR("!<", new Token(FLOW, "b.ge"), { {{Label, {0, 0}}} });
	IR* BGE = new IR(">", new Token(FLOW, "b.gt"), { {{Label, {0, 0}}} });
	IR* BGT = new IR(">=", new Token(FLOW, "b.ge"), { {{Label, {0, 0}}} });
	IR* BNG = new IR("!>", new Token(FLOW, "b.le"), { {{Label, {0, 0}}} });

	IR* RET = new IR("return", new Token(FLOW, "ret"), {});

	IR* GLOBAL = new IR("global", new Token(TOKEN::GLOBAL_LABEL, ".global"), {
		{{Label, {0, 0}}}
		});
	IR* EXTERN = new IR("extern", new Token(TOKEN::GLOBAL_LABEL, ".extern"), {
		{{Label, {0, 0}}}
		});

	//FCVTZS float to int
	//SCVTF int to float
	//fcvt float to double and double to float

	IR* FCSTZS = new IR("convert", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "fcvtzs"), {
		{{Register, {4, 4}}, {Register_Float, {4, 4}} },
	});

	IR* SCSTF = new IR("convert", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "scvtf"), {
		{{Register_Float, {4, 4}}, {Register, {4, 4}} },
	});

	IR* FCVT = new IR("convert", new Token(OPERATOR, "fcvt"), {
		{{Register_Float, {4, 8}}, {Register_Float, {4, 8}} },
	});

	IR* PUSH = new IR("push", new Token(TOKEN::OPERATOR), 
		{
			{{Register, {1, 8}}},
		}, 
		[](vector<Token*> args) {
			vector<IR*> Result;

			Token* Stack = new Token(STACK_POINTTER | REGISTER, ".STACK", _SYSTEM_BIT_SIZE_);

			//str args[0], [sp]
			Result.push_back(new IR(new Token(OPERATOR, "str"), {
				args[0], new Token(MEMORY,args[0]->Get_Name() + "stack" , args[0]->Get_Size(), {Stack})
			}, nullptr));

			//sub sp, sp, args[0].size
			Result.push_back(new IR(new Token(OPERATOR, "sub"), {
				Stack, Stack, new Token(NUM, to_string(args[0]->Get_Size()), _SYSTEM_BIT_SIZE_)
			}, nullptr));

			return Result;
		}
	);

	IR* POP = new IR("pop", new Token(TOKEN::OPERATOR),
		{
			{{Register, {1, 8}}},
		},
		[](vector<Token*> args) {
			vector<IR*> Result;

			Token* Stack = new Token(STACK_POINTTER | REGISTER, ".STACK", _SYSTEM_BIT_SIZE_);

			//ldr args[0], [sp]
			Result.push_back(new IR(new Token(OPERATOR, "ldr"), {
				args[0], new Token(MEMORY,args[0]->Get_Name() + "stack" , args[0]->Get_Size(), {Stack})
				}, nullptr));

			//add sp, sp, args[0].size
			Result.push_back(new IR(new Token(OPERATOR, "add"), {
				Stack, Stack, new Token(NUM, to_string(args[0]->Get_Size()), _SYSTEM_BIT_SIZE_)
				}, nullptr));

			return Result;
		}
	);

	Opcodes = {
		MOV_ALL, MOVE, MOV, LDR, STR,
		LSL, LSR, SHIFT_LEFT, SHIFT_RIGHT,
		ORR, OR, FORR,
		ADD_LAMBDA, ADD, LEA_MEM, LEA_LABEL, ADRP,
		SUB_LAMBDA, SUB,
		MUL, MUL_LAMBDA, DIV, DIV_LAMBDA,
		BL, B, BEQ, BNE, BLE, BLT, BNL, BGE, BGT, BNG,
		RET, PUSH, POP,
		GLOBAL, EXTERN,
		FADD, FSUB, FMUL, FDIV, FLSL, FLSR, FMOV,
		FCSTZS, SCSTF, FCVT,
	};
}

pair<vector<Token*>, bool> ARM_64::Un_Wrap_Content(Token* t)
{
	vector<Token*> Result;
	bool Positive_Offsetter = true;

	if (t->is(TOKEN::MEMORY))
		for (auto c : t->Childs) {
			pair<vector<Token*>, bool> tmp = Un_Wrap_Content(c);
			Result.insert(Result.end(), tmp.first.begin(), tmp.first.end());
			if (!tmp.second)
				Positive_Offsetter = false;
		}
	else if (t->is(TOKEN::OFFSETTER) || t->is(TOKEN::DEOFFSETTER) || t->is(TOKEN::SCALER)) {
		pair<vector<Token*>, bool> tmp = Un_Wrap_Content(t->Left);
		Result.insert(Result.end(), tmp.first.begin(), tmp.first.end());
		if (!tmp.second)
			Positive_Offsetter = false;

		tmp = Un_Wrap_Content(t->Right);
		Result.insert(Result.end(), tmp.first.begin(), tmp.first.end());
		if (!tmp.second)
			Positive_Offsetter = false;
	}
	else {
		Result.push_back(t);
	}

	if (t->is(TOKEN::DEOFFSETTER))
		Positive_Offsetter = false;

	return { Result, Positive_Offsetter };

}

C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Cpp\BackEnd\BackEnd.cpp" 
#include "../../H/BackEnd/BackEnd.h"

extern Node* Global_Scope;
extern Usr* sys;
extern x86_64 X86_64;
extern ARM_64 _ARM_64;
extern Selector* selector;

void BackEnd::Init()
{
	if (sys->Info.Architecture == "x86") {
		if (sys->Info.Bits_Mode == "8") {
			Seperator = X86_64.Seperator;
			Register_Pre_Fix = X86_64.Register_Pre_Fix;
			Number_Pre_Fix = X86_64.Number_Pre_Fix;
			Label_Post_Fix = X86_64.Label_Post_Fix;
		}

	}	
	else if (sys->Info.Architecture == "arm") {
		if (sys->Info.Bits_Mode == "8") {
			if (sys->Info.OS == "win" || sys->Info.OS == "unix") {
				Seperator = _ARM_64.Seperator;
				Register_Pre_Fix = _ARM_64.Register_Pre_Fix;
				Number_Pre_Fix = _ARM_64.Number_Pre_Fix;
				Label_Post_Fix = _ARM_64.Label_Post_Fix;
			}
		}

	}
}

void BackEnd::Factory()
{
	int j = 0;
	for (auto i : Input) {
		Label_Builder(i);
		Global_Builder(i);
		Operator_Builder(i);
		End_Of_Function_Builder(i);
		Call_Builder(i);
		j++;
	}
}

void BackEnd::Operator_Builder(IR* i)
{
	//leave data handling into other algorithm
	if (!i->is(TOKEN::OPERATOR) && !i->is(TOKEN::FLOW) && !i->is(TOKEN::SET_DATA))
		return;
	//get the needed opcode
	IR* opc = selector->Get_Opcode(i);
	*Output += opc->OPCODE->Get_Name() + " ";

	//set up the parameters
	for (int p = 0; p < i->Arguments.size(); p++) {
		*Output += Token_Builder(i->Arguments[p], i->is(TOKEN::SET_DATA));
		if ((size_t)p + 1 < i->Arguments.size()) {
			*Output += Seperator + " ";
		}
	}
	//set up the next line

	string Comment = "\t\t#";

	for (int j = 0; j < i->Arguments.size(); j++) {
		Comment += i->Arguments[j]->Get_Name();
		if (j != i->Arguments.size() - 1)
			Comment += ", ";
	}

	*Output += Comment + "\n";
}

void BackEnd::Label_Builder(IR* i)
{
	if (!i->is(TOKEN::LABEL))
		return;

	*Output += i->OPCODE->Get_Name() + Label_Post_Fix + "\n";
}

void BackEnd::End_Of_Function_Builder(IR* i)
{
	if (!i->is(TOKEN::END_OF_FUNCTION))
		return;

	*Output += "\n\n";
}

void BackEnd::Call_Builder(IR* i)
{
	if (!i->is(TOKEN::CALL))
		return;

	IR* call_opc = selector->Get_Opcode(i);
	*Output += call_opc->OPCODE->Get_Name();

	*Output += " " + Token_Builder(i->Arguments[0]) + "\n";
}

void BackEnd::Global_Builder(IR* i)
{
	if (!i->is(TOKEN::GLOBAL_LABEL))
		return;

	IR* glob = selector->Get_Opcode(i);
	*Output += glob->OPCODE->Get_Name();

	*Output += " " + Token_Builder(i->Arguments[0]) + "\n";
}

string BackEnd::Token_Builder(Token* t, bool Inside_Content)
{
	string PreFix = "";
	string PostFix = "";
	string Result = "";
	string Name = "";
	if (t->is(TOKEN::REGISTER) || t->is(TOKEN::NONVOLATILE) || t->is(TOKEN::RETURNING) || t->is(TOKEN::QUOTIENT) || t->is(TOKEN::REMAINDER) || t->is(TOKEN::PARAMETER)) {
		Name = t->ID;
	}
	else if (t->is(TOKEN::NUM) || (t->is(TOKEN::DECIMAL) && !t->is(TOKEN::MEMORY))) {
		//if (Inside_Content)
		Name = t->Get_Name();
		//else
		//	Name = selector->Get_Size_Identifier(t->Get_Size()) + " " + t->Get_Name();
	}
	else if (t->is(TOKEN::STRING))
		Name = "\"" + t->Get_Name() + "\"";
	else if (t->is(TOKEN::GLOBAL_VARIABLE))
		//Name = selector->Get_Size_Identifier(t->Get_Size()) + "[" + t->Get_Name() + "]";
		Name = t->Get_Name();
	else if (t->is(TOKEN::MEMORY)) {
		if (Inside_Content)
			PreFix = t->Get_Name();
		else
			PreFix = selector->Get_Size_Identifier(t->Get_Size()) + " [";
		for (auto i : t->Childs)
			Name += Token_Builder(i, true) + " ";
		PostFix = "]";
	}
	else if (t->is(TOKEN::CONTENT)) {
		PreFix = "(";
		for (auto i : t->Childs)
			Name += Token_Builder(i, true);
		PostFix = ")";
	}
	else if (t->is(TOKEN::OFFSETTER) || t->is(TOKEN::SCALER) || t->is(TOKEN::DEOFFSETTER)) {
		Name += Token_Builder(t->Left, true) + " " + t->Get_Name() + " " + Token_Builder(t->Right, true);
	}
	else if (t->is(TOKEN::LABEL))
		Name = t->Get_Name();

	Result = PreFix + Name + PostFix;
	return Result;
}

C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Cpp\BackEnd\DebugGenerator.cpp" 
#include "../../H/BackEnd/DebugGenerator.h"

namespace DW_TAG {
    constexpr int Namelist = 0x2b;
    constexpr int Namelist_item = 0x2c;
    constexpr int Packed_type = 0x2d;
    constexpr int Subprogram = 0x2e;
    constexpr int Template_type_parameter = 0x2f;
    constexpr int Template_value_parameter = 0x30;
    constexpr int Thrown_type = 0x31;
    constexpr int Try_block = 0x32;
    constexpr int Variant_part = 0x33;
    constexpr int Variable = 0x34;
    constexpr int Volatile_type = 0x35;
    constexpr int Dwarf_procedure = 0x36;
    constexpr int Restrict_type = 0x37;
    constexpr int Interface_type = 0x38;
    constexpr int Namespace = 0x39;
    constexpr int Imported_module = 0x3a;
    constexpr int Unspecified_type = 0x3b;
    constexpr int Partial_unit = 0x3c;
    constexpr int Imported_unit = 0x3d;
    constexpr int Condition = 0x3f;
    constexpr int Union_type = 0x17;
    constexpr int Unspecified_parameters = 0x18;
    constexpr int Variant = 0x19;
    constexpr int Common_block = 0x1a;
    constexpr int Common_inclusion = 0x1b;
    constexpr int Inheritance = 0x1c;
    constexpr int Inlined_subroutine = 0x1d;
    constexpr int Module = 0x1e;
    constexpr int Ptr_to_member_type = 0x1f;
    constexpr int Set_type = 0x20;
    constexpr int Subrange_type = 0x21;
    constexpr int With_stmt = 0x22;
    constexpr int Access_declaration = 0x23;
    constexpr int Base_type = 0x24;
    constexpr int Catch_block = 0x25;
    constexpr int Const_type = 0x26;
    constexpr int Constant = 0x27;
    constexpr int Enumerator = 0x28;
    constexpr int File_type = 0x29;
    constexpr int Friend = 0x2a;
    constexpr int Array_type = 0x01;
    constexpr int Class_type = 0x02;
    constexpr int Entry_point = 0x03;
    constexpr int Enumeration_type = 0x04;
    constexpr int Formal_parameter = 0x05;
    constexpr int Imported_declaration = 0x08;
    constexpr int Label = 0x0a;
    constexpr int Lexical_block = 0x0b;
    constexpr int Member = 0x0d;
    constexpr int Pointer_type = 0x0f;
    constexpr int Reference_type = 0x10;
    constexpr int Compile_unit = 0x11;
    constexpr int String_type = 0x12;
    constexpr int Structure_type = 0x13;
    constexpr int Subroutine_type = 0x15;
    constexpr int Typedef = 0x16;
}

namespace DW_CHILDREN {
    int No = 0x00;
    int Yes = 0x01;
}

namespace DW_AT {
    constexpr int Sibling = 0x01;
    constexpr int Location = 0x02;
    constexpr int Name = 0x03;
    constexpr int Ordering = 0x09;
    constexpr int Byte_size = 0x0b;
    constexpr int Bit_offset = 0x0c;
    constexpr int Bit_size = 0x0d;
    constexpr int Stmt_list = 0x10;
    constexpr int Low_pc = 0x11;
    constexpr int High_pc = 0x12;
    constexpr int Language = 0x13;
    constexpr int Discr = 0x15;
    constexpr int Discr_value = 0x16;
    constexpr int Visibility = 0x17;
    constexpr int Import = 0x18;
    constexpr int String_length = 0x19;
    constexpr int Common_reference = 0x1a;
    constexpr int Comp_dir = 0x1b;
    constexpr int Const_value = 0x1c;
    constexpr int Threads_scaled = 0x62;
    constexpr int Explicit = 0x63;
    constexpr int Object_pointer = 0x64;
    constexpr int Endianity = 0x65;
    constexpr int Elemental = 0x66;
    constexpr int Pure = 0x67;
    constexpr int Recursive = 0x68;
    constexpr int Signature = 0x69;
    constexpr int Main_subprogram = 0x6a;
    constexpr int Data_bit_offset = 0x6b;
    constexpr int Const_expr = 0x6c;
    constexpr int Enum_class = 0x6d;
    constexpr int Linkage_name = 0x6e;
    constexpr int Lo_user = 0x2000;
    constexpr int Hi_user = 0x3fff;
    constexpr int Decl_file = 0x3a;
    constexpr int Decl_line = 0x3b;
    constexpr int Declaration = 0x3c;
    constexpr int Discr_list = 0x3d;
    constexpr int Encoding = 0x3e;
    constexpr int External = 0x3f;
    constexpr int Frame_base = 0x40;
    constexpr int Friend = 0x41;
    constexpr int Identifier_case = 0x42;
    constexpr int Macro_info = 0x43;
    constexpr int Namelist_item = 0x44;
    constexpr int Priority = 0x45;
    constexpr int Segment = 0x46;
    constexpr int Specification = 0x47;
    constexpr int Static_link = 0x48;
    constexpr int Type = 0x49;
    constexpr int Use_location = 0x4a;
    constexpr int Variable_parameter = 0x4b;
    constexpr int Virtuality = 0x4c;
    constexpr int Vtable_elem_location = 0x4d;
    constexpr int Containing_type = 0x1d;
    constexpr int Default_value = 0x1e;
    constexpr int Inline = 0x20;
    constexpr int Is_optional = 0x21;
    constexpr int Lower_bound = 0x22;
    constexpr int Producer = 0x25;
    constexpr int Prototyped = 0x27;
    constexpr int Return_addr = 0x2a;
    constexpr int Start_scope = 0x2c;
    constexpr int Bit_stride = 0x2e;
    constexpr int Upper_bound = 0x2f;
    constexpr int Abstract_origin = 0x31;
    constexpr int Accessibility = 0x32;
    constexpr int Address_class = 0x33;
    constexpr int Artificial = 0x34;
    constexpr int Base_types = 0x35;
    constexpr int Calling_convention = 0x36;
    constexpr int Count = 0x37;
    constexpr int Data_member_location = 0x38;
    constexpr int Decl_column = 0x39;
    constexpr int Allocated = 0x4e;
    constexpr int Associated = 0x4f;
    constexpr int Data_location = 0x50;
    constexpr int Byte_stride = 0x51;
    constexpr int Entry_pc = 0x52;
    constexpr int Use_UTF8 = 0x53;
    constexpr int Extension = 0x54;
    constexpr int Ranges = 0x55;
    constexpr int Trampoline = 0x56;
    constexpr int Call_column = 0x57;
    constexpr int Call_file = 0x58;
    constexpr int Call_line = 0x59;
    constexpr int Description = 0x5a;
    constexpr int Binary_scale = 0x5b;
    constexpr int Decimal_scale = 0x5c;
    constexpr int Small = 0x5d;
    constexpr int Decimal_sign = 0x5e;
    constexpr int Digit_count = 0x5f;
    constexpr int Picture_string = 0x60;
    constexpr int Mutable = 0x61;
}

namespace DW_FORM {
    constexpr int Addr = 0x01;
    constexpr int Block2 = 0x03;
    constexpr int Block4 = 0x04;
    constexpr int Data2 = 0x05;
    constexpr int Data4 = 0x06;
    constexpr int Data8 = 0x07;
    constexpr int String = 0x08;
    constexpr int Block = 0x09;
    constexpr int Block1 = 0x0a;
    constexpr int Data1 = 0x0b;
    constexpr int Flag = 0x0c;
    constexpr int Sdata = 0x0d;
    constexpr int Strp = 0x0e;
    constexpr int Udata = 0x0f;
    constexpr int Ref_addr = 0x10;
    constexpr int Ref1 = 0x11;
    constexpr int Ref2 = 0x12;
    constexpr int Ref4 = 0x13;
    constexpr int Ref8 = 0x14;
    constexpr int Ref_udata = 0x15;
    constexpr int Indirect = 0x16;
    constexpr int Sec_offset = 0x17;
    constexpr int Exprloc = 0x18;
    constexpr int Flag_present = 0x19;
    constexpr int Ref_sig8 = 0x20;
}

constexpr int DW_ATE_address = 0x01;
constexpr int DW_ATE_float = 0x04;
constexpr int DW_ATE_signed = 0x05;
constexpr int DW_ATE_signed_char = 0x06;

DebugGenerator::DebugGenerator(vector<IR*> &Input)
{
    Define_File_Index();
    Insert_Start_End_Labels(Input);
    Insert_Line_Change_Information(Input);
    Insert_Stack_Info(Input);

    Construct_Debug_Abbrev();
    Construct_Debug_Info();
    Construct_Debug_String();
    Construct_Line_Table();

    DOCKER::Append(Input, File_Index, 0);
    DOCKER::Append(Input, Debug_Abbrev);
    DOCKER::Append(Input, Debug_Info);
    DOCKER::Append(Input, Debug_Str);
    DOCKER::Append(Input, Debug_Line);
    DOCKER::Append(Input, Line_Table);

}

void DebugGenerator::Construct_Debug_Abbrev()
{
    //THE INFORMATION THAT IS DESCRIBED BELOW IS FROM http://www.dwarfstd.org/doc/DWARF4.pdf
    
    //                                                                                    .debug_abbrev,"",@progbits
    IR* Section = new IR(new Token(TOKEN::OPERATOR, "section"), {new Token(TOKEN::LABEL, ".debug_abbrev")}, nullptr);
    Debug_Abbrev.push_back(Section); 
    //tmp
    IR* debug_abbrev = new IR(new Token(TOKEN::LABEL, "debug_abbrev"), {}, nullptr);
    Debug_Abbrev.push_back(debug_abbrev);
    //Abbreviation Code describes the current section as an index
    IR* Abbreviation_Code_Describing_Index = new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, "1", 1) }, nullptr);
    Debug_Abbrev.push_back(Abbreviation_Code_Describing_Index);
    //A normal compilation unit is represented by a debugging information entry with the tag DW_TAG_compile_unit.
    IR* DW_TAG_Compile_Unit = new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, "17", 1) }, nullptr);
    Debug_Abbrev.push_back(DW_TAG_Compile_Unit);
    // determines whether a debugging information entry using this abbreviation has child entries or not.
    IR* DW_CHILDREN_Yes = new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, "1", 1) }, nullptr);
    Debug_Abbrev.push_back(DW_CHILDREN_Yes);
    //Name of the compiler that made this code
    IR* DW_AT_Producer = new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, "37", 1) }, nullptr);
    Debug_Abbrev.push_back(DW_AT_Producer);
    //Attribute values of class
    IR* DW_FORM_Strp = new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, "14", 1) }, nullptr);
    Debug_Abbrev.push_back(DW_FORM_Strp);
    // indicating the source language of the compilation unit.
    IR* DW_AT_Language = new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, "19", 1) }, nullptr);
    Debug_Abbrev.push_back(DW_AT_Language);
    // fixed length constant data forms for one, two, four and eight byte values
    IR* DW_FORM_Data2 = new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, "5", 1) }, nullptr);
    Debug_Abbrev.push_back(DW_FORM_Data2);
    //representing a program entity
    IR* DW_AT_Name = new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, "3", 1) }, nullptr);
    Debug_Abbrev.push_back(DW_AT_Name);
    //Attribute values of class
    DW_FORM_Strp;
    Debug_Abbrev.push_back(DW_FORM_Strp);
    //section offset to the line number information for this compilation unit.
    IR* DW_AT_Stmt_List = new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, "16", 1) }, nullptr);
    Debug_Abbrev.push_back(DW_AT_Stmt_List);
    //lineptr, loclistptr, macptr or rangelistptr.
    IR* DW_FORM_Sec_Offset = new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, "23", 1) }, nullptr);
    Debug_Abbrev.push_back(DW_FORM_Sec_Offset);
    //containing the current working directory of the compilation command that produced this compilation unit.
    IR* DW_AT_Comp_Dir = new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, "27", 1) }, nullptr);
    Debug_Abbrev.push_back(DW_AT_Comp_Dir);
    //Attribute values of class
    DW_FORM_Strp;
    Debug_Abbrev.push_back(DW_FORM_Strp);
    //The base address of a compilation unit
    IR* DW_AT_Low_Pc = new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_AT::Low_pc), 1) }, nullptr);
    Debug_Abbrev.push_back(DW_AT_Low_Pc);
    //Represented as an object of appropriate size to hold an address.
    IR* DW_FORM_Addr = new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_FORM::Addr), 1) }, nullptr);
    Debug_Abbrev.push_back(DW_FORM_Addr);
    //addresses of a debugging information entry.
    IR* DW_AT_High_Pc = new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_AT::High_pc), 1) }, nullptr);
    Debug_Abbrev.push_back(DW_AT_High_Pc);
    //Add a new attribute form for section offsets.
    IR* DW_FORM_Data4 = new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_FORM::Data4), 1) }, nullptr);
    Debug_Abbrev.push_back(DW_FORM_Data4);
    //End of marker
    IR* EOM = new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, "0", 1) }, nullptr);
    Debug_Abbrev.push_back(EOM);
    //End of marker
    EOM;
    Debug_Abbrev.push_back(EOM);

    for (auto i : Global_Scope->Defined) {
        if (i->Is_Template_Object)
            continue;
        Generate_Abbrev(Abbrev_Type(i));
        for (auto j : i->Defined)
            if (!j->Is_Template_Object)
                Generate_Abbrev(Abbrev_Type(j));
    }
    EOM;
    Debug_Abbrev.push_back(EOM);
}

void DebugGenerator::Construct_Debug_Info()
{
    //THE INFORMATION THAT IS DESCRIBED BELOW IS FROM http://www.dwarfstd.org/doc/DWARF4.pdf

    //                                                                                    .debug_info,"",@progbits
    IR* Section = new IR(new Token(TOKEN::OPERATOR, "section"), { new Token(TOKEN::LABEL, ".debug_info") }, nullptr);
    Debug_Info.push_back(Section);    
    //This label indicates that the next variable defined, inlists the size of the debug_info section
    Debug_Info.push_back(new IR(new Token(TOKEN::LABEL, "Debug_Info_Start"), {}, nullptr));
    //This is the variable which has the next section size init.
    IR* Section_Size = new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::LABEL, "Debug_Info_End-Debug_Info", 4) }, nullptr);
    Debug_Info.push_back(Section_Size);
    //This label indicates that the next variable defined, inlists the size of the debug_info section
    IR* Debug_Info_Start = new IR(new Token(TOKEN::LABEL, "Debug_Info"), {}, nullptr);
    Debug_Info.push_back(Debug_Info_Start);
    //DWARF version number
    IR* DWARF_Version_Number = new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, "4", 2) }, nullptr);
    Debug_Info.push_back(DWARF_Version_Number);
    //Offset Into Abbrev. Section
    IR* Offset_Into_Abbrev_Section = new IR(new Token(TOKEN::SET_DATA, "secrel32"), { new Token(TOKEN::LABEL, "debug_abbrev", 4) }, nullptr);
    Debug_Info.push_back(Offset_Into_Abbrev_Section);
    //Bits size 8 == 64
    IR* Address_Size = new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, "8", 1) }, nullptr);
    Debug_Info.push_back(Address_Size);
    //represents a complete object file.
    IR* DW_TAG_Compile_Unit = new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, "1", 1) }, nullptr);
    Debug_Info.push_back(DW_TAG_Compile_Unit);
    //Containing information about the compiler that produced the compilation unit.
    IR* COMPILER = new IR(new Token(TOKEN::SET_DATA, "secrel32"), { new Token(TOKEN::NUM, ".COMPILER_NAME", 4) }, nullptr);
    Debug_Info.push_back(COMPILER);
    //Indicating the source language used to define the type. 
    IR* DW_AT_Language = new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, "0x29A", 2) }, nullptr);
    Debug_Info.push_back(DW_AT_Language);
    //Debugging information entry representing a program entity that has been given a name.
    IR* DW_AT_Name = new IR(new Token(TOKEN::SET_DATA, "secrel32"), { new Token(TOKEN::LABEL, ".FILE_NAME", 4) }, nullptr);
    Debug_Info.push_back(DW_AT_Name);
    //Attribute whose value is a section offset to the line number information for this compilation unit.
    IR* DW_AT_Stmt_List = new IR(new Token(TOKEN::SET_DATA, "secrel32"), { new Token(TOKEN::LABEL, ".LINE_TABLE", 4) }, nullptr);
    Debug_Info.push_back(DW_AT_Stmt_List);
    //Containing the current working directory of the compilation command that produced this compilation unit in whatever form makes sense for the host system.
    IR* DW_AT_Comp_Dir = new IR(new Token(TOKEN::SET_DATA, "secrel32"), { new Token(TOKEN::LABEL, ".DIRECTORY", 4) }, nullptr);
    Debug_Info.push_back(DW_AT_Comp_Dir);
    //Start of the all asm code
    IR* DW_AT_Low_Pc = new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::LABEL, "Code_Start", 8) }, nullptr);
    Debug_Info.push_back(DW_AT_Low_Pc);
    //End of the all asm code
    IR* DW_AT_High_Pc = new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::LABEL, "Code_End", 8) }, nullptr);
    Debug_Info.push_back(DW_AT_High_Pc);

    int j = 0;
    for (auto i : Global_Scope->Defined) {
        if (i->Is_Template_Object)
            continue;

        bool Has_Template_Parameter = false;

        if (i->Has({ FUNCTION_NODE, PROTOTYPE, IMPORT, EXPORT }))
            for (auto P : i->Parameters)
                if (P->Inherits_Template_Type())
                    Has_Template_Parameter = true;

        if (Has_Template_Parameter)
            continue;

        Info_Generator(i);
    }        

    //Generate abref info for the void consept.
    Node* Void = new Node(CLASS_NODE, Global_Scope->Location);
    Void->Name = "func";
    Void->Scope = Global_Scope;

    Info_Generator(Void);
    
    Debug_Info.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(0), 1) }, nullptr));

    //This label indicates the section start point.
    IR* Ldebug_Info_Start0 = new IR(new Token(TOKEN::LABEL, "Debug_Info_End"), {}, nullptr);
    Debug_Info.push_back(Ldebug_Info_Start0);

    /*
        .byte   2                               # Abbrev [2] 0x2a:0x28 DW_TAG_subprogram
        .quad   .Lfunc_begin0                   # DW_AT_low_pc
        .long   .Lfunc_end0-.Lfunc_begin0       # DW_AT_high_pc
        .byte   1                               # DW_AT_frame_base
        .byte   86
        .long   .Linfo_string3                  # DW_AT_name
        .byte   1                               # DW_AT_decl_file
        .byte   1                               # DW_AT_decl_line
        .long   82                              # DW_AT_type
                                        # DW_AT_external
        .byte   3                               # Abbrev [3] 0x43:0xe DW_TAG_variable
        .byte   2                               # DW_AT_location
        .byte   145
        .byte   120
        .long   .Linfo_string5                  # DW_AT_name
        .byte   1                               # DW_AT_decl_file
        .byte   2                               # DW_AT_decl_line
        .long   82                              # DW_AT_type
        .byte   0                               # End Of Children Mark
        .byte   4                               # Abbrev [4] 0x52:0x7 DW_TAG_base_type
        .long   .Linfo_string4                  # DW_AT_name
        .byte   5                               # DW_AT_encoding
        .byte   4                               # DW_AT_byte_size
        .byte   0                               # End Of Children Mark
.Ldebug_info_end0:
    */
}

void DebugGenerator::Construct_Debug_String()
{
    //the section for names
    IR* Section = new IR(new Token(TOKEN::OPERATOR, "section"), { new Token(TOKEN::LABEL, ".debug_str") }, nullptr);
    Debug_Str.push_back(Section);
    //Compiler name label indicator
    IR* Compiler_Name_Indicator = new IR(new Token(TOKEN::LABEL, ".COMPILER_NAME"), {}, nullptr);
    Debug_Str.push_back(Compiler_Name_Indicator);
    //Compiler name
    IR* Compiler_Name = new IR(new Token(TOKEN::OPERATOR, "ascii"), { new Token(TOKEN::STRING, "Evie engine 3.0.0 https://github.com/Gabidal/Evie") }, nullptr);
    Debug_Str.push_back(Compiler_Name);
    //File name label indicator
    IR* File_Name_Indicator = new IR(new Token(TOKEN::LABEL, ".FILE_NAME"), {}, nullptr);
    Debug_Str.push_back(File_Name_Indicator);
    //File name
    IR* File_Name = new IR(new Token(TOKEN::OPERATOR, "ascii"), { new Token(TOKEN::STRING, DOCKER::Included_Files[0]) }, nullptr);
    Debug_Str.push_back(File_Name);
    //Directory label indicator
    IR* Directory_Indicator = new IR(new Token(TOKEN::LABEL, ".DIRECTORY"), {}, nullptr);
    Debug_Str.push_back(Directory_Indicator);
    //Directory
    string Dir = "";
    DOCKER::Update_Working_Dir(DOCKER::Included_Files[0], Dir);
    IR* Directory = new IR(new Token(TOKEN::OPERATOR, "ascii"), { new Token(TOKEN::STRING, Dir) }, nullptr);
    Debug_Str.push_back(Directory);
    /*
    vector<string> Declarated_Local_Variable_Names;
    vector<string> Declarated_Local_Variable_Mangles;

    for (auto i : Global_Scope->Defined) {
        if (i->is(FUNCTION_NODE) || i->is(IMPORT) || i->is(PROTOTYPE))
            if (i->Calling_Count < 1 && (i->is("export") == -1))
                continue;
            if (i->is(FUNCTION_NODE) || i->is(CLASS_NODE)) {
                Abbrev_Type Info(i);
                bool Skip_Function_Declaration = false;
                for (auto defined : Declarated_Local_Variable_Names)
                    if (defined == i->Name) {
                        Skip_Function_Declaration = true;
                        break;
                    }
                Declarated_Local_Variable_Names.push_back(i->Name);
                if (!Skip_Function_Declaration) {
                    if (Info.MANGLED_NAME) {
                        for (auto defined : Declarated_Local_Variable_Mangles)
                            if (defined == MANGLER::Mangle(i) + "_MANGLE")
                                goto Skip_Mangle_1;
                        Declarated_Local_Variable_Mangles.push_back(MANGLER::Mangle(i) + "_MANGLE");
                        //Funtion name label indicator
                        Debug_Str.push_back(new IR(new Token(TOKEN::LABEL, MANGLER::Mangle(i) + "_MANGLE"), {}, nullptr));
                        //Function name
                        Debug_Str.push_back(new IR(new Token(TOKEN::OPERATOR, "ascii"), { new Token(TOKEN::STRING, MANGLER::Mangle(i)) }, nullptr));
                    Skip_Mangle_1:;
                    }
                    if (Info.NAME) {
                        //Funtion name label indicator
                        Debug_Str.push_back(new IR(new Token(TOKEN::LABEL, i->Name + "_NAME"), {}, nullptr));
                        //Function name
                        Debug_Str.push_back(new IR(new Token(TOKEN::OPERATOR, "ascii"), { new Token(TOKEN::STRING, i->Name) }, nullptr));
                    }
                }
                for (auto v : i->Defined) {
                    if (v->is("const") != -1)
                        continue;
                    for (auto defined : Declarated_Local_Variable_Names)
                        if (defined == v->Name)
                            goto Skip_Variable;

                    Declarated_Local_Variable_Names.push_back(v->Name);
                    Info = Abbrev_Type(v);
                    if (Info.MANGLED_NAME) {
                        for (auto defined : Declarated_Local_Variable_Mangles)
                            if (defined == MANGLER::Mangle(v) + "_MANGLE")
                                goto Skip_Mangle;
                        Declarated_Local_Variable_Mangles.push_back(MANGLER::Mangle(v) + "_MANGLE");
                        //Funtion name label indicator
                        Debug_Str.push_back(new IR(new Token(TOKEN::LABEL, MANGLER::Mangle(v) + "_MANGLE"), {}, nullptr));
                        //Function name
                        Debug_Str.push_back(new IR(new Token(TOKEN::OPERATOR, "ascii"), { new Token(TOKEN::STRING, MANGLER::Mangle(v)) }, nullptr));
                    Skip_Mangle:;
                    }
                    if (Info.NAME) {
                        //Funtion name label indicator
                        Debug_Str.push_back(new IR(new Token(TOKEN::LABEL, v->Name + "_NAME"), {}, nullptr));
                        //Function name
                        Debug_Str.push_back(new IR(new Token(TOKEN::OPERATOR, "ascii"), { new Token(TOKEN::STRING, v->Name) }, nullptr));
                    }

                Skip_Variable:;
                }
            }
    }
    */
}

void DebugGenerator::Construct_Line_Table()
{
    IR* Section = new IR(new Token(TOKEN::OPERATOR, "section"), { new Token(TOKEN::LABEL, ".LINE_TABLE") }, nullptr);
    Line_Table.push_back(Section);
    //tmp
    IR* debug_abbrev = new IR(new Token(TOKEN::LABEL, ".LINE_TABLE"), {}, nullptr);
    Line_Table.push_back(debug_abbrev);

}

void DebugGenerator::Define_File_Index()
{
    //.file [Num] [Path/File_Name]
    long long Current_File_Index = 1;
    for (auto i : DOCKER::Included_Files) {
        Files.push_back({ i, Current_File_Index });
        IR* File = new IR(new Token(TOKEN::OPERATOR, "file"), { new Token(TOKEN::LABEL, to_string(Current_File_Index++) + " \"" + i + "\"", 1) }, nullptr);
        File_Index.push_back(File);
    }
}

int ID = 2;
void DebugGenerator::Generate_Abbrev(Abbrev_Type abbrev)
{
    if (abbrev.TAG == -1)
        return;     //unsupported type

    //first find if this abbrev does exist
    for (auto i : Abbrovation_IDs)
        if (abbrev == i.first)
            return;

    if (abbrev.ID)
        //Abbreviation Code describes the current section as an index
        Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(ID), 1) }, nullptr));
    if (abbrev.TAG != - 1)
        Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(abbrev.TAG), 1) }, nullptr));
    Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(abbrev.HAS_CHILDREN), 1) }, nullptr));
    if (abbrev.CALLING_CONVENTION) {
        Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_AT::Calling_convention), 1) }, nullptr));
        Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_FORM::Data1), 1) }, nullptr));
    }
    if (abbrev.MEMORY_LOCATION) {
        Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_AT::Location), 1) }, nullptr));
        Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_FORM::Exprloc), 1) }, nullptr));
    }
    if (abbrev.START) {
        Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_AT::Low_pc), 1) }, nullptr));
        Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_FORM::Addr), 1) }, nullptr));
    }
    if (abbrev.END) {
        Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_AT::High_pc), 1) }, nullptr));
        Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_FORM::Data4), 1) }, nullptr));
    }
    if (abbrev.STACK_FRAME_REPRESENTIVE_REGISTER) {
        Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_AT::Frame_base), 1) }, nullptr));
        Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_FORM::Exprloc), 1) }, nullptr));
    }
    if (abbrev.STACK_FRAME_LOCATION) {
        Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_AT::Data_member_location), 1) }, nullptr));
        Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_FORM::Data2), 1) }, nullptr));
    }
    if (abbrev.MANGLED_NAME) {
        Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_AT::Linkage_name), 1) }, nullptr));
        Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_FORM::String), 1) }, nullptr));
    }
    if (abbrev.NAME) {
        Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_AT::Name), 1) }, nullptr));
        Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_FORM::String), 1) }, nullptr));
    }
    if (abbrev.ENCODING) {
        Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_AT::Encoding), 1) }, nullptr));
        Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_FORM::Data1), 1) }, nullptr));
    }
    if (abbrev.BYTE_SIZE) {
        Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_AT::Byte_size), 1) }, nullptr));
        Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_FORM::Data8), 1) }, nullptr));
    }
    if (abbrev.SOURCE_FILE) {
        Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_AT::Decl_file), 1) }, nullptr));
        Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_FORM::Data1), 1) }, nullptr));
    }
    if (abbrev.SOURCE_LINE) {
        Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_AT::Decl_line), 1) }, nullptr));
        Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_FORM::Data1), 1) }, nullptr));
    }
    if (abbrev.TYPE) {
        Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_AT::Type), 1) }, nullptr));
        Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_FORM::Ref4), 1) }, nullptr));
    }
    if (abbrev.EXTERNAL) {
        Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_AT::External), 1) }, nullptr));
        Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(DW_FORM::Flag_present), 1) }, nullptr));
    }
    //EOM(0)
    Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(0), 1) }, nullptr));
    Debug_Abbrev.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(0), 1) }, nullptr));

    Abbrovation_IDs.push_back({abbrev, ID++});
}

void DebugGenerator::Insert_Start_End_Labels(vector<IR*>& input)
{
    IR* Debug_Info_Start = new IR(new Token(TOKEN::LABEL, "Code_Start"), {}, nullptr);
    input.insert(input.begin(), Debug_Info_Start);

    int Data_Section_Start;
    for (Data_Section_Start = 0; Data_Section_Start < input.size(); Data_Section_Start++)
        if (input[Data_Section_Start]->Arguments.size() > 0)
            if (input[Data_Section_Start]->OPCODE->Get_Name() == "section")
                if (input[Data_Section_Start]->Arguments[0]->Get_Name() == ".data")
                    break;
    IR* Debug_Info_End = new IR(new Token(TOKEN::LABEL, "Code_End"), {}, nullptr);
    input.insert(input.begin() + Data_Section_Start, Debug_Info_End);

    //IR* Section = new IR(new Token(TOKEN::OPERATOR, "section"), { new Token(TOKEN::LABEL, ".text") }, nullptr);
    //input.insert(input.begin(), Section);


    for (int i = 0; i < input.size(); i++) {
        if (input[i]->is(TOKEN::START_OF_FUNCTION)) {
            input.insert(input.begin() + i, new IR(new Token(TOKEN::LABEL, input[i]->OPCODE->Get_Name() + "_START"), {}, nullptr));
            i++;
        }
        else if (input[i]->is(TOKEN::END_OF_FUNCTION)) {
            input.insert(input.begin() + i, new IR(new Token(TOKEN::LABEL, input[i]->OPCODE->Get_Name() + "_END"), {}, nullptr));
            i++;
        }
    }
}

void DebugGenerator::Insert_Line_Change_Information(vector<IR*>& input)
{
    int Current_Line = 0;
    for (int i = 0; i < input.size(); i++)
        if (input[i]->Location == nullptr)
            continue;
        else if (input[i]->Location->GetFriendlyLine() != Current_Line) {
            Current_Line = input[i]->Location->GetFriendlyLine();

            string Locatoin = to_string(Get_Index_From_File(input[i]->Location->GetFilePath())) + " " + to_string(Current_Line) + " " + to_string(input[i]->Location->GetFriendlyCharacter());
            input.insert(input.begin() + i, new IR(new Token(TOKEN::SET_DATA, "location"), { new Token(TOKEN::LABEL, Locatoin) }, input[i]->Location));
        }

}

void DebugGenerator::Insert_Stack_Info(vector<IR*> &Input)
{
    for (int i = 0; i < Input.size(); i++) {
        if (Input[i]->is(TOKEN::START_OF_FUNCTION)) {
            //cfi_startproc
            Input.insert(Input.begin() + i + 1, new IR(new Token(TOKEN::SET_DATA, "cfi_start"), {}, nullptr));
            //.cfi_def_cfa_offset 16
            Input.insert(Input.begin() + i + 2, new IR(new Token(TOKEN::SET_DATA, "cfi_offset"), {new Token(TOKEN::NUM, "16")}, nullptr));

        }
        else if (Input[i]->is(TOKEN::END_OF_FUNCTION)) {
            //cfi_endproc
            Input.insert(Input.begin() + i + 1, new IR(new Token(TOKEN::SET_DATA, "cfi_end"), {}, nullptr));
        }
    }
}

void DebugGenerator::Info_Generator(Node* n)
{
    Abbrev_Type Info(n);
    string Mangled_Name;
    if (Info.TAG == -1)
        return;
    if (n->is(FUNCTION_NODE))
        if (n->Calling_Count == 0 && n->is("export") == -1)
            return;

    bool Skip_Scope_Generation = false;
    for (auto i : Genrated_Info)
        if ((i == n->Name /*|| i == MANGLER::Mangle(n, "")*/) && !n->is(OBJECT_DEFINTION_NODE)) {
            Skip_Scope_Generation = true;
            goto Go_Straight_To_Childs;
        }

    if (!Skip_Scope_Generation) {
        Genrated_Info.push_back(n->Name);
        //Genrated_Info.push_back(MANGLER::Mangle(n, ""));
    }

    Mangled_Name = n->Name;
    if (n->is(CLASS_NODE) && !MANGLER::Is_Base_Type(n))
        Mangled_Name = MANGLER::Mangle(n, "");

    if (n->is(CLASS_NODE))
        Debug_Info.push_back(new IR(new Token(TOKEN::LABEL, "_" + Mangled_Name + "_START"), {}, nullptr));

    Debug_Info.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(Get_Abbrovation_Index(n)), 1) }, nullptr));
    if (Info.CALLING_CONVENTION) {
        Debug_Info.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(1), 1) }, nullptr));
    }
    if (Info.STACK_FRAME_LOCATION) {
        Debug_Info.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(n->Memory_Offset), 2) }, nullptr));
    }
    if (Info.START)
        //The label that is in the start of the function
        Debug_Info.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::LABEL, MANGLER::Mangle(n, "") + "_START", 8)}, nullptr));
    if (Info.END)
        //The label that is in the end of the function
        Debug_Info.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::LABEL, MANGLER::Mangle(n, "") + "_END", 8) }, nullptr));
    if (Info.MEMORY_LOCATION) {
        Debug_Info.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(2), 1) }, nullptr));
        Debug_Info.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(145), 1) }, nullptr));
        Debug_Info.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(n->Memory_Offset), 1) }, nullptr));
    }
    if (Info.STACK_FRAME_REPRESENTIVE_REGISTER) {
        //Location description.
        Debug_Info.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, "1", 1) }, nullptr));
        //The stack representive register number
        Debug_Info.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(selector->STACK_REPRESENTIVE_REGISTER), 1) }, nullptr));
    }
    if (Info.MANGLED_NAME)
        //Points into a string in data section which has the function name
        Debug_Info.push_back(new IR(new Token(TOKEN::SET_DATA, "ascii"), { new Token(TOKEN::STRING, MANGLER::Mangle(n, "")) }, nullptr));
    if (Info.NAME)
        //Points into a string in data section which has the function name
        Debug_Info.push_back(new IR(new Token(TOKEN::SET_DATA, "ascii"), { new Token(TOKEN::STRING, n->Name) }, nullptr));
    if (Info.ENCODING) {
        //Some constant for encoding the inlisted type.
        int Encoding = DW_ATE_signed;
        if (n->Format == "decimal")
            Encoding = DW_ATE_float;
        else if (n->is("ptr") != -1)
            Encoding = DW_ATE_address;
        else if (n->Size == 1)
            Encoding = DW_ATE_signed_char;
        Debug_Info.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(Encoding), 1) }, nullptr));
    }
    if (Info.BYTE_SIZE) {
        Debug_Info.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(0), 8) }, nullptr));
    }
    if (Info.SOURCE_FILE)
        //The source file
        Debug_Info.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(Get_Index_From_File(n->Location->GetFilePath())), 1) }, nullptr));
    if (Info.SOURCE_LINE)
        //The source line the function starts at.
        Debug_Info.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(n->Location->GetFriendlyLine()), 1) }, nullptr));
    //Return type declaration address
    if (Info.TYPE) {
        string Inheritted = "";
        //purify the inheritted.
        for (auto i : n->Inheritted) {
            if (Lexer::GetComponent(i).is(Flags::KEYWORD_COMPONENT))
                continue;

            string Base_Type = MANGLER::Mangle(n->Find(i, n, CLASS_NODE), "");

            if (MANGLER::Is_Base_Type(n->Find(i, n, CLASS_NODE)))
                Base_Type = i;

            Inheritted = "_" + Base_Type;
            break;
        }
        if (Inheritted == "") {
            for (auto i : n->Inheritted) {
                if (i == "func") {
                    Inheritted = "_func";
                    break;
                }
            }
        }
        MANGLER::Clear_Class_Zipping_List();
        /*= n->Get_Inheritted("_", true, false, true);
        if (Inheritted == "")
            Inheritted = n->Get_Inheritted("_", true, false, false);*/
        IR* DW_AT_Type = new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::LABEL, Inheritted + "_START-Debug_Info_Start", 4) }, nullptr);
        Debug_Info.push_back(DW_AT_Type);
    }
Go_Straight_To_Childs:;
    if (!n->is(OBJECT_DEFINTION_NODE))
        for (auto v : n->Defined) {
            if (v->is("const") != -1 || v->Is_Template_Object)
                continue;
            if (v->is(FUNCTION_NODE))
                continue;
            Info_Generator(v);
        }
    if (Info.HAS_CHILDREN && !Skip_Scope_Generation)
        Debug_Info.push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::NUM, to_string(0), 1) }, nullptr));
}

int DebugGenerator::Get_Index_From_File(string s)
{
    for (auto i : Files)
        if (i.first == s)
            return i.second;
    if (s == "No File")
        return 1;
    throw::runtime_error("ERROR!");
}

int DebugGenerator::Get_Abbrovation_Index(Node* n)
{
    for (auto i : Abbrovation_IDs)
        if (Abbrev_Type(n) == i.first)
            return i.second;

    throw::runtime_error("ERROR");
}

Abbrev_Type::Abbrev_Type(Node* n)
{
    ID = true;
    NAME = true;
    TYPE = true;
    SOURCE_FILE = true;
    SOURCE_LINE = true;
    if (n->is(FUNCTION_NODE)) {
        TAG = DW_TAG::Subprogram;

        START = true;
        END = true;
        if (n->Defined.size() > 0)
            HAS_CHILDREN = true;

        //STACK_FRAME_LOCATION = true;
        STACK_FRAME_REPRESENTIVE_REGISTER = true;

        if (MANGLER::Is_Based_On_Base_Type(n)) {
            TYPE = false;
        }
    }
    else if (n->is(OBJECT_DEFINTION_NODE)) {
        TAG = DW_TAG::Variable;
        if (n->Scope->is(FUNCTION_NODE))
            MEMORY_LOCATION = true;
        else if (n->Scope->is(CLASS_NODE))
            STACK_FRAME_LOCATION = true;
    }
    else if (n->is(PARAMETER_NODE)) {
        TAG = DW_TAG::Formal_parameter;
        MEMORY_LOCATION = true;
    }
    else if (n->is(CLASS_NODE)) {
        BYTE_SIZE = true;        
        if (MANGLER::Is_Based_On_Base_Type(n)) {
            TYPE = false;
        }
        if (MANGLER::Is_Base_Type(n)) {
            TAG = DW_TAG::Base_type;
            ENCODING = true;
        }
        else {
            if (n->Defined.size() > 0)
                HAS_CHILDREN = true;
            TAG = DW_TAG::Class_type;
            CALLING_CONVENTION = true;
        }
    }
    if (n->is("export") != -1) {
        EXTERNAL = true;
        MANGLED_NAME = true;
    }
}
C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Cpp\BackEnd\IRGenerator.cpp" 
#include "../../H/BackEnd/BackEnd.h"
#include "../../H/BackEnd/IRGenerator.h"
#include "../../H/BackEnd/Selector.h"
#include "../../H/Docker/Mangler.h"
#include "../../H/UI/Safe.h"
#include "../../H/UI/Usr.h"
#include "../../H/Parser/Parser.h"
#include "../../H/Parser/PostProsessor.h"

extern Selector* selector;
extern Usr* sys;
unsigned long long Reg_Random_ID_Addon = 0;
unsigned long long Label_Differential_ID = 0;

void IRGenerator::Factory()
{
	if (Scope->Name == "GLOBAL_SCOPE") 
		Output->push_back(new IR(new Token(TOKEN::OPERATOR, "section"), { new Token(TOKEN::LABEL, ".text") }, nullptr));
	/*for (int i = 0; i < Input.size(); i++)
		Switch_To_Correct_Places(Input[i]);*/
	if (Scope->is(CLASS_NODE)) {
		for (auto i : Scope->Defined)
			Parse_Function(i);
		for (auto i : Scope->Defined)
			Parse_Member_Functions(i);
	}

	for (int i = 0; i < Input.size(); i++) {
		Parse_Dynamic_Casting(Input[i]);
		Parse_Static_Casting(Input[i]);
		Parse_If(i);
		Parse_Loops(i);
		Parse_Arrays(i);
		Parse_Member_Fetch(Input[i]);
		Parse_Calls(i);
		Parse_Parenthesis(i);
		Parse_Reference_Count_Increase(i);
		Parse_Operators(i);
		Parse_Logical_Conditions(i);
		Parse_Pointers(i);
		Parse_Conditional_Jumps(i);
		Parse_PostFixes(i);
		Parse_PreFixes(i);
		Parse_Return(i);
		Parse_Jump(i);
		Parse_Labels(i);
	}
	if (Scope->Name == "GLOBAL_SCOPE") {
		Output->push_back(new IR(new Token(TOKEN::OPERATOR, "section"), { new Token(TOKEN::LABEL, ".data") }, nullptr));
		for (auto i : Scope->Header)
			Parse_Global_Variables(i);
		for (auto i : Scope->Defined)
			Parse_Static_Variables(i);
	}
}

void IRGenerator::Parse_Function(Node* Func)
{
	if (Func->is(IMPORT)) {
		if (Func->is(IMPORT))
			Global_Scope->Header.push_back(Func);
	}
	if (!Func->is(FUNCTION_NODE))
		return;
	if (Func->Is_Template_Object)
		return;
	for (auto j : Func->Parameters)
		if (j->is("type") != -1 || j->Inherits_Template_Type())
			return;	//skip template functions.

	Node* Function_Scope = Scope;
	if (Func->Fetcher != nullptr)
		Function_Scope = Func->Fetcher;

	if ((Function_Scope->Find(Func->Name, Function_Scope, FUNCTION_NODE)->Calling_Count == 0) && Function_Scope->Find(Func->Name, Function_Scope, FUNCTION_NODE)->is("export") == -1)
		return;

	if (Func->is("export") != -1)
		Function_Scope->Header.push_back(Func);

	//label
	IR* Label = Make_Label(Func, true);
	Label->OPCODE->Set_Flags(Label->OPCODE->Get_Flags() | TOKEN::START_OF_FUNCTION);
	Output->push_back(Label);
	Reg_Random_ID_Addon = 0;

	if (sys->Info.Debug) {
		//the stack locaiton of these parameters are decided in IRPostProsessor.cpp
		int Max_Non_Decimal_Register_Count = selector->Get_Numerical_Parameter_Register_Count(Func->Parameters);
		int Max_Decimal_Register_Count = selector->Get_Floating_Parameter_Register_Count(Func->Parameters);

		for (int j = 0; j < Func->Parameters.size(); j++) {
			if (j <= Max_Decimal_Register_Count || j <= Max_Non_Decimal_Register_Count) {
				//first make a register representive out of the parameter.
				Token* Register = new Token(Func->Parameters[j], true);
				//then declare that the parameter now needs memory
				Function_Scope->Find(Func->Name, Function_Scope, Func->Type)->Parameters[j]->Requires_Address = true;
				//now the new token that is created is a memory representive of the original parameter.
				Token* Memory = new Token(TOKEN::MEMORY, { new Token(Func->Parameters[j]) }, Register->Get_Size(), Register->Get_Name());

				Output->push_back(new IR(new Token(TOKEN::OPERATOR, "="), { Memory, Register }, Func->Location));
			}
		}
	}

	//go through the childs of the function
	IRGenerator g(Func, Func->Childs, Output);


	Token* ret = new Token(TOKEN::FLOW, "return");
	ret->Set_Parent(Function_Scope->Find(Func->Name, Function_Scope, FUNCTION_NODE));
	Output->push_back(new IR(ret, {}, nullptr));

	//make the end of funciton like End Proc like label
	Output->push_back(new IR(new Token(TOKEN::END_OF_FUNCTION, MANGLER::Mangle(Func, "")), {}, nullptr));
}

void IRGenerator::Parse_Member_Functions(Node* Class)
{
	if (!Class->is(CLASS_NODE))
		return;
	if (Class->Templates.size() > 0)
		return;

	for (auto i : Class->Defined) {
		if (i->is(FUNCTION_NODE))
			if (i->Fetcher == nullptr) {	//if this function has a fetcher then it is defined in global scope.
				IRGenerator g(Class, Output);
				g.Parse_Function(i);
			}
		else if (i->is(CLASS_NODE))
			Parse_Member_Functions(i);
	}
}

void IRGenerator::Parse_Calls(int i)
{
	if (!Input[i]->is(CALL_NODE))
		return;
	if (Input[i]->Cast_Type != nullptr)
		return;
	if (Input[i]->is(PARSED_BY::IRGENERATOR))
		return;


	IRGenerator g(Scope, Output);

	//do the parameters
	//no ur wrong m8!
	//the IRPostprosessor takes care of the parameters here (:
	//nah why dont do it here? :)
	//ok. (:
	int Number_Register_Count = 0;
	int MAX_Number_Register_Count = selector->Get_Numerical_Parameter_Register_Count(Input[i]->Parameters);
	int Float_Register_Count = 0;
	int MAX_Floating_Register_Count = selector->Get_Floating_Parameter_Register_Count(Input[i]->Parameters);

	//to push everything currectly
	vector<Token*> Reversable_Pushes;

	//for selector to understand a more abstract picture of the whole parameters.
	vector<Token*> All_Parameters;
	//string All_Parameters_Names = "";

	int Parameter_Place = 0;
	for (Node* n : Input[i]->Parameters) {
		g.Generate({ n }, false);

		Token* p;
		//handle complex instructions
		if (g.Handle != nullptr)
			p = g.Handle;
		else
			p = new Token(n);	

		if (p->is(TOKEN::CONTENT))
			p = new Token(TOKEN::MEMORY, { p }, p->Get_Size(), p->Get_Name());

		int Level_Difference = Get_Amount("ptr", n) - Get_Amount("ptr", Input[i]->Function_Implementation->Parameters[Parameter_Place]);
		if (Level_Difference != 0)
			p = g.Operate_Pointter(p, Level_Difference, false, p->is(TOKEN::MEMORY));

		if (n->Format == "decimal") {
			if (Float_Register_Count < MAX_Floating_Register_Count) {
				//use a parameter register
				Token* reg = new Token(TOKEN::PARAMETER | TOKEN::REGISTER | TOKEN::DECIMAL, "REG_" + p->Get_Name() + "_Parameter" + to_string(rand()), p->Get_Size());
				reg->Parameter_Index = Parameter_Place;
				Token* opc = new Token(TOKEN::OPERATOR, "=");
				//make the parameter move
				IR* ir = new IR(opc, { reg, p }, Input[i]->Location);
				Output->push_back(ir);
				Float_Register_Count++;
				All_Parameters.push_back(reg);
			}
			else {
				//use stack
				//check is n is a complex
				if (p->is(TOKEN::REGISTER) || p->is(TOKEN::NUM)) {
					//is complex
					Reversable_Pushes.push_back(p);
					All_Parameters.push_back(p);
				}
				else if (p->is(TOKEN::MEMORY)) {
					//is non-complex variable
					//use a any tmp register
					Token* reg = new Token(TOKEN::REGISTER | TOKEN::DECIMAL, "REG_" + p->Get_Name() + "_Parameter" + to_string(rand()), p->Get_Size());
					Token* opc = new Token(TOKEN::OPERATOR, "=");
					//make the tmp move
					IR* ir = new IR(opc, { reg, p }, Input[i]->Location);
					Output->push_back(ir);
					//now give the tmp register to reversible pushbacker
					Reversable_Pushes.push_back(reg);
					All_Parameters.push_back(reg);
				}
			}
		}
		else {
			if (Number_Register_Count < MAX_Number_Register_Count) {
				//use a parameter register
				Token* reg = new Token(TOKEN::PARAMETER | TOKEN::REGISTER, "REG_" + p->Get_Name() + "_Parameter" + to_string(rand()), p->Get_Size());
				reg->Parameter_Index = Parameter_Place;
				Token* opc = new Token(TOKEN::OPERATOR, "=");
				//make the parameter move
				IR* ir = new IR(opc, { reg, p }, Input[i]->Location);
				Output->push_back(ir);
				Number_Register_Count++;
				All_Parameters.push_back(reg);
			}
			else {
				//use stack
				//check is n is a complex
				if (p->is(TOKEN::REGISTER) || p->is(TOKEN::NUM)) {
					//is complex
					Reversable_Pushes.push_back(p);
					All_Parameters.push_back(p);
				}
				else if (p->is(TOKEN::MEMORY)) {
					//is non-complex variable
					//use a any tmp register
					Token* reg = new Token(TOKEN::REGISTER, "REG_" + p->Get_Name() + "_Parameter" + to_string(rand()), p->Get_Size());
					Token* opc = new Token(TOKEN::OPERATOR, "=");
					//make the tmp move
					IR* ir = new IR(opc, { reg, p }, Input[i]->Location);
					Output->push_back(ir);
					//now give the tmp register to reversible pushbacker
					Reversable_Pushes.push_back(reg);
					All_Parameters.push_back(reg);
				}
			}
		}
		Parameter_Place++;
		//All_Parameters_Names += All_Parameters.back()->Get_Name();
	}

	//reverse(Reversable_Pushes.begin(), Reversable_Pushes.end());

	Node* parent = Global_Scope->Get_Scope_As(FUNCTION_NODE, Input[i]);

	/*int allocation = 0;
	if (sys->Info.Debug) {
		for (auto p : Input[i]->Parameters)
			allocation += p->Size;
	}
	else
		for (auto p : Reversable_Pushes) {
			allocation += p->Get_Size();
		}
	*/

	int Stack_Offset = 0;
	for (auto p : Reversable_Pushes) {
		Output->push_back(new IR(new Token(TOKEN::OPERATOR, "="), {
			new Token(TOKEN::MEMORY, {
				new Token(TOKEN::OFFSETTER, "+", new Token(TOKEN::STACK_POINTTER | TOKEN::REGISTER, ".STACK", _SYSTEM_BIT_SIZE_), new Token(TOKEN::NUM, to_string(Stack_Offset + parent->Local_Allocation_Space)))
				}, p->Get_Size(), p->Get_Name() + "_REGISTER"),
			p
			}, Input[i]->Location));
		Stack_Offset += p->Get_Size();
	}

	if (parent->Size_of_Call_Space < Stack_Offset)
		parent->Size_of_Call_Space = Stack_Offset;

	Token* call = new Token(TOKEN::CALL, "call", All_Parameters);
	IR* ir;
	if (!Input[i]->Function_Ptr)
		ir = new IR(call, { new Token(TOKEN::LABEL, MANGLER::Mangle(Input[i]->Function_Implementation, "")) }, Input[i]->Location);
	else {
		Node* tmp = Input[i];
		tmp->Type = OBJECT_NODE;
		Token* Call_Variable = new Token(tmp);
		if (Call_Variable->is(TOKEN::CONTENT))
			Call_Variable = new Token(TOKEN::MEMORY, { Call_Variable }, Call_Variable->Get_Size(), Call_Variable->Get_Name());
		ir = new IR(call, { Call_Variable }, Input[i]->Location);
		
		//now remove one ptr from the fuz
		Input[i]->Inheritted.erase(Input[i]->Inheritted.begin() + Input[i]->is("ptr"));
	}

	Output->push_back(ir);

	//selector->DeAllocate_Stack(De_Allocate_Size, Output, Output->size());
	Input[i]->Update_Size();
	long long F = TOKEN::REGISTER | TOKEN::RETURNING;
	if (Input[i]->Format == "decimal")
		F |= TOKEN::DECIMAL;

	Token* returningReg = new Token(F, "RetREG_" + to_string(Reg_Random_ID_Addon++) /* + All_Parameters_Names*/, Input[i]->Size);

	if (Input[i]->Function_Ptr) {
		Input[i]->Inheritted.push_back("ptr");
	}

	Handle = returningReg;
	Input[i]->Parsed_By |= PARSED_BY::IRGENERATOR;
}

void IRGenerator::Parse_If(int i)
{
	if (!Input[i]->is(IF_NODE))
		return;
	if (Input[i]->is(PARSED_BY::IRGENERATOR))
		return;


	//check next condition goto it else goto check this condition then goto end
	//cmp eax, ecx		;1 != a
	//je L1
	//..
	//jmp L3
	//L1:
	//cmp eax, ebx		;1 == b
	//jne L2
	//..
	//jmp L3
	//L2:
	//..
	//L3:
	//do parameters
	Loop_Elses(Input[i]);
	Input[i]->Parsed_By |= PARSED_BY::IRGENERATOR;
}

void IRGenerator::Loop_Elses(Node* e)
{
	//the if/else label
	if (e->Predecessor == nullptr)
		e->Name += "_" + to_string(Label_Differential_ID++);
	Node* tmp = new Node(e->Name, e->Location);
	Output->push_back(Make_Label(tmp, false));

	//init else names
	Node* Else = e->Succsessor;
	while (Else) {
		Else->Name += "_" + to_string(Label_Differential_ID++);
		Else = Else->Succsessor;
	}

	//do an subfunction that can handle coditions and gets the label data for the condition data from the Parent given.
	IRGenerator p(e, e->Parameters, Output);
	//then do childs
	IRGenerator c(e, e->Childs, Output);

	if (e->Succsessor != nullptr) {
		//get the last successor name
		Node* s = e->Succsessor;
		while (true) {
			if (s->Succsessor == nullptr)
				break;	//s is now last
			s = s->Succsessor;
		}

		//the end of every conditon to true fall to
		Output->push_back(Make_Jump("jump", s->Name + "_END"));

		//skip the last end jump if the condition is not met
		Node* tmp2 = new Node(e->Name + "_END", e->Location);
		Output->push_back(Make_Label(tmp2, false));

		//now construct the successor
		Loop_Elses(e->Succsessor);
	}
	else {
		Node* tmp2 = new Node(e->Name + "_END", e->Location);
		Output->push_back(Make_Label(tmp2, false));
	}

}

void IRGenerator::Parse_Conditional_Jumps(int i)
{
	//NOTICE: this must happen after all operator is created as IR!!!
	if (!Input[i]->is(CONDITION_OPERATOR_NODE))
		return;
	if (!Scope->is(IF_NODE) && !Scope->is(ELSE_IF_NODE) && !Scope->is(WHILE_NODE))
		// a = b * c < d
		//...
		return;
	/*
	int Level_Difference = (int)labs(Get_Amount("ptr", Input[i]->Left) - Get_Amount("ptr", Input[i]->Right));
	if (Level_Difference != 0)
		return;

	// if (a == 1)
	//give the right side as left side to IRGenerator
	IRGenerator g(Parent, { Input[i]->Right }, Output);

	Token* Right = nullptr;
	Token* Left = nullptr;

	if (g.Handle != nullptr)
		Right = g.Handle;
	else {
		//move to register
		Token* R = new Token(Input[i]->Right->Find(Input[i]->Right, Input[i]->Right->Parent));
		if (R->is(TOKEN::CONTENT))
			R = new Token(TOKEN::MEMORY, { R }, _SYSTEM_BIT_SIZE_);

		Token* Reg = new Token(TOKEN::REGISTER, "REG_" + R->Get_Name(), R->Get_Size());

		Token* opc = new Token(TOKEN::OPERATOR, "move");

		IR* ir = new IR(opc, { Reg, R });
		Output->push_back(ir);

		Right = Reg;
	}

	g.Generate({ Input[i]->Left});

	if (g.Handle != nullptr)
		Left = g.Handle;
	else {		
		//move to register
		Token* L = new Token(Input[i]->Left->Find(Input[i]->Left, Input[i]->Left->Parent));
		if (L->is(TOKEN::CONTENT))
			L = new Token(TOKEN::MEMORY, { L }, _SYSTEM_BIT_SIZE_);

		Token* Reg = new Token(TOKEN::REGISTER, "REG_" + L->Get_Name(), L->Get_Size());

		Token* opc = new Token(TOKEN::OPERATOR, "move");

		IR* ir = new IR(opc, { Reg, L });
		Output->push_back(ir);

		Left = Reg;
	}

	Token* cmp = new Token(TOKEN::OPERATOR, "compare");

	IR* ir = new IR(cmp, { Left, Right });
	Output->push_back(ir);
	*/
	string Next_Label = Scope->Name + "_END";
	if (Scope->Succsessor != nullptr)
		Next_Label = Scope->Succsessor->Name;

	//jmp if not correct
	string Condition = Get_Inverted_Condition(Input[i]->Name, Input[i]->Location);
	Node* Logical_Condition_Node = Input[i]->Get_Closest_Context(LOGICAL_OPERATOR_NODE);
	
	if (Logical_Condition_Node && Logical_Condition_Node->Name == "||")
		Condition = Input[i]->Name;

	Output->push_back(Make_Jump(Condition, Next_Label));

	Input[i]->Parsed_By |= PARSED_BY::IRGENERATOR;
}

void IRGenerator::Parse_Logical_Conditions(int i)
{
	if (!Input[i]->is(LOGICAL_OPERATOR_NODE))
		return;

	// a == 1 && b < 2
	// -->
	// cmp a, 1
	// jne end_of_if_children
	// cmp b, 2
	// jge end_of_if_children
	// condition_children:
	// 	   ..
	// end_of_if_children:

	// a == 1 || b < 2
	// -->
	// cmp a, 1
	// je condition_children
	// cmp b, 2
	// jl condition_children
	// jmp end_of_if_children
	// condition_children:
	// 	   ..
	// end_of_if_children:

	IRGenerator g(Scope, { Input[i]->Left, Input[i]->Right }, Output);

	string Next_Label = Scope->Name + "_END";
	if (Scope->Succsessor)
		Next_Label = Scope->Succsessor->Name;

	if (Input[i]->Name == "||") {
		Output->push_back(Make_Jump("jump", Next_Label));
	}
}

//Class move to other class
void IRGenerator::Parse_Cloning(int i)
{
	if (!Input[i]->is(ASSIGN_OPERATOR_NODE))
		return;

	//object non-ptr x = object y
	//object non-ptr x = object ptr y

	Token* Right;
	IRGenerator g(Scope, { Input[i]->Right }, Output);
	if (g.Handle != nullptr)
		Right = g.Handle;
	else 
		Right = new Token(Input[i]->Right);

	//check for pointters
	if (Input[i]->Right->is("ptr") != -1) {								// -1 keep one pointter that there is
		Right = Operate_Pointter(Right, Get_Amount("ptr", Input[i]->Right) -1, true, Right->is(TOKEN::MEMORY), Input[i]->Right->Inheritted);
	}

	Token* Left;
	g.Generate({ Input[i]->Left }, true);
	if (g.Handle != nullptr)
		Left = g.Handle;
	else
		Left = new Token(Input[i]->Left);

	if (Left->is(TOKEN::MEMORY)) {
		//unwrap the insides from the memory.
		Left = Left->Childs.back();
	}

	//get the appropriate registers.
	//			size, count
	vector<pair<int, int>> Registers;

	int Object_Size = Input[i]->Left->Get_Size();
	int Register_Size = _SYSTEM_BIT_SIZE_;
	int Count = 0;
	while (Object_Size > 0) {
		Count = Object_Size / Register_Size;
		if (Count > 0)
			Registers.push_back({Register_Size, Count});
		Object_Size -= Count * Register_Size;
		Register_Size /= 2;		//half the size.
	}

	int Current_Stack_Offset = 0;
	for (auto& j : Registers) {
		for (int c = 0; c < j.second; c++) {
			//x[Current_Offset] = y[Current_Offset]

			//load the right side.
			Token* Reg = new Token(TOKEN::REGISTER, "REG_" + Right->Get_Name() + to_string(c) + to_string(j.first), j.first);
			//convert the right side into memory.
			Token* Offset = new Token(TOKEN::OFFSETTER, "+", Right, new Token(TOKEN::NUM, to_string(Current_Stack_Offset)));
			Offset = new Token(TOKEN::MEMORY, { Offset }, Reg->Get_Size(), Right->Get_Name() + "_Mem");
			Output->push_back(new IR(new Token(TOKEN::OPERATOR, "="), { Reg, Offset }, Input[i]->Location));

			//set the Reg into the Left side.
			Token* Dest = new Token(TOKEN::OFFSETTER, "+", Left, new Token(TOKEN::NUM, to_string(Current_Stack_Offset)));
			
			Dest = new Token(TOKEN::MEMORY, { Dest }, Reg->Get_Size(), Left->Get_Name() + "_Mem");
			Output->push_back(new IR(new Token(TOKEN::OPERATOR, "="), { Dest, Reg }, Input[i]->Location));

			Current_Stack_Offset += Reg->Get_Size();
		}
	}

}

void IRGenerator::Parse_Operators(int i)
{
	if (!Input[i]->is(OPERATOR_NODE) && !Input[i]->is(BIT_OPERATOR_NODE) && !Input[i]->is(ASSIGN_OPERATOR_NODE) && !Input[i]->is(CONDITION_OPERATOR_NODE))
		return;
	
	if (Scope->Name == "GLOBAL_SCOPE")
		return;
	if (Input[i]->Name == ".")
		return;


	Update_Operator(Input[i]);
	Input[i]->Update_Format();

	if (!Input[i]->Left->Has({ ARRAY_NODE, OPERATOR_NODE, ASSIGN_OPERATOR_NODE, CONDITION_OPERATOR_NODE, BIT_OPERATOR_NODE, CONTENT_NODE, PREFIX_NODE, POSTFIX_NODE }))
		Input[i]->Left->Size = Scope->Find(Input[i]->Left, Scope)->Size;

	if (Input[i]->is(ASSIGN_OPERATOR_NODE) && Input[i]->Left->Size > _SYSTEM_BIT_SIZE_) {
		Parse_Cloning(i);
		Input[i]->Parsed_By |= PARSED_BY::IRGENERATOR;
		return;
	}
	//If this operator is handling with pointters we cant use general operator handles
	int Level_Difference = (int)labs(Get_Amount("ptr", Input[i]->Left) - Get_Amount("ptr", Input[i]->Right));
	if (Level_Difference != 0)
		return;

	Token* Left = nullptr;
	Token* Right = nullptr;

	IRGenerator g(Scope, { Input[i]->Left }, Output, Input[i]->is(ASSIGN_OPERATOR_NODE) || Is_In_Left_Side_Of_Operator);

	vector<IR*> tmp;
	IRGenerator g2(Scope, { Input[i]->Right }, &tmp);

	//if (Input[i]->Generated)
	//	return;

	long long F = 0;
	if (Input[i]->Format == "decimal")
		F |= TOKEN::DECIMAL;

	if (g.Handle != nullptr) {
		Left = g.Handle;
	}
	else {
		if (Input[i]->Name == "=" || Is_In_Left_Side_Of_Operator) {
			//dont load the value into a register
			Left = new Token(Input[i]->Left);
			if (Left->is(TOKEN::CONTENT))
				Left = new Token(TOKEN::MEMORY | F, { Left }, Input[i]->Find(Input[i]->Left, Input[i]->Left->Scope)->Get_Size(), Left->Get_Name());
		}
		else if (Is_In_Left_Side_Of_Operator || (!Input[i]->Left->is(PARAMETER_NODE) && !Input[i]->is(CONDITION_OPERATOR_NODE) || Input[i]->Left->is(NUMBER_NODE))) {
			Token* L = new Token(Input[i]->Left->Find(Input[i]->Left, Input[i]->Left->Scope));
			if (L->is(TOKEN::CONTENT))
				L = new Token(TOKEN::MEMORY | F, { L }, L->Get_Size(), L->Get_Name());

			Token* Reg = new Token(TOKEN::REGISTER | F, "REG_" + L->Get_Name() + to_string(Reg_Random_ID_Addon++), L->Get_Size());
			//create the IR
			Token* Opc = new Token(TOKEN::OPERATOR, "=");
			IR* ir = new IR(Opc, { Reg, L }, Input[i]->Location);

			Left = Reg;
			Output->push_back(ir);
		}
		else {
			Left = new Token(Input[i]->Left);
			if (Left->is(TOKEN::CONTENT))
				Left = new Token(TOKEN::MEMORY, { Left }, Left->Get_Size(), Left->Get_Name());
		}
	}

	if (g2.Handle != nullptr && g.Handle != nullptr) {
		if (g.Handle->Has(TOKEN::RETURNING))
			if (Input[i]->Right->Has(CALL_NODE).size() > 0) {
				//save left into other reg
				string Type = "=";
				if (Left->is(TOKEN::MEMORY))
					Type = "evaluate";
				Token* r = new Token(TOKEN::REGISTER | F, Left->Get_Name() + "Save from the right side callations" + to_string(Reg_Random_ID_Addon++), Left->Get_Size());
				Output->push_back(new IR(new Token(TOKEN::OPERATOR, Type), { r, new Token(*Left) }, Input[i]->Location));
				//wtf is this register to memory operator here m8?
				//r = new Token(TOKEN::MEMORY | F, { r }, Left->Get_Size(), Left->Get_Name());
				Left = r;
			}
	}

	/*bool Is_Parameter_Register = false;
	if (Input[i]->Right->is(PARAMETER_NODE)) {
		//check if the parameter is held in a register or not
		if (Token(Input[i]->Right).is(TOKEN::REGISTER))
			Is_Parameter_Register = true;
	}*/

	if (g2.Handle != nullptr) {
		Right = g2.Handle;
		Output->insert(Output->end(), tmp.begin(), tmp.end());
	}
	else if (!Input[i]->Right->is(NUMBER_NODE) && !Token(Input[i]->Right).is(TOKEN::REGISTER) && !Left->is(TOKEN::REGISTER)){//!Is_Parameter_Register) {
		Token* R = new Token(Input[i]->Right->Find(Input[i]->Right, Input[i]->Right->Scope));

		if (R->is(TOKEN::CONTENT))
			R = new Token(TOKEN::MEMORY | F, { R }, R->Get_Size(), R->Get_Name());

		Token* Reg = new Token(TOKEN::REGISTER | F, "REG_" + R->Get_Name() + to_string(Reg_Random_ID_Addon++), R->Get_Size());
		//create the IR
		Token* Opc = new Token(TOKEN::OPERATOR, "=");
		IR* ir = new IR(Opc, { Reg, R }, Input[i]->Location);

		Right = Reg;
		Output->push_back(ir);
	}
	else {
		Right = new Token(Input[i]->Right);
		if (Right->is(TOKEN::NUM))
			Right->Set_Size(Left->Get_Size());
		if (Right->is(TOKEN::CONTENT))
			Right = new Token(TOKEN::MEMORY | F, { Right }, Left->Get_Size() ,Right->Get_Name());
		//Right = new Token(TOKEN::NUM, Input[i]->Right->Name, 4);
	}
	
	/*if (Left->is({ TOKEN::CONTENT, TOKEN::GLOBAL_VARIABLE }) && Right->is({ TOKEN::CONTENT, TOKEN::GLOBAL_VARIABLE })) {
		//Global variable + Global variable does this.
		//Member fetcher returns into Handler: Content and global scope flagged tokens
		if (Input[i]->Name == "=") {
			//move right into register then set Left's value into the register value that right just putted.
			Token* Reg = new Token(TOKEN::REGISTER, Right->Get_Name(), Right->Get_Size());
		}
	}*/

	string Operator = Input[i]->Name;
	//this translates the condition operator into a compare operation then the parse_jumps,
	//will use the condition name to do the correct jump.
	if (Input[i]->is(CONDITION_OPERATOR_NODE))
		Operator = "compare";

	Token* Opcode = new Token(TOKEN::OPERATOR, Operator);

	IR* ir = new IR(Opcode, {Left, Right}, Input[i]->Location);

	Handle = Left;
	Output->push_back(ir);

	Input[i]->Parsed_By |= PARSED_BY::IRGENERATOR;
}

void IRGenerator::Parse_Pointers(int i)
{
	//int a = 0
	//int ptr b = a + f - e / g get the address of memory
	//int ptr c = b pass memory address of a to c
	//int d = c		load value of a into c
	if (Input[i]->is(PARSED_BY::IRGENERATOR))
		return;
	if (!Input[i]->is(OPERATOR_NODE) && !Input[i]->is(CONDITION_OPERATOR_NODE) && !Input[i]->is(BIT_OPERATOR_NODE) && !Input[i]->is(ASSIGN_OPERATOR_NODE))
		return;
	if (Scope->Name == "GLOBAL_SCOPE")
		return;
	if (Input[i]->Name == ".")
		return;


	Update_Operator(Input[i]);
	if (!Input[i]->Left->Has({ ARRAY_NODE, OPERATOR_NODE, ASSIGN_OPERATOR_NODE, CONDITION_OPERATOR_NODE, BIT_OPERATOR_NODE, CONTENT_NODE, PREFIX_NODE, POSTFIX_NODE }))
		Input[i]->Left->Size = Scope->Find(Input[i]->Left, Scope)->Size;

	if (Input[i]->is(ASSIGN_OPERATOR_NODE) && Input[i]->Left->Get_Size() > _SYSTEM_BIT_SIZE_) {
		//this has been already made in cloning objects
		return;
	}

	int Level_Difference = (int)labs(Get_Amount("ptr", Input[i]->Left) - Get_Amount("ptr", Input[i]->Right));
	if (Level_Difference == 0)
		return;

	Token* Right = nullptr;
	Token* Left = nullptr;

	//if (Input[i]->Generated)
	//	return;
	
	//handle complex Right
	IRGenerator g(Scope, { Input[i]->Right }, Output);
	if (g.Handle != nullptr)
		Right = g.Handle;
	else
		Right = new Token(Input[i]->Right);

	//handle complex Left
	g.Generate({ Input[i]->Left }, Input[i]->is(ASSIGN_OPERATOR_NODE));
	if (g.Handle != nullptr)
		Left = g.Handle;
	else
		Left = new Token(Input[i]->Left);

	Update_Operator(Input[i]);

	int Left_Level = Get_Amount("ptr", Input[i]->Left);
	int Right_Level = Get_Amount("ptr", Input[i]->Right);

	if (Left_Level == Right_Level) {
		//this means some part was apointer but also a array so it is no more because its unwrapped already.
		Parse_Operators(i);
		return;
	}
	if (Left_Level > Right_Level) {
		//here left has more ptr init check this is assignment
		if (Input[i]->is(ASSIGN_OPERATOR_NODE) && !Right->is(TOKEN::NUM) && !Input[i]->Right->is(OPERATOR_NODE)) {
			//save the address of Right into Left
			Token* reg = new Token(TOKEN::REGISTER, Right->Get_Name() + "_REG" + to_string(Reg_Random_ID_Addon++), _SYSTEM_BIT_SIZE_);

			Token* Right_Mem = new Token(TOKEN::MEMORY, { Right }, _SYSTEM_BIT_SIZE_, Right->Get_Name());

			Output->push_back(new IR(new Token(TOKEN::OPERATOR, "evaluate"), { new Token(*reg), Right_Mem }, Input[i]->Location));
			Right = reg;
		}
		else {
			int Keep_Last_Address = 0;
			if (Input[i]->is(ASSIGN_OPERATOR_NODE))
				Keep_Last_Address = 1;
			Left = Operate_Pointter(Left, Level_Difference - Keep_Last_Address, false, Left->is(TOKEN::MEMORY), Input[i]->Left->Inheritted);
			if (Input[i]->is(ASSIGN_OPERATOR_NODE))
				Left = new Token(TOKEN::MEMORY, { Left }, _SYSTEM_BIT_SIZE_);
		}

		if (Right->is(TOKEN::CONTENT)) {
			//handle the other side into a usable register
			Right = new Token(TOKEN::MEMORY, { Right }, Input[i]->Find(Right->Get_Name(), Right->Get_Parent())->Get_Size());
		}
	}
	else if (Left_Level < Right_Level) {
		Right = Operate_Pointter(Right, Level_Difference, false, Right->is(TOKEN::MEMORY), Input[i]->Right->Inheritted);
		if (Left->is(TOKEN::CONTENT)) {
				//handle the other side into a usable register
				Left = new Token(TOKEN::MEMORY, { Left }, Input[i]->Find(Left->Get_Name(), Left->Get_Parent())->Get_Size());
			}
	}

	string Operator = Input[i]->Name;
	//this translates the condition operator into a compare operation then the parse_jumps,
	//will use the condition name to do the correct jump.
	if (Input[i]->is(CONDITION_OPERATOR_NODE))
		Operator = "compare";

	if (Left->is(TOKEN::CONTENT))
		Left = new Token(TOKEN::MEMORY, { Left }, Left->Get_Size(), Left->Get_Name());
	Output->push_back(new IR(new Token(TOKEN::OPERATOR, Operator), { Left, Right }, Input[i]->Location));

	Input[i]->Parsed_By |= PARSED_BY::IRGENERATOR;
}

void IRGenerator::Parse_Arrays(int i)
{
	if (!Input[i]->is(ARRAY_NODE))
		return;
	if (Scope->Name == "GLOBAL_SCOPE")
		return;
	if (Input[i]->is(PARSED_BY::IRGENERATOR))
		return;


	Token* Left = nullptr;
	Token* Right = nullptr;

	//the left side contains the owner from the offsetting happends
	IRGenerator g(Scope, { Input[i]->Left }, Output);
	if (g.Handle != nullptr)
		Left = g.Handle;
	else
		Left = new Token(Input[i]->Left);

	//how parser array ast is buildt
	//x[123, 123][123, 123]
	//((x, {123, 123}), {123, 123})
	//((x, 123), 123)
	//x, 123
	if (Input[i]->Right->Childs.size() > 1) {
		//this is where the 2D array operators are constructed.
		vector<string> Type_Trace = Input[i]->Find(Input[i]->Left, Input[i]->Left->Scope)->Inheritted;
		//reverse(Type_Trace.begin(), Type_Trace.end());
		//int,[ptr, ptr]
		//x	  [123, 123]
		Token* handle = new Token(TOKEN::MEMORY, { Left}, _SYSTEM_BIT_SIZE_, Left->Get_Name());

		//the array is a ptr and it is in a memory then load the actual address the pointter points to
		if (Input[i]->Left->is("ptr") != -1)
			if (Left->is(TOKEN::CONTENT)) {
				Token* UnLoaded_Left = new Token(TOKEN::REGISTER, Left->Get_Name() + "_UnLoaded", Left->Get_Size());
				Output->push_back(new IR(new Token(TOKEN::OPERATOR, "="), { UnLoaded_Left, new Token(*handle) }, nullptr));
				Left = UnLoaded_Left;

				handle->Get_Childs()->back() = Left;
				handle->Set_Name(UnLoaded_Left->Get_Name());
			}

		Token* reg = nullptr;
		for (int o = 0; o < Input[i]->Right->Childs.size(); o++) {
			/*int Current_Size = Global_Scope->Find(Type_Trace[Type_Trace.size()-1 - o], Global_Scope)->Get_Size();
			for (int tmp = Type_Trace.size() - 1 - o; tmp >= 0; tmp--) {
				if (Type_Trace[tmp] == "ptr") {
					Current_Size = _SYSTEM_BIT_SIZE_;
					break;
				}
				else
					Current_Size += Global_Scope->Find(Type_Trace[tmp], Global_Scope)->Get_Size();
			}*/
			
			int Scale = 0;
			//calculate the current size and the next size for the scaling.
			for (int tmp = (int)Type_Trace.size() - 1 - o; tmp >= 0; tmp--) {
				if (Type_Trace[tmp] == "ptr") {
					Scale = _SYSTEM_BIT_SIZE_;
					break;
				}
				else
					Scale += Global_Scope->Find(Type_Trace[tmp], Global_Scope)->Get_Size();
			}

			int Next_Register_Size = 0;
			if (Is_In_Left_Side_Of_Operator)
				Next_Register_Size = _SYSTEM_BIT_SIZE_;
			else
				for (int tmp = (int)Type_Trace.size() - 2 - o; tmp >= 0; tmp--) {
					if (Type_Trace[tmp] == "ptr") {
						Next_Register_Size = _SYSTEM_BIT_SIZE_;
						break;
					}
					else
						Next_Register_Size += Global_Scope->Find(Type_Trace[tmp], Global_Scope)->Get_Size();
				}

			int Next_Scaler_Size = 0;
			for (int tmp = (int)Type_Trace.size() - 2 - o; tmp >= 0; tmp--) {
				if (Type_Trace[tmp] == "ptr") {
					Next_Scaler_Size = _SYSTEM_BIT_SIZE_;
					break;
				}
				else
					Next_Scaler_Size += Global_Scope->Find(Type_Trace[tmp], Global_Scope)->Get_Size();
			}

			reg = new Token(TOKEN::REGISTER, handle->Get_Name() + "_REG" + to_string(Reg_Random_ID_Addon++), Next_Register_Size);

			//parse through the Right childs for something complex.
			g.Generate({ Input[i]->Right->Childs[o] }, false);

			if (g.Handle != nullptr)
				Right = g.Handle;
			else
				Right = new Token(Input[i]->Right->Childs[o]);

			if (Input[i]->Right->Childs[o]->is("ptr") != -1)
				//								//unload all ptr layers
				Right = Operate_Pointter(Right, Get_Amount("ptr", Input[i]->Right->Childs[o]), true, Right->is(TOKEN::MEMORY));
			else if (Right->is(TOKEN::CONTENT)) {
				//load variable into a register
				Output->push_back(new IR(new Token(TOKEN::OPERATOR, "="), {
					new Token(TOKEN::REGISTER, Right->Get_Name() + "_REG" + to_string(Reg_Random_ID_Addon++), _SYSTEM_BIT_SIZE_),
					new Token(TOKEN::MEMORY, {Right}, _SYSTEM_BIT_SIZE_, Right->Get_Name())
					}, Input[i]->Location));
				Right = new Token(TOKEN::REGISTER, Right->Get_Name() + "_REG" + to_string(Reg_Random_ID_Addon++), _SYSTEM_BIT_SIZE_);
			}

			//if this is not the last register it must be _SYSTEM_BIT_SIZE:d
			if (Right->is(TOKEN::REGISTER)) {
				if ((size_t)o + 1 < Input[i]->Right->Childs.size())
					Right->Set_Size(_SYSTEM_BIT_SIZE_);
			}

			Token* Offsetter = new Token(TOKEN::OFFSETTER, "+");
			Offsetter->Left = handle->Get_Childs()->back();
			Offsetter->Right = Right;

			Token* Scaler = new Token(TOKEN::SCALER, "*");
			Scaler->Left = Offsetter;
			Scaler->Right = new Token(TOKEN::NUM, to_string(Next_Scaler_Size));

			string Load_Type = "=";
			if (Is_In_Left_Side_Of_Operator && (size_t)o+1 >= Input[i]->Right->Childs.size())
				Load_Type = "evaluate";	//this happends when it is the last load and it is left side of a assign

			Output->push_back(new IR(new Token(TOKEN::OPERATOR, Load_Type), {reg, new Token(TOKEN::MEMORY, {Scaler}, Next_Register_Size, Input[i]->Left->Name + "_" + Input[i]->Right->Name) }, Input[i]->Location));
		
			handle->Get_Childs()->back() = reg;
			handle->Set_Name(reg->Get_Name());
			handle->Set_Size(Next_Register_Size);
		}

		//calculate the resulting size
		int Reg_Size = 0;
		for (int tmp = ((int)Type_Trace.size() - (int)Input[i]->Right->Childs.size()) - 1; tmp >= 0; tmp--) {
			if (Type_Trace[tmp] == "ptr") {
				Reg_Size = _SYSTEM_BIT_SIZE_;
				break;
			}
			else
				Reg_Size += Global_Scope->Find(Type_Trace[tmp], Global_Scope)->Get_Size();
		}
		//get the remained inhertited types and set them for next to use
		vector<string> New_Inheritted;
		for (int tmp = ((int)Type_Trace.size() - (int)Input[i]->Right->Childs.size()) - 1; tmp >= 0; tmp--) {
			New_Inheritted.push_back(Type_Trace[tmp]);
		}

		Input[i]->Inheritted = New_Inheritted;

		if (Is_In_Left_Side_Of_Operator)
			Handle = new Token(TOKEN::MEMORY, { reg }, Reg_Size);
		else
			Handle = reg;
	}
	else {
		//this is where the 1D array operators are constructed.
		vector<string> Type_Trace = Input[i]->Find(Input[i]->Left, Input[i]->Left->Scope)->Inheritted;
		//reverse(Type_Trace.begin(), Type_Trace.end());
		//int,[ptr, ptr]
		//x	  [123, 123]

		Token* handle = new Token(TOKEN::MEMORY, { Left }, _SYSTEM_BIT_SIZE_, Left->Get_Name());

		//the array is a ptr and it is in a memory then load the actual address the pointter points to
		if (Input[i]->Left->is("ptr") != -1)
			if (Left->is(TOKEN::CONTENT)) {
				Token* UnLoaded_Left = new Token(TOKEN::REGISTER, Left->Get_Name() + "_UnLoaded", Left->Get_Size());
				Output->push_back(new IR(new Token(TOKEN::OPERATOR, "="), { UnLoaded_Left, new Token(*handle) }, nullptr));
				Left = UnLoaded_Left;

				handle->Get_Childs()->back() = Left;
				handle->Set_Name(UnLoaded_Left->Get_Name());
			}

		Token* reg = nullptr;
		int Scale = 0;
		//calculate the current size and the next size for the scaling.
		for (int tmp = (int)Type_Trace.size() - 1; tmp >= 0; tmp--) {
			if (Type_Trace[tmp] == "ptr") {
				Scale = _SYSTEM_BIT_SIZE_;
				break;
			}
			else
				Scale += Global_Scope->Find(Type_Trace[tmp], Global_Scope)->Get_Size();
		}

		int Next_Register_Size = 0;
		if (Is_In_Left_Side_Of_Operator)
			Next_Register_Size = _SYSTEM_BIT_SIZE_;
		else
			for (int tmp = (int)Type_Trace.size() - 2; tmp >= 0; tmp--) {
				if (Type_Trace[tmp] == "ptr") {
					Next_Register_Size = _SYSTEM_BIT_SIZE_;
					break;
				}
				else
					Next_Register_Size += Global_Scope->Find(Type_Trace[tmp], Global_Scope)->Get_Size();
			}

		int Next_Scaler_Size = 0;
		for (int tmp = (int)Type_Trace.size() - 2; tmp >= 0; tmp--) {
			if (Type_Trace[tmp] == "ptr") {
				Next_Scaler_Size = _SYSTEM_BIT_SIZE_;
				break;
			}
			else
				Next_Scaler_Size += Global_Scope->Find(Type_Trace[tmp], Global_Scope)->Get_Size();
		}

		reg = new Token(TOKEN::REGISTER, handle->Get_Name() + "_REG" + to_string(Reg_Random_ID_Addon++), Next_Register_Size);

		//parse through the Right childs for something complex.
		g.Generate({ Input[i]->Right }, false);

		if (g.Handle != nullptr)
			Right = g.Handle;
		else
			Right = new Token(Input[i]->Right);

		if (Input[i]->Right->is("ptr") != -1)
			//								//unload all ptr layers
			Right = Operate_Pointter(Right, Get_Amount("ptr", Input[i]->Right), true, Right->is(TOKEN::MEMORY));
		else if (Right->is(TOKEN::CONTENT)) {
			//load variable into a register
			Token* New_Right = new Token(TOKEN::REGISTER, Right->Get_Name() + "_REG" + to_string(Reg_Random_ID_Addon++), Right->Get_Size());
			Output->push_back(new IR(new Token(TOKEN::OPERATOR, "="), {
				new Token(*New_Right),
				new Token(TOKEN::MEMORY, {Right}, Right->Get_Size(), Right->Get_Name())
				}, Input[i]->Location));
			New_Right->Set_Size(_SYSTEM_BIT_SIZE_);
			Right = New_Right;
		}
		//scale the offsetter into a usable system bit size.
		if (Right->is(TOKEN::REGISTER))
			Right->Set_Size(_SYSTEM_BIT_SIZE_);

		Token* Offsetter = new Token(TOKEN::OFFSETTER, "+");
		Offsetter->Left = handle->Get_Childs()->back();
		Offsetter->Right = Right;

		Token* Scaler = new Token(TOKEN::SCALER, "*");
		Scaler->Left = Offsetter;
		Scaler->Right = new Token(TOKEN::NUM, to_string(Next_Scaler_Size));

		string Load_Type = "=";
		if (Is_In_Left_Side_Of_Operator)
			Load_Type = "evaluate";	//this happends when it is the last load and it is left side of a assign

		Output->push_back(new IR(new Token(TOKEN::OPERATOR, Load_Type), { reg, new Token(TOKEN::MEMORY, {Scaler}, Next_Register_Size, Left->Get_Name()) }, Input[i]->Location));

		handle->Get_Childs()->back() = reg;
		handle->Set_Name(reg->Get_Name());
		handle->Set_Size(Next_Register_Size);

		//calculate the resulting size
		int Reg_Size = 0;
		for (int tmp = (int)Type_Trace.size() - 2; tmp >= 0; tmp--) {
			if (Type_Trace[tmp] == "ptr") {
				Reg_Size = _SYSTEM_BIT_SIZE_;
				break;
			}
			else
				Reg_Size += Global_Scope->Find(Type_Trace[tmp], Global_Scope)->Get_Size();
		}
		//get the remained inhertited types and set them for next to use
		vector<string> New_Inheritted;
		for (int tmp = (int)Type_Trace.size() - 2; tmp >= 0; tmp--) {
			New_Inheritted.push_back(Type_Trace[tmp]);
		}

		Input[i]->Inheritted = New_Inheritted;

		if (Is_In_Left_Side_Of_Operator)
			Handle = new Token(TOKEN::MEMORY, { reg }, Reg_Size, reg->Get_Name());
		else
			Handle = reg;
	}

	Input[i]->Parsed_By |= PARSED_BY::IRGENERATOR;
}

void IRGenerator::Parse_PreFixes(int i)
{
	if (!Input[i]->is(PREFIX_NODE))
		return;
	if (Input[i]->is(PARSED_BY::IRGENERATOR))
		return;


	//++i
	IRGenerator g(Scope, { Input[i]->Right }, Output);

	Token* Right = nullptr;

	if (g.Handle != nullptr)
		Right = g.Handle;
	else
		Right = new Token(Input[i]->Right);

	if (Right->is(TOKEN::CONTENT))
		Right = new Token(TOKEN::MEMORY, { Right }, Input[i]->Find(Right->Get_Name(), Right->Get_Parent())->Get_Size());

	string Change_Type = "+";
	if (Input[i]->Name == "--")
		Change_Type = "-";

	Token* opc = new Token(TOKEN::OPERATOR, Change_Type);
	Token* num = new Token(TOKEN::NUM, "1", 4);

	IR* ir = new IR(opc, { Right, num }, Input[i]->Location);
	Output->push_back(ir);

	Handle = Right;
	Input[i]->Parsed_By |= PARSED_BY::IRGENERATOR;
}

void IRGenerator::Parse_PostFixes(int i)
{
	if (!Input[i]->is(POSTFIX_NODE))
		return;
	if (Input[i]->is(PARSED_BY::IRGENERATOR))
		return;

	//i++
	IRGenerator g(Scope, { Input[i]->Left }, Output, true);

	Token* Left = nullptr;

	if (g.Handle != nullptr)
		Left = g.Handle;
	else
		Left = new Token(Input[i]->Left);

	if (Left->is(TOKEN::CONTENT))
		Left = new Token(TOKEN::MEMORY, { Left }, Input[i]->Find(Left->Get_Name(), Left->Get_Parent())->Get_Size());

	//i++
	//make a copy
	if (Input[i]->Context != nullptr) {
		Token* CR = new Token(TOKEN::REGISTER, "CLONEREG_" + Left->Get_Name(), Left->Get_Size());
		Token* copc = new Token(TOKEN::OPERATOR, "=");

		IR* cir = new IR(copc, { CR, Left }, Input[i]->Location);
		Output->push_back(cir);
		Handle = CR;
	}

	//add to the original variable
	Token* num = new Token(TOKEN::NUM, "1", Left->Get_Size());

	string Change_Type = "+";
	if (Input[i]->Name == "--")
		Change_Type = "-";

	Token* add = new Token(TOKEN::OPERATOR, Change_Type);

	IR* ir = new IR(add, { Left, num }, Input[i]->Location);
	Output->push_back(ir);
	if (Input[i]->Context == nullptr)
		Handle = Left;
	Input[i]->Parsed_By |= PARSED_BY::IRGENERATOR;
}

void IRGenerator::Parse_Reference_Count_Increase(int i)
{
	if (Input[i]->is(PARSED_BY::REFERENCE_COUNT_INCREASE))
		return;

	if (!Input[i]->is(ASSIGN_OPERATOR_NODE) || Input[i]->Right->Has({OPERATOR_NODE, CONDITION_OPERATOR_NODE, BIT_OPERATOR_NODE}))
		return;
	
	if (MANGLER::Is_Based_On_Base_Type(Input[i]))
		return;

	int Combined_Ptr_Count = Input[i]->Left->Get_All("ptr") + Input[i]->Right->Get_All("ptr");
	if (Combined_Ptr_Count < 1)
		return;

	int Ptr_Difference = Input[i]->Left->Get_All("ptr") - Input[i]->Right->Get_All("ptr");
	if (Ptr_Difference < 0)
		return;

	//make a temporary local variable that is to hold the value of the right side, if the right side if to be a function call that returns a class pointter.
	// [inheritted types] tmp01 = [operator right side]
	// tmp01.Reference_Count++
	// [operator left side] = tmp01

	PostProsessor P(Scope);

	Node* tmp = new Node(OBJECT_DEFINTION_NODE, Input[i]->Location);
	tmp->Name = Input[i]->Right->Name + "_TMP_" + to_string((long long)tmp);
	tmp->Inheritted = Input[i]->Inheritted;
	tmp->Scope = Scope;

	tmp->Get_Inheritted_Class_Members();

	Scope->Defined.push_back(tmp);

	//update now the parent funcion to aling all the stack offset to right
	P.Define_Sizes(Scope);

	//the move from right to tmp needs to be hand made, because we dont have call to string functions.

	Node* Set = new Node(ASSIGN_OPERATOR_NODE, Input[i]->Location);
	Set->Name = "=";
	Set->Scope = Scope;
	Set->Left = tmp;
	Set->Right = Input[i]->Right;

	Set->Left->Context = Set;
	Set->Right->Context = Set;

	Set->Parsed_By |= PARSED_BY::REFERENCE_COUNT_INCREASE;
	Component Move("=", Flags::OPERATOR_COMPONENT);
	Move.node = Set;

	Parser p(Scope);
	p.Input.push_back(Move);
	tmp->Append(p.Input,Lexer::GetComponents("\n" + tmp->Name + ".Reference_Count++\n"));

	Set = new Node(ASSIGN_OPERATOR_NODE, Input[i]->Location);
	Set->Name = "=";
	Set->Scope = Scope;
	Set->Left = Input[i]->Left;
	Set->Right = tmp;
	Set->Parsed_By |= PARSED_BY::REFERENCE_COUNT_INCREASE;
	Move = Component("=", Flags::OPERATOR_COMPONENT);
	Move.node = Set;

	p.Input.push_back(Move);

	/*Input.erase(Input.begin() + i);	//erase the old move that initiated this whole function.
	i--;*/
	Input[i]->Parsed_By |= PARSED_BY::IRGENERATOR;
	p.Factory();

	P.Components = p.Input;
	P.Factory();

	IRGenerator g(Scope, P.Input, Output);
}

void IRGenerator::Parse_Jump(int i)
{
	if (Input[i]->Name != "jump")
		return;
	if (Input[i]->is(PARSED_BY::IRGENERATOR))
		return;

	string Label_Name = Input[i]->Right->Name;

	Node* Func = Scope->Find(Input[i]->Right->Name);

	if (Func != nullptr && Func->Has({ FUNCTION_NODE, IMPORT, EXPORT, PROTOTYPE }))
		Label_Name = Func->Mangled_Name;

	Output->push_back(Make_Jump("jump", Label_Name));
	Input[i]->Parsed_By |= PARSED_BY::IRGENERATOR;
}

void IRGenerator::Parse_Labels(int i)
{
	if (!Input[i]->is(LABEL_NODE))
		return;

	Output->push_back(new IR(new Token(TOKEN::LABEL, Input[i]->Name), {}, Input[i]->Location));
}

void IRGenerator::Parse_Parenthesis(int i)
{
	if (!Input[i]->is(CONTENT_NODE))
		return;
	if (Input[i]->is(PARSED_BY::IRGENERATOR))
		return;
	if (Input[i]->Paranthesis_Type == '(') {


		//b++ + (b++ + 1)
		IRGenerator g(Scope, Input[i]->Childs, Output);

		if (g.Handle != nullptr)
			Handle = g.Handle;
		else {
			//mov the variable into a reg.
			Token* C = new Token(Input[i]->Find(Input[i]->Childs[0], Input[i]->Childs[0]->Scope));
			if (C->is(TOKEN::CONTENT))
				C = new Token(TOKEN::MEMORY, { C }, C->Get_Size(), C->Get_Name());

			Token* Reg = new Token(TOKEN::REGISTER, "REG_" + C->Get_Name(), C->Get_Size());
			//create the IR
			Token* Opc = new Token(TOKEN::OPERATOR, "=");
			IR* ir = new IR(Opc, { Reg, C }, Input[i]->Location);

			Handle = Reg;
			Output->push_back(ir);
		}
	}
	else if (Input[i]->Paranthesis_Type == '{') {
		IRGenerator g(Scope, Input[i]->Childs, Output);
	}
	Input[i]->Parsed_By |= PARSED_BY::IRGENERATOR;
}

void IRGenerator::Update_Operator(Node* n)
{
	if (n == nullptr)
		return;
	if (!n->is(OPERATOR_NODE) && !n->is(ASSIGN_OPERATOR_NODE) && !n->is(CONDITION_OPERATOR_NODE) && !n->is(BIT_OPERATOR_NODE) && !n->is(LOGICAL_OPERATOR_NODE))
		return;
	Update_Operator(n->Left);
	Update_Operator(n->Right);

	n->Inheritted = n->Left->Inheritted;
}

void IRGenerator::Generate_Global_Variable(string Variable_Name, Node* Value)
{
	Output->push_back(Make_Label(Variable_Name));

	Token* value = new Token(Value);

	string Init_Type = "init";
	if (value->is(TOKEN::STRING))
		Init_Type = "ascii";
	Output->push_back(new IR(new Token(TOKEN::SET_DATA, Init_Type), { value }, nullptr));
	if (value->is(TOKEN::STRING))
		Output->push_back(new IR(new Token(TOKEN::SET_DATA, "init"), { new Token(TOKEN::STRING, "0", 1) }, nullptr));
}

void IRGenerator::Generate_Global_Variable(string Variable_Name, int Size)
{
	Node* Value = new Node(NUMBER_NODE, nullptr);
	Value->Name = "0";
	Value->Size = Size;
	Generate_Global_Variable(Variable_Name, Value);
}

void IRGenerator::Parse_Global_Variables(Node* n)
{
	if (Scope->Name != "GLOBAL_SCOPE")
		return;

	if (!n->is(ASSIGN_OPERATOR_NODE))
		return;

	n->Right->Size = n->Find(n->Left, n)->Size;
	Generate_Global_Variable(n->Left->Name, n->Right);
}

void IRGenerator::Parse_Static_Variables(Node* n)
{
	if (n->is(CLASS_NODE)) {
		if (n->is("static") != -1)
			for (auto i : n->Childs)
				Parse_Static_Variables(i);
		else
			for (auto i : n->Header)
				Parse_Static_Variables(i);
		return;
	}

	if (n->Has({ OPERATOR_NODE, ASSIGN_OPERATOR_NODE, CONDITION_OPERATOR_NODE, BIT_OPERATOR_NODE })) {
		//{[Namespace name] + [Static variable name]} d[size] [Value]
		Generate_Global_Variable(n->Scope->Name + "_" + n->Left->Name, n->Right);
	}
	else if (n->Has({ OBJECT_DEFINTION_NODE, OBJECT_NODE })) {
		//{[Namespace name] + [Static variable name]} d[size] 0
		Generate_Global_Variable(n->Scope->Name + "_" + n->Name, n->Size);
	}
}

void IRGenerator::Parse_Member_Fetch(Node* n)
{
	if (n->Fetcher == nullptr)
		return;
	if (Handle != nullptr)
		return;		//the job has already been done
	if (n->is(NUMBER_NODE))
		return;	//x.size										//They're were Holders, both of em actually... srry, i dont know what this does m8!
	if ((!Is_In_Left_Side_Of_Operator && n->Context == nullptr) || (n->Scope != nullptr && n->Scope->Has({ CLASS_NODE, FUNCTION_NODE, IF_NODE, ELSE_IF_NODE, ELSE_NODE }) == false))
		return;
	if (n->is(CALL_NODE))
		return;
	if (n->is(PARSED_BY::IRGENERATOR))
		return;


	if (n->is("static") != -1 || n->Fetcher->is("static") != -1) {
		if (Scope->is(FUNCTION_NODE)) {
			//this now namespace if the condition above yelds true.
			bool Load_To_Reg = true;

			if (n->Context->Name == "=" && n->Context->Left == n)
				Load_To_Reg = false;	//the label data is going to be rewritten by set operator.

			if (!n->Fetcher->is(CLASS_NODE))
				n->Fetcher = n->Find(n->Fetcher->Inheritted[0]);

			Token* Result = new Token(TOKEN::MEMORY, { new Token(n) }, n->Size, n->Name);

			if (Load_To_Reg) {
				Token* Reg = new Token(TOKEN::REGISTER, n->Fetcher->Name + "_" + n->Name + "_REGISTER", n->Size);
				Output->push_back(new IR(new Token(TOKEN::OPERATOR, "="),
					{
						Reg, Result
					}, nullptr));
				Result = Reg;
			}

			n->Parsed_By |= PARSED_BY::IRGENERATOR;
			Handle = Result;
			return;
		}
		n->Parsed_By |= PARSED_BY::IRGENERATOR;
		Handle = new Token(n);
		return;
	}

	Token* Fecher;
	IRGenerator g(n->Scope, { n->Fetcher }, Output, true);
	if (g.Handle != nullptr)
		Fecher = g.Handle;
	else
		Fecher = new Token(n->Fetcher);

	if (Fecher->is(TOKEN::MEMORY)) {
		Fecher = Fecher->Childs.back();
	}

	//if the fetcher is a memory we need to load it first to a register and that register is our handle for the member offset
	if (Fecher->is(TOKEN::CONTENT) && !n->Fetcher->Has({OPERATOR_NODE, CONDITION_OPERATOR_NODE, ASSIGN_OPERATOR_NODE, BIT_OPERATOR_NODE, ARRAY_NODE}) && n->Fetcher->is("ptr") != -1) {
		//call the pointter handle system to do our job here :D
		//															 - 1 because the fecher being memory 
		//															the pointter operator alrerady because of that does one unwrap
		Fecher = Operate_Pointter(Fecher, n->Fetcher->Get_All("ptr"), false, false, n->Fetcher->Inheritted);

	}
	
	//make the member offset
	Token* Member_Offset = new Token(TOKEN::NUM, to_string(n->Find(n->Fetcher, n->Fetcher->Scope)->Find(n->Name)->Memory_Offset));

	Token* Member_Offsetter = new Token(TOKEN::OFFSETTER, "+");
	Member_Offsetter->Left = Fecher;
	Member_Offsetter->Right = Member_Offset;

	long long Type = 0;
	if (n->Format == "decimal")
		Type = TOKEN::DECIMAL;

	Member_Offsetter = new Token(Type | TOKEN::MEMORY, { Member_Offsetter }, n->Find(n->Fetcher, n->Fetcher->Scope)->Find(n->Name)->Size, n->Fetcher->Name + "_" + n->Name);

	if (Is_In_Left_Side_Of_Operator) {
		Handle = Member_Offsetter;
		n->Parsed_By |= PARSED_BY::IRGENERATOR;
		return;
	}
	
	//if not then load this into register
	Token* r = new Token(Type | TOKEN::REGISTER, Member_Offsetter->Get_Name() + "_REG" + to_string(Reg_Random_ID_Addon++), n->Get_Size());

	Output->push_back(new IR(new Token(TOKEN::OPERATOR, "="), { r, Member_Offsetter }, n->Location));

	Handle = new Token(*r);
	n->Parsed_By |= PARSED_BY::IRGENERATOR;
}

/*void IRGenerator::Switch_To_Correct_Places(Node* o)
{
	if (!o->is(OPERATOR_NODE) && !o->is(ASSIGN_OPERATOR_NODE) && !o->is(CONDITION_OPERATOR_NODE) && !o->is(BIT_OPERATOR_NODE))
		return;

	if (o->Left->is(OPERATOR_NODE) || o->Left->is(ASSIGN_OPERATOR_NODE) || o->Left->is(CONDITION_OPERATOR_NODE) || o->Left->is(BIT_OPERATOR_NODE))
		Switch_To_Correct_Places(o->Left);
	if (o->Right->is(OPERATOR_NODE) || o->Right->is(ASSIGN_OPERATOR_NODE) || o->Right->is(CONDITION_OPERATOR_NODE) || o->Right->is(BIT_OPERATOR_NODE))
		Switch_To_Correct_Places(o->Right);

	if (o->Left->is(NUMBER_NODE) && !o->Right->is(NUMBER_NODE)) {
		//switch the left side with right side, what could possibly go wrong?
		//yeah pretty much everythong bro.
		Node* tmp = o->Left;
		o->Left = o->Right;
		o->Right = tmp;
	}
}*/

void IRGenerator::Parse_Static_Casting(Node* n)
{
	//first check is the n has a casting request, and its format casting, no other!
	//int a
	//return a->float
	if (n->Cast_Type == nullptr)
		return;
	if (n->Cast_Type->Name == "address")
		return;
	if (n->is(PARSED_BY::IRGENERATOR))
		return;

	n->Update_Format();

	Node* Caster = n->Find(n->Cast_Type, n, CLASS_NODE);

	if (Caster == nullptr) {
		//if this happends then the catser is not a class but a local defined cast type
		Caster = n->Find(n->Cast_Type, n, OBJECT_DEFINTION_NODE);
	}


	//parse calls, arrays etc..
	Node* cast_Type = n->Cast_Type;
	n->Cast_Type = nullptr;

	int Last_Output_Size = Output->size();

	IRGenerator g(n, { n }, Output);
	Token* Old_Format = nullptr;

	if (Output->size() > Last_Output_Size)
		Handle = g.Handle;

	n->Parsed_By |= PARSED_BY::IRGENERATOR;

	if (g.Handle != nullptr)
		Old_Format = g.Handle;
	else
		Old_Format = new Token(n);

	long long Additional_Flags = TOKEN::MEMORY;
	if (Old_Format->is(TOKEN::DECIMAL))
		Additional_Flags |= TOKEN::DECIMAL;
	if (Old_Format->is(TOKEN::CONTENT)) {
		Old_Format = new Token(Additional_Flags, { Old_Format },  Old_Format->Get_Size(), Old_Format->Get_Name() + "_REGISTER");
	}

	/*if (n->is("ptr") != -1) {
		int amount = 0;
		for (auto i : n->Inheritted)
			if (i == "ptr")
				amount++;
		Old_Format = Operate_Pointter(Old_Format, amount, true, n->Inheritted);
	}*/
	int Casted_Pointter_Count = Get_Amount("ptr", n);
	int Caster_Pointter_Count =	Get_Amount("ptr", Caster);
	
	if (Casted_Pointter_Count > Caster_Pointter_Count) {
		//revome exess ptr
		int Removable_Count = Casted_Pointter_Count - Caster_Pointter_Count;

		//go through all ptr and remove the excess ptr from n inheritance.
		for (int i = 0; i < n->Inheritted.size(); i++)
			if (n->Inheritted[i] == "ptr" && Removable_Count-- > 0)
				n->Inheritted.erase(n->Inheritted.begin() + i);
	}
	else if (Casted_Pointter_Count < Caster_Pointter_Count) {
		int Addable_Pointter_Count = Caster_Pointter_Count- Casted_Pointter_Count;
		for (int i = 0; i < Addable_Pointter_Count; i++) {
			n->Inheritted.push_back("ptr");
		}
	}

	if (n->is(NUMBER_NODE)) {
		n->Format = Caster->Format;
		return;
	}	
	
	//decimal to integer | integer to decimal
	if (Caster->Format == n->Format)
		return;

	long long Type = 0;
	if (n->Find(cast_Type, n, CLASS_NODE)->Format == "decimal")
		Type = TOKEN::DECIMAL;

	Token* r = new Token(Type | TOKEN::REGISTER, "REG_" + n->Name + to_string(Reg_Random_ID_Addon++), n->Find(cast_Type, n, CLASS_NODE)->Get_Size());
	
	Output->push_back(new IR(new Token(TOKEN::OPERATOR, "convert"), {
		r, Old_Format
	}, n->Location));

	Handle = r;
	n->Cast_Type = cast_Type;
}

void IRGenerator::Parse_Dynamic_Casting(Node* n)
{
	if (n->Cast_Type == nullptr)
		return;
	if (n->Cast_Type->Name != "address")
		return;
	if (n->is(PARSED_BY::IRGENERATOR))
		return;


	Node* Other = n->Get_Pair();

	int Casted_Pointter_Count = Get_Amount("ptr", n);
	int Caster_Pointter_Count = Get_Amount("ptr", Other);

	if (Casted_Pointter_Count > Caster_Pointter_Count) {
		//revome exess ptr
		int Removable_Count = Casted_Pointter_Count - Caster_Pointter_Count;

		//go through all ptr and remove the excess ptr from n inheritance.
		for (int i = 0; i < n->Inheritted.size(); i++)
			if (n->Inheritted[i] == "ptr" && Removable_Count-- > 0)
				n->Inheritted.erase(n->Inheritted.begin() + i);
	}
	else if (Casted_Pointter_Count < Caster_Pointter_Count) {
		int Addable_Pointter_Count = Caster_Pointter_Count - Casted_Pointter_Count;
		for (int i = 0; i < Addable_Pointter_Count; i++) {
			n->Inheritted.push_back("ptr");
		}
	}

	n->Parsed_By |= PARSED_BY::IRGENERATOR;
}

void IRGenerator::Parse_Loops(int i)
{
	if (!Input[i]->is(WHILE_NODE))
		return;
	if (Input[i]->is(PARSED_BY::IRGENERATOR))
		return;

	//condition
	//loopinglabel:
	//content
	//condition again
	//end

	Input[i]->Name += "_" + to_string(Label_Differential_ID++);

	//make the condition
	vector<Node*> Header;
	if (Input[i]->Parameters[0]->is(OPERATOR_NODE) || Input[i]->Parameters[0]->is(ASSIGN_OPERATOR_NODE))
		Header = { Input[i]->Parameters[0] };

	vector<Node*> Header_Conditions;
	Input[i]->Append(Header_Conditions, Get_all(CONDITION_OPERATOR_NODE, Input[i]->Parameters));
	Input[i]->Append(Header, Input[i]->Append(Header_Conditions, Get_all(LOGICAL_OPERATOR_NODE, Input[i]->Parameters)));

	vector<Node*> Footer = Get_all(POSTFIX_NODE, Input[i]->Parameters);
	
	if (Input[i]->Parameters[Input[i]->Parameters.size() - 1]->is(OPERATOR_NODE))
		Input[i]->Append(Footer, { Input[i]->Parameters[Input[i]->Parameters.size() - 1] });
	
	Input[i]->Append(Footer, Get_all(PREFIX_NODE, Input[i]->Parameters));

	IRGenerator g(Input[i], Header, Output);

	//make the looping label
	Output->push_back(Make_Label(Input[i], false));

	int start_Index = (int)Output->size();

	//make ir tokens from the code inside the loop
	g.Generate(Input[i]->Childs, false);

	//make the Footter IR
	g.Generate(Footer, false);
	//now do the condition again
	//get the location of the condition
	//vector<Node*> Conditions = Node::Get_all(CONDITION_OPERATOR_NODE, Header);
	g.Generate(Header_Conditions, false);

	//now make the _END addon at the end of loop for the false condition to fall
	Output->push_back(Make_Jump("jump", Input[i]->Name));

	Output->push_back(new IR(new Token(TOKEN::LABEL, Input[i]->Name + "_END"), {}, Input[i]->Location));

	//make here IR that states that every variable that is extern to this while define list must last the same end.
	Output->push_back(new IR(new Token(TOKEN::END_OF_LOOP), Get_All_Extern_Variables((int)Output->size(), start_Index, Input[i]), Input[i]->Location));

	Input[i]->Parsed_By |= PARSED_BY::IRGENERATOR;
}

string IRGenerator::Get_Inverted_Condition(string c, Position* p)
{
	if (c == "==")
		return "!=";
	else if (c == "!=")
		return "==";
	else if (c == "<")
		return ">=";
	else if (c == ">")
		return "<=";
	else if (c == "!<")
		return ">=";
	else if (c == "!>")
		return "<=";
	else if (c == "<=")
		return ">";
	else if (c == ">=")
		return "<";
	Report(Observation(ERROR, "Undefined Condition type " + c, *p));
	return "";
}

vector<Token*> IRGenerator::Get_All_Extern_Variables(int end_index, int start_index, Node* scope)
{
	vector<Token*> Result;
	for (int i = start_index; i < end_index; i++) {
		for (auto a : Output->at(i)->Arguments) {
			if (Find(TOKEN::CONTENT, a).size() > 0) {
				for (auto f : Find(TOKEN::CONTENT, a)) {
					bool is_extern = true;
					for (auto d : scope->Defined) {
						if (f->Get_Name() == d->Name) {
							is_extern = false;
						}
					}
					if (is_extern)
						Result.push_back(f);
				}
			}
			if (Find(TOKEN::PARAMETER, a).size() > 0) {
				for (auto f : Find(TOKEN::PARAMETER, a)) {
					bool is_extern = true;
					for (auto d : scope->Defined) {
						if (f->Get_Name() == d->Name) {
							is_extern = false;
						}
					}
					if (is_extern)
						Result.push_back(f);
				}
			}
		}
	}
	return Result;
}

vector<Token*> IRGenerator::Find(string n, Token* t)
{
	vector<Token*> Result;
	if (t->Get_Name() == n)
		Result.push_back(t);
	if (t->is(TOKEN::CONTENT) || t->is(TOKEN::MEMORY))
		for (auto i : t->Childs)
			if (Find(n, i).size() > 0)
				Global_Scope->Append(Result, Find(n, i));
	if (t->is(TOKEN::OFFSETTER) || t->is(TOKEN::DEOFFSETTER) || t->is(TOKEN::SCALER)) {
		if (Find(n, t->Left).size() > 0)
			Global_Scope->Append(Result, Find(n, t->Left));
		else if (Find(n, t->Right).size() > 0)
			Global_Scope->Append(Result, Find(n, t->Right));
	}
	return Result;
}

vector<Token*> IRGenerator::Find(long n, Token* t)
{
	vector<Token*> Result;
	if (t->is(n))
		Result.push_back(t);
	if (t->is(TOKEN::CONTENT) || t->is(TOKEN::MEMORY))
		for (auto i : t->Childs)
			if (Find(n, i).size() > 0)
				Global_Scope->Append(Result, Find(n, i));
	if (t->is(TOKEN::OFFSETTER) || t->is(TOKEN::DEOFFSETTER) || t->is(TOKEN::SCALER)) {
		if (Find(n, t->Left).size() > 0)
			Global_Scope->Append(Result, Find(n, t->Left));
		if (Find(n, t->Right).size() > 0)
			Global_Scope->Append(Result, Find(n, t->Right));
	}
	return Result;
}

Token* IRGenerator::Operate_Pointter(Token* p, int Difference, bool Needed_At_Address_Offsetting, bool Unwrap_Memory, vector<string> Types)
{
	if (p->is(TOKEN::CONTENT)) {
		p = new Token(TOKEN::MEMORY, { p }, _SYSTEM_BIT_SIZE_, p->Get_Name(), p->Get_Parent());
	}
	if (Difference > 0) {	//this p is more pointter that the other
		vector<string> Type_Trace = Types;
		if (Types.size() == 0)
			Type_Trace = Global_Scope->Find(p->Get_Name(), p->Get_Parent())->Inheritted;
		//reverse(Type_Trace.begin(), Type_Trace.end());

		//load the Left to right level
		//mov reg1, [(esp+123)]
		//mov reg2, [reg1]
		//give Left [reg2]
		//set the Left size into right system bit size
		p->Set_Size(_SYSTEM_BIT_SIZE_);
		Token* handle;
		if (!p->is(TOKEN::MEMORY))
			handle = new Token(TOKEN::MEMORY, { p }, _SYSTEM_BIT_SIZE_, p->Get_Name());	//start from the pointter 
		else
			handle = new Token(*p);
		Token* Reg = nullptr;
		//														  memory uploading needs more unwrapping.
		for (int j = 0; j <= Difference - !Needed_At_Address_Offsetting + Unwrap_Memory; j++) {
			int Reg_Size = _SYSTEM_BIT_SIZE_;
			if (j + 1 <= Difference + p->is(TOKEN::MEMORY)) {
				Reg_Size = 0;
				//	 -j because we need to remove the current ptr to see what is inside it
				for (int s = (int)Type_Trace.size() - 1 - j - !p->is(TOKEN::MEMORY); s >= 0; s--) {
					//keywords dont have defined in the find list so skip them and put ptr the scaler switch.
					if (Lexer::GetComponents(Type_Trace[s])[0].is(Flags::KEYWORD_COMPONENT)) {
						if (Type_Trace[s] == "ptr") {
							Reg_Size = _SYSTEM_BIT_SIZE_;
							break;
						}
					}
					else
						Reg_Size += Global_Scope->Find(Type_Trace[s], Scope)->Size;
				}

			}

			int Needed_Size = Reg_Size;
			if (Needed_At_Address_Offsetting)
				Needed_Size = _SYSTEM_BIT_SIZE_;
			handle->Set_Size(Needed_Size);
			Reg = new Token(TOKEN::REGISTER, handle->Get_Name() + "_REG" + to_string(Reg_Random_ID_Addon++), Needed_Size);

			//move from handle to reg
			Output->push_back(new IR(new Token(TOKEN::OPERATOR, "="), {
				new Token(*Reg), new Token(*handle)
			}, nullptr));

			//keep the old handle 
			//if (j + 1 < Level_Difference) {
			//replace the Original Left, to the new Reg for next loop.
			handle->Childs.back() = Reg;
			handle->Set_Name(Reg->Get_Name());
			//}
		}
		if (Needed_At_Address_Offsetting)
			Reg->Set_Size(_SYSTEM_BIT_SIZE_);
		return Reg;
	}
	if (Difference < 0) {
		//save the address of Right into Left
		Token* reg = new Token(TOKEN::REGISTER, p->Get_Name() + "_REG" + to_string(Reg_Random_ID_Addon++), _SYSTEM_BIT_SIZE_);

		Token* Right_Mem;
		if (!p->is(TOKEN::MEMORY))
			Right_Mem = new Token(TOKEN::MEMORY, { p }, _SYSTEM_BIT_SIZE_, p->Get_Name());
		else
			Right_Mem = p;

		if (Right_Mem->Get_Size() != reg->Get_Size())
			Right_Mem->Set_Size(reg->Get_Size());

		Output->push_back(new IR(new Token(TOKEN::OPERATOR, "evaluate"), { new Token(*reg), Right_Mem }, nullptr));
		return reg;
	}
	return p;
}

IR* IRGenerator::Make_Label(Node* n, bool Mangle = false)
{
	string name = n->Name;
	if (Mangle)
		name = MANGLER::Mangle(n, "");
	Token* label_name = new Token(TOKEN::LABEL, name);
	label_name->OG = n->Name;

	Node* Scope_Path = Scope;
	if (n->Fetcher != nullptr)
		Scope_Path = n->Fetcher;

	label_name->Set_Parent(Scope_Path);

	IR* label = new IR(n->Location);
	label->OPCODE = label_name;
	return label;
}

IR* IRGenerator::Make_Label(string n)
{
	string name = n;
	Token* label_name = new Token(TOKEN::LABEL, name);
	IR* label = new IR(nullptr);
	label->OPCODE = label_name;
	return label;
}

IR* IRGenerator::Make_Jump(string condition, string l)
{
	Token* jmp = new Token(TOKEN::FLOW, condition);
	Token* label = new Token(TOKEN::LABEL, l);
	IR* op = new IR(nullptr);
	op->OPCODE = jmp;
	op->Arguments.push_back(label);
	return op;
}

int IRGenerator::Get_Amount(string t, Node* n)
{
	int result = 0;
	for (string s : n->Inheritted)
		if (s == t)
			result++;

	return result;
}

void IRGenerator::Parse_Return(int i) {
	if (!Input[i]->is(FLOW_NODE))
		return;
	if (Input[i]->Name != "return")
		return;
	if (Input[i]->is(PARSED_BY::IRGENERATOR))
		return;


	if (Input[i]->Right) {
		bool Can_Modify_Last_Variable_Value = true;
		for (auto j : Input[i]->Right->Has(Input[i]->Right, OBJECT_NODE)) {
			if (j->Has({ OBJECT_DEFINTION_NODE, OBJECT_NODE }) && j->Find(j, j->Scope)->Scope == Global_Scope)
				Can_Modify_Last_Variable_Value = false;
			if (j->is("ptr") != -1)
				Can_Modify_Last_Variable_Value = false;
		}

		IRGenerator g(Scope, Input[i]->Header, Output);

		g.Generate({ Input[i]->Right }, Can_Modify_Last_Variable_Value);

		Token* Return_Val = nullptr;
		if (g.Handle != nullptr)
			Return_Val = g.Handle;
		else
			Return_Val = new Token(Input[i]->Right);

		Node* p = Input[i]->Get_Scope_As(FUNCTION_NODE, Input[i]);

		int Returning_Reg_Size = 0;
		for (auto& j : p->Inheritted) {
			if (j == "ptr") {
				Returning_Reg_Size = _SYSTEM_BIT_SIZE_;
				break;
			}
			if (Lexer::GetComponents(j)[0].is(Flags::KEYWORD_COMPONENT))
				continue; //skip keywords
			Returning_Reg_Size += Global_Scope->Find(j, Global_Scope)->Size;
		}

		int Level_Difference = Get_Amount("ptr", Input[i]->Right) - Get_Amount("ptr", p);
		//int main(){
		//int ptr fuz = foo()
		//return fuz()
		//}
		if (Input[i]->Right->Function_Ptr) {
			if (Level_Difference < 0) {
				Return_Val = Operate_Pointter(Return_Val, Level_Difference, false, Return_Val->is(TOKEN::CONTENT), Input[i]->Right->Inheritted);
			}
			else if (Level_Difference > 0) {
				Level_Difference = 0;
			}
		}
		else if (Level_Difference != 0) {
			Return_Val = Operate_Pointter(Return_Val, Level_Difference, false, Return_Val->is(TOKEN::CONTENT), Input[i]->Right->Inheritted);
		}
		else if (Return_Val->is(TOKEN::CONTENT)) {
			Token* m = new Token(TOKEN::MEMORY, { Return_Val }, Returning_Reg_Size, Return_Val->Get_Name());
			Return_Val = m;
		}

		if (Return_Val->is(TOKEN::NUM) && Returning_Reg_Size != 0)
			Return_Val->Set_Size(Returning_Reg_Size);

		long long Flag = TOKEN::REGISTER | TOKEN::RETURNING;

		if (Return_Val->is(TOKEN::DECIMAL))
			Flag |= TOKEN::DECIMAL;

		Output->push_back(new IR(new Token(TOKEN::OPERATOR, "="), {
			new Token(Flag, "Returning_REG" + to_string(Reg_Random_ID_Addon++), Returning_Reg_Size),
			Return_Val }
		, Input[i]->Location));
	}
	//let the postprosessor to handle stack emptying!
	Token* ret = new Token(TOKEN::FLOW, "return");
	ret->Set_Parent(Scope);
	Output->push_back(new IR(ret, vector<Token*>{}, Input[i]->Location));

	Input[i]->Parsed_By |= PARSED_BY::IRGENERATOR;
}
C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Cpp\BackEnd\IRPostProsessor.cpp" 
#include "../../H/BackEnd/IRPostProsessor.h"
#include "../../H/Nodes/Node.h"
#include "../../H/Docker/Mangler.h"

extern Selector* selector;
extern Node* Global_Scope;

void IRPostProsessor::Scale_To_Same_Size(int i)
{
	if (!Input->at(i)->is(TOKEN::OPERATOR))
		return;

	if (Input->at(i)->Arguments.size() < 2)
		return;

	if (!selector->Get_Opcode(Input->at(i))->is(TOKEN::ALL_ARGS_SAME_SIZE))
		return;

	//numbers seem to be exeptions to this particular rule...
	for (auto j : Input->at(i)->Arguments)
		if (j->is(TOKEN::NUM))
			return;

	//there IR's are still universal so dont worry about, if there is more than 2 arguments with the operator.
	//convert always the smaller into the bigger size
	Token* Scalable = nullptr;
	int Destination_Size = 0;
	int ArgIndex = 0;

	if (Input->at(i)->Arguments[0]->Get_Size() > Input->at(i)->Arguments[1]->Get_Size()) {
		//this means that right side is smaller, scale.
		Scalable = Input->at(i)->Arguments[1];
		ArgIndex = 1;	//tell later that were the scalable originates from.
		Destination_Size = Input->at(i)->Arguments[0]->Get_Size();
	}
	else if (Input->at(i)->Arguments[0]->Get_Size() < Input->at(i)->Arguments[1]->Get_Size()) {
		//this means thatthe left side is smaller, scale.
		Scalable = Input->at(i)->Arguments[0];
		ArgIndex = 0; //tell later where scalable originates from.
		Destination_Size = Input->at(i)->Arguments[1]->Get_Size();
	}
	else {
		//this means that theyre same size
		return;
	}

	Token* NewReg = new Token(TOKEN::REGISTER, Scalable->Get_Name() + "_converted", Destination_Size);

	Token* Convert = new Token(TOKEN::OPERATOR, "convert");
	IR* CONV = new IR(Convert, { NewReg, new Token(*Scalable) }, Input->at(i)->Location);

	//now put the newreg where the scalable was.
	Input->at(i)->Arguments[ArgIndex] = NewReg;

	//now insert the new converter before the operator
	Input->insert(Input->begin() + i, CONV);
}

void IRPostProsessor::Registerize(Token* t, int i)
{
	//mov eax, ebx
	if (t->is(TOKEN::REGISTER)) {
		Give_New_Register(t, i);
	}
	else if (t->is(TOKEN::MEMORY) || t->is(TOKEN::CONTENT))
		for (auto c : t->Childs)
			Registerize(c, i);
	else if (t->is(TOKEN::OFFSETTER) || t->is(TOKEN::DEOFFSETTER) || t->is(TOKEN::SCALER)) {
		Registerize(t->Left, i);
		Registerize(t->Right, i);
	}
}

void IRPostProsessor::Give_New_Register(Token* t, int i)
{
	if (!t->is(TOKEN::REGISTER) || t->is(TOKEN::ALREADY_GIVEN_REGISTER_NAME))
		return;
	//if (t->Get_Name() == ".RIP") {
	//	cout << ".";
	//}
	if (selector->Get_Memory_Location(t) == nullptr || !t->is(TOKEN::REGISTER_SAVE_SPACE)) {
		if (selector->Get_Register(t) == nullptr)
			if (selector->Get_New_Reg(Input, i, t) == nullptr) {
				selector->Allocate_Register(Input, i, t);
				goto Use_Memory_Instead_Of_Register;
			}
		t->ID = selector->Get_Register(t)->Get_Name();
	}
	else {
	Use_Memory_Instead_Of_Register:;
		*t = *selector->Get_Memory_Location(t);
		Handle_Stack_Usages(t);
	}
	//if (t->Get_Name() == "REG_2") {
	//	cout << ".";
	//}
}

void IRPostProsessor::Handle_Global_Labels()
{
	for (auto i : Global_Scope->Header) {
		//if (i->is(IMPORT))
		//	Input->insert(Input->begin(), new IR(new Token(TOKEN::GLOBAL_LABEL, "extern"), { new Token(TOKEN::LABEL, MANGLER::Mangle(i)) }, nullptr));
		/*else*/ if (i->is("export") != -1)
			Input->insert(Input->begin(), new IR(new Token(TOKEN::GLOBAL_LABEL, "global"), { new Token(TOKEN::LABEL,  MANGLER::Mangle(i, "")) }, nullptr));

	}
}

void IRPostProsessor::Clean_Selector(int& i)
{
	if (!Input->at(i)->is(TOKEN::END_OF_FUNCTION))
		return;
	if (Input->at(i)->OPCODE->Is_Initted)
		return;
	Input->at(i)->OPCODE->Is_Initted = true;
	//get the start of function index
	int Start_Of_Function = 0;
	for (int j = i; j > 0; j--)
		if (Input->at(j)->is(TOKEN::START_OF_FUNCTION)) {
			Start_Of_Function = j;
			break;
		}
	Start_Of_Function += 1; //Skip the label
	//now we know what non-volatiles are in use
	vector<Token*> Push_Amount;
	int Additional_Changes = 0;
	int Return_Amount = 0;
	for (auto r : selector->Get_Register_Type(TOKEN::NONVOLATILE)) {
		if (r.first == nullptr)
			continue;

		Token* reg;

		//if the same nonvolatile is in other size used
		for (auto p : Push_Amount) {
			for (auto s : p->Get_Connected_Registers(p)) {
				if (s->Get_Name() == r.second->Get_Name()) {
					goto Already_Pushed;
				}
			}
		}

		reg = new Token(*r.second->Get_Size_Parent(_SYSTEM_BIT_SIZE_, r.second));
		reg->ID = reg->Get_Name();
		Input->insert(Input->begin() + Start_Of_Function, new IR(new Token(TOKEN::OPERATOR, "push"), { reg }, Input->at(i)->Location));
		Additional_Changes += Parse_Complex(Input->at(Start_Of_Function), Start_Of_Function, true);
		Push_Amount.push_back(reg);
	Already_Pushed:;
	}

	//Compute here the needed re-location of the function parameters
	int New_Stack_Offset = 0;
	for (auto r : Push_Amount)
		New_Stack_Offset += r->Get_Size();
	//start from the bottom of the function and rise up until hit function start label.
	for (int j = i + (int)Push_Amount.size() + Additional_Changes; j > Start_Of_Function; j--) {
		for (auto& arg : Input->at(j)->Arguments)
			for (auto& Child : arg->Get_All(TOKEN::ADD_NON_VOLATILE_SPACE_NEEDS_HERE)) {
				int Current_Offset = atoi(Child->Get_Name().c_str());
				Current_Offset += New_Stack_Offset;
				Child->Set_Name(to_string(Current_Offset));

			}
	}

	reverse(Push_Amount.begin(), Push_Amount.end());

	//now do same but for the end of funciton
	for (int j = i + (int)Push_Amount.size() + Additional_Changes; j > Start_Of_Function; j -= 1) {
		if (Input->at(j)->OPCODE->Get_Name() != "return")
			continue;
		Return_Amount++;
		Token* ret = Input->at(j)->OPCODE;
		for (auto r : Push_Amount) {
			Token* reg = new Token(*r->Get_Size_Parent(_SYSTEM_BIT_SIZE_, r));
			reg->ID = reg->Get_Name();


			Input->insert(Input->begin() + j, new IR(new Token(TOKEN::OPERATOR, "pop"), { reg }, Input->at(i)->Location));
			Parse_Complex(Input->at(j), j, true);
		}
		Node* Parent = Global_Scope->Get_Scope_As(FUNCTION_NODE, ret->Get_Parent());
		if (Parent->Size_of_Call_Space + Parent->Local_Allocation_Space > 0) {
			selector->DeAllocate_Stack(Parent->Size_of_Call_Space + Parent->Local_Allocation_Space, Input, j);
			for (auto k : Input->at(j)->Arguments)
				Registerize(k, j);
		}
	}

	for (int j = i + (int)Push_Amount.size() + Additional_Changes; j > Start_Of_Function; j--) {
		for (auto& arg : Input->at(j)->Arguments)
			for (auto& Child : arg->Get_All(TOKEN::LOCAL_VARIABLE_SCOPE)) {
				int Current_Offset = atoi(Child->Get_Name().c_str());
				Current_Offset += selector->Calculate_Memory_Address(TOKEN::LOCAL_VARIABLE_SCOPE);
				Child->Set_Name(to_string(Current_Offset));

			}
	}

	selector->Clean_Register_Holders();
	selector->Clean_Stack();
	//find the current end of function location.
	for (; !Input->at(i)->is(TOKEN::END_OF_FUNCTION); i++);
}

void IRPostProsessor::Prepare_Function(int& i)
{
	if (!Input->at(i)->is(TOKEN::START_OF_FUNCTION))
		return;

	//selector->Allocate_Stack(Global_Scope->Find(Input->at(i)->OPCODE->Get_Name(), Global_Scope)->Max_Allocation_Space, Input, i + 1);
	
	Node* Scope = Input->at(i)->OPCODE->Get_Parent();

	Node* Func = Scope->Find(Input->at(i)->OPCODE->OG);

	int Before_OpCode_Additions = Input->size();
	for (auto p : Func->Defined) {
		if (!p->is(PARAMETER_NODE))
			continue;
		Token* tmp = new Token(p);
		if (tmp->is(TOKEN::REGISTER))
			selector->Get_New_Reg(Input, i+1, new Token(p));
	}

	i += (Input->size() - Before_OpCode_Additions) + (Input->size() > Before_OpCode_Additions);
}

void IRPostProsessor::Handle_Labels(int i)
{
	if (!Input->at(i)->is(TOKEN::LABEL))
		return;

	if (!Input->at(i)->is(TOKEN::START_OF_FUNCTION))
		return;

	Node* Scope = Input->at(i)->OPCODE->Get_Parent();

	Node* Func = Scope->Find(Input->at(i)->OPCODE->OG, Scope, FUNCTION_NODE);

	if (Func->Size_of_Call_Space == 0 && Func->Local_Allocation_Space == 0)
		return;

	selector->Allocate_Stack(Func->Size_of_Call_Space + Func->Local_Allocation_Space, Input, i + 1);

	selector->Init_Stack(Func);
}

void IRPostProsessor::Handle_Stack_Usages(Token* t)
{
	if (t->is(TOKEN::MEMORY))
		for (auto& i : t->Childs)
			Handle_Stack_Usages(i);
	if (t->is(TOKEN::OFFSETTER) || t->is(TOKEN::DEOFFSETTER) || t->is(TOKEN::SCALER)) {
		Handle_Stack_Usages(t->Left);
		Handle_Stack_Usages(t->Right);
	}
	if (!t->is(TOKEN::CONTENT))
		return;

	if (t->is(TOKEN::GLOBAL_VARIABLE)) {
		*t = Token(TOKEN::OFFSETTER, "+", new Token(TOKEN::POSITION_INDEPENDENT_REGISTER | TOKEN::REGISTER, ".RIP", _SYSTEM_BIT_SIZE_), new Token(TOKEN::GLOBAL_VARIABLE, t->Get_Name(), t->Get_Size()));
	}
	else {
		if (t->Has({ TOKEN::REGISTER_SAVE_SPACE })) {
			*t = Token(TOKEN::OFFSETTER, "+", new Token(TOKEN::STACK_POINTTER | TOKEN::REGISTER, ".STACK", _SYSTEM_BIT_SIZE_), new Token(TOKEN::NUM, to_string(selector->Calculate_Memory_Address(t))));
		}
		else {
			//first update the stack offset.
			Node* Function = t->Get_Parent();

			/*Function->Update_Defined_Stack_Offsets();*/

			Node* og = Function->Find(t->Get_Name());

			//this is for memory usage parameters
			long long Pushes_Also_Determine_The_Parameter_Location = TOKEN::NUM;
			if (og->is(PARAMETER_NODE) && !Token(og, true).is(TOKEN::REGISTER))
				Pushes_Also_Determine_The_Parameter_Location |= TOKEN::ADD_NON_VOLATILE_SPACE_NEEDS_HERE;
			else
				Pushes_Also_Determine_The_Parameter_Location |= TOKEN::LOCAL_VARIABLE_SCOPE;


			long long Offset = 0;// = selector->Calculate_Memory_Address(TOKEN::LOCAL_VARIABLE_SCOPE);

			//Maybe we need to add the parameters addresses here?
			if (og->Memory_Offset >= 0 || og->is(PARAMETER_NODE))
				*t = Token(TOKEN::OFFSETTER, "+", new Token(TOKEN::STACK_POINTTER | TOKEN::REGISTER, ".STACK", _SYSTEM_BIT_SIZE_), new Token(Pushes_Also_Determine_The_Parameter_Location, to_string(og->Memory_Offset + Offset)));
			/*else if (og->Memory_Offset + Offset == 0)
				*t = Token(TOKEN::STACK_POINTTER | TOKEN::REGISTER, ".STACK", _SYSTEM_BIT_SIZE_);*/
			else if (og->Memory_Offset < 0)
				*t = Token(TOKEN::DEOFFSETTER, "-", new Token(TOKEN::STACK_POINTTER | TOKEN::REGISTER, ".STACK", _SYSTEM_BIT_SIZE_), new Token(Pushes_Also_Determine_The_Parameter_Location, to_string(og->Memory_Offset + Offset)));
		}
	}
}

int IRPostProsessor::Parse_Complex(IR* ir, int i, bool Registry)
{
	if (!ir->is(TOKEN::OPERATOR))
		return 0;
	if (selector->Get_Opcode(ir)->Complex != nullptr) {
		vector<IR*> r = selector->Get_Opcode(ir)->Complex(ir->Arguments);
		if (r.size() == 0)
			return 0;
		int Changes = r.size() - 1;
		if (Registry)
			for (int opc = 0; opc < r.size(); opc++)
				for (auto arg : r[opc]->Arguments) {
					Registerize(arg, i + opc);
				}
		Input->erase(Input->begin() + i);
		Input->insert(Input->begin() + i, r.begin(), r.end());
		//go through the added complex content and iterate them into complex again, 
		//this feature is made for recursive complex usage.
		for (int j = 0; j < r.size(); j++)
			Changes += Parse_Complex(Input->at(i + j), i + j, Registry);
		return Changes;
	}
	return 0;
}

void IRPostProsessor::Factory()
{
	Handle_Global_Labels();
	for (int i = 0; i < Input->size(); i++)
		Parse_Complex(Input->at(i), i, false);
	for (int i = 0; i < Input->size(); i++)
		Scale_To_Same_Size(i);
	for (int i = 0; i < Input->size(); i++) {
		selector->Reset_Parameter_Register_Count(Input->at(i));
		Prepare_Function(i);
		Handle_Labels(i);
		IR* Holder = Input->at(i);
		reverse(Holder->Arguments.begin(), Holder->Arguments.end());
		for (auto a : Holder->Arguments) {
			Handle_Stack_Usages(a);
			Registerize(a, i);
		}
		reverse(Holder->Arguments.begin(), Holder->Arguments.end());
		Clean_Selector(i);
	}
}

C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Cpp\BackEnd\Selector.cpp" 
#include "../../H/BackEnd/Selector.h"
#include "../../H/UI/Usr.h"
#include "../../H/UI/Safe.h"

extern Usr* sys;
extern x86_64 X86_64;
extern ARM_64 _ARM_64;

void Selector::Init() {
	if (sys->Info.Architecture == "x86") {
		if (sys->Info.Bits_Mode == "8") {
			X86_64.Init();
			for (auto i : X86_64.Registers)
				Registers.push_back({ nullptr, i });
			for (auto i : X86_64.Parameter_Registers) {
				Parameter_Registers.push_back(Transform(i));
			}
			Opcodes = X86_64.Opcodes;
			Size_Identifiers = X86_64.Size_Identifiers;

			//DEBUG
			STACK_REPRESENTIVE_REGISTER = X86_64.STACK_REPRESENTIVE_REGISTER;
		}

	}
	else if (sys->Info.Architecture == "arm") {
		if (sys->Info.Bits_Mode == "8") {
			if (sys->Info.OS == "win" || sys->Info.OS == "unix") {
				_ARM_64.Init();
				for (auto i : _ARM_64.Registers)
					Registers.push_back({ nullptr, i });
				for (auto i : _ARM_64.Parameter_Registers) {
					Parameter_Registers.push_back(Transform(i));
				}
				Opcodes = _ARM_64.Opcodes;
				Size_Identifiers = _ARM_64.Size_Identifiers;

				//DEBUG
				STACK_REPRESENTIVE_REGISTER = X86_64.STACK_REPRESENTIVE_REGISTER;
			}
		}
	}
}

bool Selector::Find(string n, Token* ast)
{
	if (ast->Get_Name() == n)
		return true;
	if (ast->is(TOKEN::CONTENT) || ast->is(TOKEN::MEMORY))
		for (auto& i : ast->Childs)
			//throw::runtime_error("haha nobnob");
			return Find(n, i);
	if (ast->is(TOKEN::OFFSETTER) || ast->is(TOKEN::DEOFFSETTER) || ast->is(TOKEN::SCALER)) {
		if (Find(n, ast->Left))
			return true;
		if (Find(n, ast->Right))
			return true;
	}
	return false;
}

bool Selector::Find(Token* n, Token* ast)
{
	if ((ast == n) || (ast->Get_Name() == n->Get_Name() && ast->is(n->Get_Flags())))
		return true;
	if (ast->is(TOKEN::CONTENT) || ast->is(TOKEN::MEMORY))
		for (auto& i : ast->Childs)
			//throw::runtime_error("haha nobnob");
			return Find(n, i);
	if (ast->is(TOKEN::OFFSETTER) || ast->is(TOKEN::DEOFFSETTER) || ast->is(TOKEN::SCALER)) {
		if (Find(n, ast->Left))
			return true;
		if (Find(n, ast->Right))
			return true;
	}
	return false;
}

int L1 = 0;
vector<Token*> Selector::Transform(Token* parent)
{
	vector<Token*> Result;
	if (L1 == 0)
		Result.push_back(parent);
	L1++;
	for (auto c : *parent->Get_Childs()) {
		Result.push_back(c);
		vector<Token*> r = Transform(c);
		Result.insert(Result.end(), r.begin(), r.end());
	}
	L1--;
	return Result;
}

Path* Selector::Get_Path_Info(vector<IR*> source, int i, Token* t) {
	Path* p = new Path;
	//try to find if this t* is used in future
	//also check if it intersects cllations
	vector<int> Intersects_Calls;
	int Crossed_Call = -1;
	int Parameter_Place = -1;
	int Last_Usage = i;
	for (int j = i; j < source.size(); j++) {
		for (auto k : source[j]->Arguments) {
			//TODO: Cheking names wont work on duplicated local varibles inside a condition like scopes.
			if (Find(t, k)) {
				//check if this is the same variable...
				Last_Usage = j;
				if (Crossed_Call != -1) {
					Intersects_Calls.push_back(Crossed_Call);
					Crossed_Call = -1;
				}
			}
		}
		if (source[j]->is(TOKEN::CALL)) {
			Crossed_Call = j;
			//Intersects_Calls.push_back(j);
			for (int k = 0; k < source[j]->OPCODE->Parameters.size(); k++)
				if (source[j]->OPCODE->Parameters[k]->Get_Name() == t->Get_Name()) {
					Last_Usage = j;
					Parameter_Place = k;
				}
		}
		if (source[j]->is(TOKEN::END_OF_FUNCTION))
			break;
	}
	p->Intersects_Calls = Intersects_Calls;
	p->Last_Usage = Last_Usage;
	p->Parameter_Place = Parameter_Place;
	return p;
}

void Selector::Make_Solution_For_Crossed_Register_Usages(pair<Descriptor*, Token*> Current, pair<Descriptor*, Token*> New, vector<IR*>* source, int i)
{
	/*
	mov rbx, [a]
	;try to find non-volatile
	;if no non_volatile then use stack
	;inform stack about the new push
	add rbx, [c]	//a += c
	mov rcx, [b]
	call banana(b)
	mov rcx, rbx
	call banana(a)
	*/
	//get a new non-volatile register to use
	Token* non_volatile = Get_Register(TOKEN::NONVOLATILE, New.first, i, New.second);
	string non_Name = non_volatile->Get_Name();
	string Current_Name = Current.second->Get_Name();
	if (non_volatile == nullptr) {
		//if this happends then all registers are in use and we need to use stack
	}
	else {
		non_volatile = new Token(non_volatile->Get_Flags(), "Non-Volatile" + to_string(rand()), non_volatile->Get_Size());
		non_volatile->ID = non_Name;
	}
	Token* Current_Reg = new Token(Current.second->Get_Flags(), "Current_Volatile" + to_string(rand()), Current.second->Get_Size());
	Current_Reg->ID = Current_Name;
	//now we need to give the cuurent user the new non-volatile register.
	//TODO: Because im a peace of shit and dont know how to implement LIVE register change ill have to make a new move IR
	IR* MOV = new IR(new Token(TOKEN::OPERATOR, "="), {non_volatile, Current_Reg }, nullptr);

	//insert the mov before the new user starts
	source->insert(source->begin() + New.first->First_Usage_Index, MOV);

	//the load back is handled by the situation system, call, etc..

	//now we need to give the current user the new non-volatile
	//if the non-volatile area is a memory then no need to pair
	if (!non_volatile->is(TOKEN::MEMORY))
		Pair_Up(non_volatile, Current.first);

	//break the old connection between the register and the user
	Break_Up(Current.second);

	Pair_Up(Current.second, New.first);
}

Token* Selector::Move_Parameter_Into_Non_Volatile(pair<Path*, Token*> Owner, Token* Current_Reg, vector<IR*>* source, int i)
{
	Token* New_Reg = new Token(TOKEN::REGISTER | TOKEN::NONVOLATILE, Owner.second->Get_Name(), Owner.second->Get_Size());
	New_Reg->ID = Get_New_Reg(source, i, New_Reg, Owner.first)->Get_Name();

	Token* New_Token = new Token(*Owner.second);

	New_Token->ID = Current_Reg->Get_Name();
	//New_Token->Set_Name(Current_Reg->Get_Name());

	source->insert(source->begin() + i, new IR(new Token(TOKEN::OPERATOR, "="), { New_Reg, New_Token }, nullptr));

	return New_Reg;
}

Token* Selector::Get_New_Reg(vector<IR*>* source, int i, Token* t, Path* path)
{
	Path* p = path;
	if (p == nullptr)
		p = Get_Path_Info(*source, i, t);
	if (p->Parameter_Place != -1 && (p->Parameter_Place <= Parameter_Registers.size())) {
		//TODO: this can go broke if there is one or more calls before this so the parameter chosen by this is going to be overwritten :(
		Token* reg = Get_Right_Parameter_Register(t, p->Parameter_Place);

		for (auto& r : Registers) {
			if (r.second->Get_Name() != reg->Get_Name())
				//skip until we get into the right register
				continue;
			if (r.first == nullptr || r.first->Last_Usage_Index <= p->Last_Usage) {
				//no current owner
				r.first = new Descriptor(i, p->Last_Usage, t->Get_Name(), t->Get_Parent());
				return r.second;
			}
			else if (r.first->Last_Usage_Index > p->Last_Usage){
				//if the current register user is more superior register user than us, then we need to do a temporary save to stack 
				Make_Solution_For_Crossed_Register_Usages({ r.first, r.second }, { new Descriptor(i, p->Last_Usage, t->Get_Name(), t->Get_Parent()), t }, source, i);
				//now the wanted register is solutioned :D
				return r.second;
			}
		}
	}
	long long Reg_Type = 0;
	if (t->is(TOKEN::RETURNING))
		Reg_Type |= TOKEN::RETURNING;
	else if (t->is(TOKEN::REMAINDER))
		Reg_Type |= TOKEN::REMAINDER;
	else if (t->is(TOKEN::QUOTIENT))
		Reg_Type |= TOKEN::QUOTIENT;
	else if (t->is(TOKEN::PARAMETER))
		Reg_Type |= TOKEN::PARAMETER;
	else if (t->is(TOKEN::STACK_POINTTER))
		Reg_Type |= TOKEN::STACK_POINTTER;
	else if (t->is(TOKEN::POSITION_INDEPENDENT_REGISTER))
		Reg_Type |= TOKEN::POSITION_INDEPENDENT_REGISTER;
	else if ((p->Intersects_Calls.size() > 0))
		Reg_Type |= TOKEN::NONVOLATILE;
	else if (t->is(TOKEN::NONVOLATILE))
		Reg_Type |= TOKEN::NONVOLATILE;
	else
		Reg_Type |= TOKEN::VOLATILE;
	if (t->is(TOKEN::DECIMAL))
		Reg_Type |= TOKEN::DECIMAL;
	//because there is usually only one register for those purposes we need to enable same typed register usage
	//example: mov eax, eax, if we are returning a call value the value resides in a eax, and the return value in eax.
	//optimizer will remove these errors later on.
	bool Single_Register_Type = t->is(TOKEN::RETURNING) || t->is(TOKEN::REMAINDER) || t->is(TOKEN::QUOTIENT) || t->is(TOKEN::STACK_POINTTER) || t->is(TOKEN::POSITION_INDEPENDENT_REGISTER);

	if (t->Parameter_Index != -1) {
		Token* reg = nullptr;
		int Type_Offset = 0;
		if (t->is(TOKEN::DECIMAL)) {
			while (!Parameter_Registers[Type_Offset][0]->is(TOKEN::DECIMAL))
				Type_Offset++;
		}
		for (auto k : Parameter_Registers[(size_t)Type_Offset + t->Parameter_Index])
			if (k->Get_Size() == t->Get_Size()) {
				reg = k;
				break;
			}

		for (auto& r : Registers) {
			if (r.second->Get_Name() == reg->Get_Name()) {
				if (r.first == nullptr || r.first->Last_Usage_Index <= p->Last_Usage) {

					if (p->Intersects_Calls.size() > 0)
						return Move_Parameter_Into_Non_Volatile({ p, t }, r.second, source, i);

					r.first = new Descriptor(i, p->Last_Usage, t->Get_Name(), t->Get_Parent());

					return r.second;
				}
				else if (r.first->User == t->Get_Name()) {
					return r.second;
				}
				else if (r.first->Last_Usage_Index > p->Last_Usage) {
					//if the current register user is more superior register user than us, then we need to do a temporary save to stack 
					Make_Solution_For_Crossed_Register_Usages({ r.first, r.second }, { new Descriptor(i, p->Last_Usage, t->Get_Name(), t->Get_Parent()), t }, source, i);
					//now the wanted register is solutioned :D
					return r.second;
				}
				else {
					return nullptr;
				}
			}
		}
	}

	//for (auto j : p->Intersects_Calls) {
	//	for (auto a : source->at(j)->OPCODE->Parameters) {
	//		Get_New_Reg(source, j, a);
	//	}
	//}

	for (auto& r : Registers) {
		if (r.second->is(TOKEN::DECIMAL))
			if (!t->is(TOKEN::DECIMAL))
				continue;
		if (r.first == nullptr) {
			if (r.second->is(Reg_Type)) {
				for (auto s : *r.second->Get_Childs())
					if (Check_If_Smaller_Register_Is_In_Use(s) != nullptr)
						if (Check_If_Smaller_Register_Is_In_Use(s)->Last_Usage_Index > i)
							goto Wrong;
				if (r.second->Holder != nullptr)
					if (Check_If_Larger_Register_Is_In_Use(r.second->Holder) != nullptr)
						if (Check_If_Larger_Register_Is_In_Use(r.second->Holder)->Last_Usage_Index > i)
							goto Wrong;
				if (r.second->Get_Size() == t->Get_Size()) {
					r.first = new Descriptor(i, p->Last_Usage, t->Get_Name(), t->Get_Parent());
					return r.second;
				}
			}
		}
		//									no need because the arguments are now reversed!
		//								   <= is wrong because the old user doesnt find the register it belong into.
		else if (r.first->Last_Usage_Index <= i && r.second->is(Reg_Type) && r.second->Get_Size() == t->Get_Size()) {
			for (auto s : *r.second->Get_Childs())
				if (Check_If_Smaller_Register_Is_In_Use(s) != nullptr)
					if (Check_If_Smaller_Register_Is_In_Use(s)->Last_Usage_Index > i)
						goto Wrong;
			if (r.second->Holder != nullptr)
				if (Check_If_Larger_Register_Is_In_Use(r.second->Holder) != nullptr)
					if (Check_If_Larger_Register_Is_In_Use(r.second->Holder)->Last_Usage_Index > i)
						goto Wrong;
			r.first->Last_Usage_Index = p->Last_Usage;
			r.first->User = t->Get_Name();
			return r.second;
		}
		else if (Single_Register_Type && r.second->is(Reg_Type) && r.second->Get_Size() == t->Get_Size()) {
			Make_Solution_For_Crossed_Register_Usages({ r.first, r.second }, { new Descriptor(i, p->Last_Usage, t->Get_Name(), t->Get_Parent()), t }, source, i);
			return r.second;
		}
		//still... checking names is wrong
		else if (r.first->User == t->Get_Name()) {
			return r.second;
		}
	Wrong:;
	}
	//if the code gets here, then return nullptr to indicate that we need to release some registers
	return nullptr;
}

Token* Selector::Get_Right_Parameter_Register(Token* t, int parameter_index)
{
	int Offset = 0;
	if (t->is(TOKEN::DECIMAL))
		for (auto i : Parameter_Registers) {
			if (i[0]->is(TOKEN::DECIMAL))
				break;
			Offset++;
		}

	if (sys->Info.OS == "win") {
		int Location = (size_t)Offset + parameter_index;
		if (t->is(TOKEN::DECIMAL) && !Previus_Parameter_Type_Decimal)
			Location += Current_Parameter_Register_Index;
		else if (!t->is(TOKEN::DECIMAL) && Previus_Parameter_Type_Decimal)
			Location += Current_Parameter_Register_Index;

		for (auto& k : Parameter_Registers[Location])
			if (k->Get_Size() == t->Get_Size()) {
				Current_Parameter_Register_Index++;
				if (t->is(TOKEN::DECIMAL))
					Previus_Parameter_Type_Decimal = true;
				else
					Previus_Parameter_Type_Decimal = false;
				return k;
			}
	}
	else if (sys->Info.OS == "unix") {
		for (auto& k : Parameter_Registers[(size_t)Offset + parameter_index])
			if (k->Get_Size() == t->Get_Size()) {
				return k;
			}
	}
	throw::runtime_error("ERROR!");
}

void Selector::Reset_Parameter_Register_Count(IR* r)
{
	if (!r->OPCODE->is(TOKEN::CALL))
		return;
	
	Current_Parameter_Register_Index = 0;
}

Token* Selector::Get_Register(Token* t)
{
	for (auto& i : Registers)
		if ((i.first != nullptr) && i.first->User == t->Get_Name())
			if (i.second->Get_Size() == t->Get_Size())
				return i.second;

	for (auto& i : Registers)
		if ((i.first != nullptr) && i.first->User == t->Get_Name()) {
			if (i.second->Get_Size() == t->Get_Size())
				return i.second;
			else if (i.second->Get_Size() < t->Get_Size()) {
				Token* Larger_Register = Get_Larger_Register(i.second, t);
				for (auto& j : Registers)
					if (Larger_Register->Get_Name() == j.second->Get_Name()) {
						j.first = new Descriptor(*i.first);
						return j.second;
					}
			}
			else {
				Token* Smaller_Register = Get_Smaller_Register(i.second, t);
				for (auto& j : Registers)
					if (Smaller_Register->Get_Name() == j.second->Get_Name()) {
						j.first = new Descriptor(*i.first);
						return j.second;
					}
			}
		}
	return nullptr;	//need to use Get_New_Reg();
}

Token* Selector::Get_Register(long F, Descriptor* user, int i, Token* t)
{
	bool Single_Register_Type = F == TOKEN::RETURNING || F == TOKEN::REMAINDER || F == TOKEN::QUOTIENT || F == TOKEN::STACK_POINTTER;

	for (auto& r : Registers) {
		if (!r.second->is(F))
			continue;
		if (r.second->Get_Size() != t->Get_Size())
			continue;
		if (r.first == nullptr) {
			for (auto s : *r.second->Get_Childs())
				if (Check_If_Smaller_Register_Is_In_Use(s) != nullptr)
					if (Check_If_Smaller_Register_Is_In_Use(s)->Last_Usage_Index > i && !Single_Register_Type)
						goto Wrong;
			if (r.second->Holder != nullptr)
				if (Check_If_Larger_Register_Is_In_Use(r.second->Holder) != nullptr)
					if (Check_If_Larger_Register_Is_In_Use(r.second->Holder)->Last_Usage_Index > i && !Single_Register_Type)
						goto Wrong;
			r.first = user;
			return r.second;
		}
		else if (r.first->Last_Usage_Index <= i + Single_Register_Type) {
			for (auto s : *r.second->Get_Childs())
				if (Check_If_Smaller_Register_Is_In_Use(s) != nullptr)
					if (Check_If_Smaller_Register_Is_In_Use(s)->Last_Usage_Index > i && !Single_Register_Type)
						goto Wrong;
			if (r.second->Holder != nullptr)
				if (Check_If_Larger_Register_Is_In_Use(r.second->Holder) != nullptr)
					if (Check_If_Larger_Register_Is_In_Use(r.second->Holder)->Last_Usage_Index > i && !Single_Register_Type)
						goto Wrong;
			r.first = user;
			return r.second;
		}
		//still... checking names is wrong
		else if (r.first->User == t->Get_Name()) {
			return r.second;
		}
	Wrong:;
	}
	//if this gets here, all non & non-non-volatile register are used already.
	//use stack
	return nullptr;
}

int Selector::Get_Largest_Register_Size()
{
	int Result = 0;
	for (auto i : Registers)
		if (i.second->Get_Size() > Result)
			Result = i.second->Get_Size();
	return Result;
}

Descriptor* Selector::Check_If_Smaller_Register_Is_In_Use(Token* r)
{
	for (auto i : Registers) {
		if (i.second->Get_Name() == r->Get_Name()) {
			if (i.first != nullptr)
				return i.first;
			for (auto j : i.second->Childs) {
				if (Check_If_Smaller_Register_Is_In_Use(j) != nullptr)
					return Check_If_Smaller_Register_Is_In_Use(j);
			}
			return nullptr;
		}
	}
	throw::runtime_error("INTERNAL ERROR!");
}

Descriptor* Selector::Check_If_Larger_Register_Is_In_Use(Token* r)
{
	for (auto i : Registers) {
		//if (i.second->Get_Name() == r->Get_Name()) {
		if (i.second == r){
			if (i.first != nullptr)
				return i.first;
			if (r->Holder == nullptr)
				return nullptr;
			return Check_If_Larger_Register_Is_In_Use(r->Holder);
		}
	}
	throw::runtime_error("INTERNAL ERROR!");
}

void Selector::Allocate_Register(vector<IR*>* source, int i, Token* t)
{
	//move some register into a non-volatile register
	//if all the non-volatile registers are already occupied then use stack
	//we have Save/Load commads for them (:
	Path* p = Get_Path_Info(*source, i, t);
	for (auto& r : Registers) {
		if (!r.second->is(TOKEN::NONVOLATILE))
			continue;
		if (r.second->Get_Size() != t->Get_Size())
			continue;
		
		//get the register owner
		pair<Descriptor*, Token*>* Previus_User = Get_Register_User(Get_Largest_Register(r.second));
		
		if (Previus_User == nullptr)
			Report(Observation(ERROR, "INTERNAL PROBLEM HAS OCCURED!!", Position()));

		bool Used_Previus_Stack_Space = false;

		long long Memory_Type = 0;
		if (t->is(TOKEN::DECIMAL))
			Memory_Type = TOKEN::DECIMAL;

		Token* Memory_Location;

		//check if there is some free space already allocated from previus allocations.
		for (auto &j : Stack) {
			if (j.second->is(TOKEN::REGISTER_SAVE_SPACE) && j.first->Last_Usage_Index < i && j.second->Get_Size() == Previus_User->second->Get_Size()) {
				*j.first = *Previus_User->first;

				j.second->Set_Name(Previus_User->first->User);
				j.second->Childs.back()->Set_Name(Previus_User->first->User);
				j.second->Childs.back()->Set_Parent(t->Get_Parent());

				j.second->Set_Flags(TOKEN::MEMORY | Memory_Type);

				j.second->Set_Parent(Previus_User->first->Scope);

				Previus_User->first = nullptr;
				Used_Previus_Stack_Space = true;

				Memory_Location = j.second;
			}
		}

		if (!Used_Previus_Stack_Space) {
			//we need to allocate some space for this NONVOLATILE previus owner.
			Stack.push_back({ Previus_User->first, new Token(TOKEN::MEMORY | Memory_Type, { new Token(TOKEN::CONTENT | TOKEN::REGISTER_SAVE_SPACE, t->Get_Name(), t->Get_Size())}, t->Get_Size(), t->Get_Name()) });


			Stack.back().second->Childs.back()->Set_Parent(t->Get_Parent());

			Previus_User->first = nullptr;

			Memory_Location = Stack.back().second;
		}

		Token* New_Reg = new Token(*Previus_User->second);
		New_Reg->ID = Previus_User->second->Get_Name();
		New_Reg->Set_Flags(New_Reg->Get_Flags() | TOKEN::ALREADY_GIVEN_REGISTER_NAME);
		//make a move operator here:
		source->insert(source->begin() + i, new IR(new Token(TOKEN::OPERATOR, "="), {Memory_Location, New_Reg}, new Position()));

		//now pair up the freed up register with the new user
		r.first = new Descriptor(i, p->Last_Usage, t->Get_Name(), t->Get_Parent());

		return;

	}
	cout << "allocation needed!" << endl;
	throw::runtime_error("INTERNAL ERROR!");
}

void Selector::Pair_Up(Token* r, Descriptor* t)
{
	for (auto& i : Registers)
		if (i.second->Get_Name() == r->Get_Name() || i.second->Get_Name() == r->ID) {
			i.first = t;
			return;
		}
}

void Selector::Break_Up(Token* r)
{
	for (auto& i : Registers)
		if (i.second->Get_Name() == r->Get_Name() || i.second->Get_Name() == r->ID) {
			i.first = nullptr;
			return;
		}
}

int Selector::Get_Numerical_Parameter_Register_Count(vector<Node*> Parameters)
{
	if(sys->Info.OS == "win") {
		//first get the amount of all non decimal registers
		int Non_Decimal_Register_Count = 0;
		for (auto i : Parameter_Registers) {
			if (!i[0]->is(TOKEN::DECIMAL))
				Non_Decimal_Register_Count++;
		}
		//then get the amount of all decimal registers
		int Decimal_Register_Count = 0;
		for (auto i : Parameter_Registers) {
			if (i[0]->is(TOKEN::DECIMAL))
				Decimal_Register_Count++;
		}
		//then count the number of decimal parameters used in the Parameters list
		int Parameter_Decimal_Register_Count = 0;
		for (auto i : Parameters) {
			if (i->is(TOKEN::DECIMAL))
				Parameter_Decimal_Register_Count++;
		}
		//now that we have the amount of possible decimal register count and the used amount of them we can
		//calculate the substraction of the used decimal registers from non decimal registers, bear with me.
		return Non_Decimal_Register_Count - (Decimal_Register_Count - (Decimal_Register_Count - Parameter_Decimal_Register_Count));
	}
	else {
		int Non_Decimal_Register_Count = 0;
		for (auto i : Parameter_Registers) {
			if (!i[0]->is(TOKEN::DECIMAL))
				Non_Decimal_Register_Count++;
		}
		return Non_Decimal_Register_Count;
	}
}

int Selector::Get_Floating_Parameter_Register_Count(vector<Node*> Parameters)
{
	if (sys->Info.OS == "win") {
		//first get the amount of all non decimal registers
		int Non_Decimal_Register_Count = 0;
		for (auto i : Parameter_Registers) {
			if (!i[0]->is(TOKEN::DECIMAL))
				Non_Decimal_Register_Count++;
		}
		//then get the amount of all decimal registers
		int Decimal_Register_Count = 0;
		for (auto i : Parameter_Registers) {
			if (i[0]->is(TOKEN::DECIMAL))
				Decimal_Register_Count++;
		}
		//then count the number of non decimal parameters used in the Parameters list
		int Parameter_Non_Decimal_Register_Count = 0;
		for (auto i : Parameters) {
			if (!i->is(TOKEN::DECIMAL))
				Parameter_Non_Decimal_Register_Count++;
		}
		//now that we have the amount of possible non decimal register count and the used amount of them, we can
		//calculate the substraction of the used non decimal registers from decimal registers, bear with me.
		return Decimal_Register_Count - (Non_Decimal_Register_Count - (Non_Decimal_Register_Count - Parameter_Non_Decimal_Register_Count));
	}
	else {
		int Decimal_Register_Count = 0;
		for (auto i : Parameter_Registers) {
			if (i[0]->is(TOKEN::DECIMAL))
				Decimal_Register_Count++;
		}
		return Decimal_Register_Count;
	}
}

void Selector::Clean_Register_Holders()
{
	for (auto& r : Registers) {
		r.first = nullptr;
	}
}

vector<pair<Descriptor*, Token*>> Selector::Get_Register_Type(long f)
{
	vector<pair<Descriptor*, Token*>> Result;
	for (auto& i : Registers) {
		if (i.second->is(f))
			Result.push_back(i);
	}
	return Result;
}

Token* Selector::Get_Larger_Register(Token* Reg, Token* token)
{
	if (Reg->Get_Size() == token->Get_Size())
		return Reg;

	if (Reg->Holder)
		return Get_Larger_Register(Reg->Holder, token);

	return nullptr;
}

Token* Selector::Get_Smaller_Register(Token* Reg, Token* token)
{
	if (Reg->Get_Size() == token->Get_Size())
		return Reg;

	for (auto i : Reg->Childs) {
		if (Get_Smaller_Register(i, token))
			return Get_Smaller_Register(i, token);
	}

	return nullptr;
}

Token* Selector::Get_Largest_Register(Token* Reg)
{
	if (Reg->Holder)
		return Get_Largest_Register(Reg->Holder);

	return Reg;
}

void Selector::DeAllocate_Stack(int Amount, vector<IR*>* list, int i)
{
	//add rsp, 123 * 16
	//if used call in scope use stack.size() % 16 = 0;
	list->insert(list->begin() + i, new IR(new Token(TOKEN::OPERATOR, "+"), { new Token(TOKEN::STACK_POINTTER | TOKEN::REGISTER, ".STACK",  _SYSTEM_BIT_SIZE_), new Token(TOKEN::NUM | TOKEN::STACK_ALLOCATION_CONSTANT, to_string(Amount), _SYSTEM_BIT_SIZE_) }, nullptr));
}

void Selector::Allocate_Stack(int Amount, vector<IR*>* list, int i)
{
	//sub rsp, 123 * 16
	//if used call in scope use stack.size() % 16 = 0;
	list->insert(list->begin() + i, new IR(new Token(TOKEN::OPERATOR, "-"), { new Token(TOKEN::STACK_POINTTER | TOKEN::REGISTER, ".STACK", _SYSTEM_BIT_SIZE_), new Token(TOKEN::NUM | TOKEN::STACK_ALLOCATION_CONSTANT, to_string(Amount), _SYSTEM_BIT_SIZE_) }, nullptr));
}

void Selector::Init_Stack(Node* Func)
{
	for (auto i : Func->Defined){
		if (!i->Requires_Address /* && !sys->Info.Debug --> no need the memory needing variables are already need_address = true*/ )
			continue;
		long long Memory_Type = 0;
		if (i->Is_Decimal())
			Memory_Type = TOKEN::DECIMAL;

		Stack.push_back({ nullptr, new Token(TOKEN::MEMORY | Memory_Type | TOKEN::LOCAL_VARIABLE_SCOPE, { new Token(TOKEN::CONTENT, i->Name, i->Size, i->Scope)}, i->Size, i->Name, i->Scope)});
	}

	Stack.push_back({ nullptr, new Token(TOKEN::MEMORY | TOKEN::CALL_PARAMETER_SPACE, { new Token(TOKEN::CONTENT, ".CALL_PARAMETER_SPACE", Func->Size_of_Call_Space)}, Func->Size_of_Call_Space, ".CALL_PARAMETER_SPACE")});

	
}

Token* Selector::Get_Memory_Location(Token* v)
{
	for (auto i : Stack) {
		if (i.second->Get_Name() == v->Get_Name()) {
			return new Token(*i.second);
		}
	}
	return nullptr;
}

void Selector::Clean_Stack()
{
	Stack.clear();
}

long long Selector::Calculate_Memory_Address(Token* m)
{
	long long Result = 0;

	for (auto i : { TOKEN::CALL_PARAMETER_SPACE, TOKEN::REGISTER_SAVE_SPACE, TOKEN::LOCAL_VARIABLE_SCOPE, TOKEN::PUSH_SPACE,  TOKEN::PARAMETER_SPACE})
		for (auto j : Stack) {
			//this may need flag checkings
			if (j.second->Get_Name() == m->Get_Name() && m->is(i))
				return Result;
			if (j.second->is(i)) {
				Result += j.second->Get_Size();
			}
		}

	Report(Observation(ERROR, "INTERNAL ERROR WHILE TRYING TO FIND FROM STACK!!!", Position()));
}

long long Selector::Calculate_Memory_Address(long long F)
{
	long long Result = 0;

	for (auto i : { TOKEN::CALL_PARAMETER_SPACE, TOKEN::REGISTER_SAVE_SPACE, TOKEN::LOCAL_VARIABLE_SCOPE, TOKEN::PUSH_SPACE,  TOKEN::PARAMETER_SPACE }) {
		if ((F & i) == i)
			return Result;
		for (auto j : Stack) {
			if (j.second->is(i)) {
				Result += j.second->Get_Size();
			}
		}
	}

	Report(Observation(ERROR, "INTERNAL ERROR WHILE TRYING TO FIND FROM STACK!!!", Position()));

}

IR* Selector::Get_Opcode(IR* i)
{
	vector<int> sizes;
	//this gives the selector information about the sizes of these arguments
	for (auto s : i->Arguments)
		sizes.push_back(s->Get_Size());

	for (auto opc : Opcodes) {
		if (opc->ID != i->OPCODE->Get_Name())
			continue;
		for (auto o : opc->Order) {
			//check if this order has same amount of arguments as i.
			if (o.size() != sizes.size())
				continue;	//this is wrong order
			for (int j = 0; j < sizes.size(); j++) {
				if (!(o[j].second.first <= sizes[j] && o[j].second.second >= sizes[j]))
					goto Wrong;
			}
			//if (!Check_Resource_Availability(i, o))
			//	goto Wrong;
			for (int j = 0; j < sizes.size(); j++) {
				if (!o[j].first->is(i->Arguments[j]->Get_Flags()))
					goto Wrong;
			}
			return opc;
		Wrong:;
		}
		if (opc->Order.size() < 1) {
			if (sizes.size() == 0)
				return opc;
		}
	}
	string args = "(";
	for (auto j : i->Arguments)
		args += j->Get_Name() + "[" + to_string(j->Get_Size()) + "]" + ", ";
	args += ")";
	Report(Observation(ERROR, "No suitable OPCODE found for " + i->OPCODE->Get_Name() + args, Position()));
	throw std::runtime_error("Error");
	return nullptr;
}

bool Selector::Check_Resource_Availability(IR* opc, vector<pair<Token*, pair<int, int>>> Order)
{
	int Register_Usage = 0;
	int Const_Usage = 0;
	int Scaler_Usage = 0;
	for (auto& i : opc->Arguments) {

	}
	return false;
}

string Selector::Get_Size_Identifier(int s)
{
	for (auto i : Size_Identifiers) {
		if (i->Get_Size() == s)
			return i->Get_Name();
	}
	Report(Observation(ERROR, "Size identifier for size of '" + to_string(s) + "' wasnt found!", Position()));
	throw::runtime_error("Error!");
}

pair<long long, long long> Selector::Compute_Function_Territory(vector<IR*> Irs, long long i)
{
	pair<long long, long long> Result;
	for (long long Current_Location = i; Current_Location > 0; Current_Location--)
		if (Irs[Current_Location]->is(TOKEN::START_OF_FUNCTION)) {
			Result.first = Current_Location;
			break;
		}

	for (long long Current_Location = i; Current_Location < Irs.size(); Current_Location++)
		if (Irs[Current_Location]->is(TOKEN::END_OF_FUNCTION)) {
			Result.second = Current_Location;
			break;
		}

	return Result;
}

vector<Token*> Selector::Get_Stack_Deallocators_And_Allocators(pair<long long, long long> Function_Territory, vector<IR*> Irs)
{
	vector<Token*> Result;

	for (int i = Function_Territory.first; i < Function_Territory.second; i++) {
		for (auto j : Irs[i]->Arguments)
			for (auto k : j->Get_All(TOKEN::STACK_ALLOCATION_CONSTANT)) {
				Result.push_back(k);
			}
	}

	return Result;
}

pair<Descriptor*, Token*>* Selector::Get_Register_User(Token* R)
{
	for (auto &i : Registers) {
		if (i.second == R) {
			if (i.first)
				return &i;
			for (auto j : R->Childs) {
				if (Get_Register_User(j))
					return Get_Register_User(j);
			}
			return nullptr;
		}
	}
}


C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Cpp\BackEnd\x86.cpp" 
#include "../../H/BackEnd/x86.h"
#include "../../H/UI/Usr.h"

extern Usr* sys;

void x86_64::Init()
{
	size = 8;	//64 bit arch

	long long OS_DEPENDENT_FLAG = TOKEN::NONVOLATILE;

	if (sys->Info.OS == "unix")
		OS_DEPENDENT_FLAG = TOKEN::VOLATILE;

	Seperator = ",";
	Register_Pre_Fix = "";
	Number_Pre_Fix = "";
	Label_Post_Fix = ":";

	Token* AL = new Token(TOKEN::RETURNING | TOKEN::QUOTIENT, "al", 1, {});
	Token* AH = new Token(TOKEN::RETURNING, "ah", 1, {});
	Token* AX = new Token(TOKEN::RETURNING | TOKEN::QUOTIENT, "ax", 2, { AH, AL });
	Token* EAX = new Token(TOKEN::RETURNING | TOKEN::QUOTIENT, "eax", 4, { AX });
	Token* RAX = new Token(TOKEN::RETURNING | TOKEN::QUOTIENT, "rax", 8, { EAX });

	Token* BL = new Token(TOKEN::NONVOLATILE, "bl", 1, {});
	Token* BH = new Token(TOKEN::NONVOLATILE, "bh", 1, {});
	Token* BX = new Token(TOKEN::NONVOLATILE, "bx", 2, { BH, BL });
	Token* EBX = new Token(TOKEN::NONVOLATILE, "ebx", 4, { BX });
	Token* RBX = new Token(TOKEN::NONVOLATILE, "rbx", 8, { EBX });

	Token* CL = new Token(TOKEN::VOLATILE | TOKEN::PARAMETER, "cl", 1, {});
	Token* CH = new Token(TOKEN::VOLATILE | TOKEN::PARAMETER, "ch", 1, {});
	Token* CX = new Token(TOKEN::VOLATILE | TOKEN::PARAMETER, "cx", 2, { CH, CL });
	Token* ECX = new Token(TOKEN::VOLATILE | TOKEN::PARAMETER, "ecx", 4, { CX });
	Token* RCX = new Token(TOKEN::VOLATILE | TOKEN::PARAMETER, "rcx", 8, { ECX});

	Token* DL = new Token( TOKEN::PARAMETER, "dl", 1, {});
	Token* DH = new Token( TOKEN::PARAMETER, "dh", 1, {});
	Token* DX = new Token( TOKEN::PARAMETER  | TOKEN::REMAINDER, "dx", 2, { DH, DL });
	Token* EDX = new Token( TOKEN::PARAMETER | TOKEN::REMAINDER, "edx", 4, { DX });
	Token* RDX = new Token( TOKEN::PARAMETER | TOKEN::REMAINDER, "rdx", 8, { EDX });

	Token* DIL = new Token(OS_DEPENDENT_FLAG, "dil", 1, {});
	//Token* DIH = new Token(TOKEN::NONVOLATILE, "dih", 1, {});
	Token* DI = new Token(OS_DEPENDENT_FLAG, "di", 2, {DIL });
	Token* EDI = new Token(OS_DEPENDENT_FLAG, "edi", 4, { DI });
	Token* RDI = new Token(OS_DEPENDENT_FLAG, "rdi", 8, { EDI });

	Token* SIL = new Token(OS_DEPENDENT_FLAG, "sil", 1, {});
	//Token* SIH = new Token(TOKEN::NONVOLATILE, "sih", 1, {});
	Token* SI = new Token(OS_DEPENDENT_FLAG, "si", 2, {SIL });
	Token* ESI = new Token(OS_DEPENDENT_FLAG, "esi", 4, { SI });
	Token* RSI = new Token(OS_DEPENDENT_FLAG, "rsi", 8, { ESI });


	Token* BPL = new Token(TOKEN::NONVOLATILE, "bpl", 1, {});
	Token* BP = new Token(TOKEN::NONVOLATILE, "bp", 2, { BPL });
	Token* EBP = new Token(TOKEN::NONVOLATILE, "ebp", 4, { BP });
	Token* RBP = new Token(TOKEN::NONVOLATILE, "rbp", 8, { EBP });

	Token* SPL = new Token(TOKEN::STACK_POINTTER, "spl", 1, {});
	Token* SP = new Token(TOKEN::STACK_POINTTER, "sp", 2, { SPL });
	Token* ESP = new Token(TOKEN::STACK_POINTTER, "esp", 4, { SP });
	Token* RSP = new Token(TOKEN::STACK_POINTTER, "rsp", 8, { ESP });

	Token* IPL = new Token(TOKEN::POSITION_INDEPENDENT_REGISTER, "ipl", 1, {});
	Token* IP = new Token(TOKEN::POSITION_INDEPENDENT_REGISTER, "ip", 2, {IPL});
	Token* EIP = new Token(TOKEN::POSITION_INDEPENDENT_REGISTER, "eip", 4, { IP });
	Token* RIP = new Token(TOKEN::POSITION_INDEPENDENT_REGISTER, "rip", 8, { EIP });

	Token* XMM0D = new Token(TOKEN::VOLATILE | TOKEN::PARAMETER | TOKEN::RETURNING | TOKEN::DECIMAL, "xmm0", 4, {});
	Token* XMM1D = new Token(TOKEN::VOLATILE | TOKEN::PARAMETER | TOKEN::DECIMAL, "xmm1", 4, {});
	Token* XMM2D = new Token(TOKEN::VOLATILE | TOKEN::PARAMETER | TOKEN::DECIMAL, "xmm2", 4, {});
	Token* XMM3D = new Token(TOKEN::VOLATILE | TOKEN::PARAMETER | TOKEN::DECIMAL, "xmm3", 4, {});
	Token* XMM4D = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "xmm4", 4, {});
	Token* XMM5D = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "xmm5", 4, {});
	Token* XMM6D = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "xmm6", 4, {});
	Token* XMM7D = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "xmm7", 4, {});
	Token* XMM8D = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "xmm8", 4, {});
	Token* XMM9D = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "xmm9", 4, {});
	Token* XMM10D = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "xm10", 4, {});
	Token* XMM11D = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "xmm11", 4, {});
	Token* XMM12D = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "xmm12", 4, {});
	Token* XMM13D = new Token(TOKEN::NONVOLATILE | TOKEN::DECIMAL, "xmm13", 4, {});
	Token* XMM14D = new Token(TOKEN::NONVOLATILE | TOKEN::DECIMAL, "xmm14", 4, {});
	Token* XMM15D = new Token(TOKEN::NONVOLATILE | TOKEN::DECIMAL, "xmm15", 4, {});

	Token* XMM0Q = new Token(TOKEN::VOLATILE | TOKEN::PARAMETER | TOKEN::RETURNING | TOKEN::DECIMAL, "xmm0", 8, {XMM0D});
	Token* XMM1Q = new Token(TOKEN::VOLATILE | TOKEN::PARAMETER | TOKEN::DECIMAL, "xmm1", 8, {XMM1D});
	Token* XMM2Q = new Token(TOKEN::VOLATILE | TOKEN::PARAMETER | TOKEN::DECIMAL, "xmm2", 8, { XMM2D });
	Token* XMM3Q = new Token(TOKEN::VOLATILE | TOKEN::PARAMETER | TOKEN::DECIMAL, "xmm3", 8, { XMM3D });
	Token* XMM4Q = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "xmm4", 8, { XMM4D });
	Token* XMM5Q = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "xmm5", 8, { XMM5D });
	Token* XMM6Q = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "xmm6", 8, { XMM6D });
	Token* XMM7Q = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "xmm7", 8, { XMM7D });
	Token* XMM8Q = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "xmm8", 8, { XMM8D });
	Token* XMM9Q = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "xmm9", 8, { XMM9D });
	Token* XMM10Q = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "xm10", 8, { XMM10D });
	Token* XMM11Q = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "xmm11", 8, { XMM11D });
	Token* XMM12Q = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "xmm12", 8, { XMM12D });
	Token* XMM13Q = new Token(TOKEN::NONVOLATILE | TOKEN::DECIMAL, "xmm13", 8, { XMM13D });
	Token* XMM14Q = new Token(TOKEN::NONVOLATILE | TOKEN::DECIMAL, "xmm14", 8, { XMM14D });
	Token* XMM15Q = new Token(TOKEN::NONVOLATILE | TOKEN::DECIMAL, "xmm15", 8, { XMM15D });

	Token* XMM0 = new Token(TOKEN::VOLATILE | TOKEN::PARAMETER | TOKEN::RETURNING | TOKEN::DECIMAL, "xmm0", 12, { XMM0Q });
	Token* XMM1 = new Token(TOKEN::VOLATILE | TOKEN::PARAMETER | TOKEN::DECIMAL, "xmm1", 12, { XMM1Q });
	Token* XMM2 = new Token(TOKEN::VOLATILE | TOKEN::PARAMETER | TOKEN::DECIMAL, "xmm2", 12, { XMM2Q });
	Token* XMM3 = new Token(TOKEN::VOLATILE | TOKEN::PARAMETER | TOKEN::DECIMAL, "xmm3", 12, { XMM3Q });
	Token* XMM4 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "xmm4", 12, { XMM4Q });
	Token* XMM5 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "xmm5", 12, { XMM5Q });
	Token* XMM6 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "xmm6", 12, { XMM6Q });
	Token* XMM7 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "xmm7", 12, { XMM7Q });
	Token* XMM8 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "xmm8", 12, { XMM8Q });
	Token* XMM9 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "xmm9", 12, { XMM9Q });
	Token* XMM10 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "xm10", 12, { XMM10Q });
	Token* XMM11 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "xmm11", 12, { XMM11Q });
	Token* XMM12 = new Token(TOKEN::VOLATILE | TOKEN::DECIMAL, "xmm12", 12, { XMM12Q });
	Token* XMM13 = new Token(TOKEN::NONVOLATILE | TOKEN::DECIMAL, "xmm13", 12, { XMM13Q });
	Token* XMM14 = new Token(TOKEN::NONVOLATILE | TOKEN::DECIMAL, "xmm14", 12, { XMM14Q });
	Token* XMM15 = new Token(TOKEN::NONVOLATILE | TOKEN::DECIMAL, "xmm15", 12, { XMM15Q });

	Token* R8B = new Token(TOKEN::VOLATILE | TOKEN::PARAMETER, "r8b", 1, {});
	Token* R8W = new Token(TOKEN::VOLATILE | TOKEN::PARAMETER, "r8w", 2, { R8B });
	Token* R8D = new Token(TOKEN::VOLATILE | TOKEN::PARAMETER, "r8d", 4, { R8W });
	Token* R8 = new Token(TOKEN::VOLATILE | TOKEN::PARAMETER, "r8", 8, { R8D });

	Token* R9B = new Token(TOKEN::VOLATILE | TOKEN::PARAMETER, "r9b", 1, {});
	Token* R9W = new Token(TOKEN::VOLATILE | TOKEN::PARAMETER, "r9w", 2, { R9B });
	Token* R9D = new Token(TOKEN::VOLATILE | TOKEN::PARAMETER, "r9d", 4, { R9W });
	Token* R9 = new Token(TOKEN::VOLATILE | TOKEN::PARAMETER, "r9", 8, { R9D });

	Token* R10B = new Token(TOKEN::VOLATILE, "r10b", 1, {});
	Token* R10W = new Token(TOKEN::VOLATILE, "r10w", 2, { R10B });
	Token* R10D = new Token(TOKEN::VOLATILE, "r10d", 4, { R10W });
	Token* R10 = new Token(TOKEN::VOLATILE , "r10", 8, { R10D });

	Token* R11B = new Token(TOKEN::VOLATILE, "r11b", 1, {});
	Token* R11W = new Token(TOKEN::VOLATILE, "r11w", 2, { R11B });
	Token* R11D = new Token(TOKEN::VOLATILE, "r11d", 4, { R11W });
	Token* R11 = new Token(TOKEN::VOLATILE , "r11", 8, { R11D });

	Token* R12B = new Token(TOKEN::NONVOLATILE, "r12b", 1, {});
	Token* R12W = new Token(TOKEN::NONVOLATILE, "r12w", 2, { R12B });
	Token* R12D = new Token(TOKEN::NONVOLATILE, "r12d", 4, { R12W });
	Token* R12 = new Token(TOKEN::NONVOLATILE , "r12", 8, { R12D });

	Token* R13B = new Token(TOKEN::NONVOLATILE, "r13b", 1, {});
	Token* R13W = new Token(TOKEN::NONVOLATILE, "r13w", 2, { R13B });
	Token* R13D = new Token(TOKEN::NONVOLATILE, "r13d", 4, { R13W });
	Token* R13 = new Token(TOKEN::NONVOLATILE , "r13", 8, { R13D });

	Token* R14B = new Token(TOKEN::NONVOLATILE, "r14b", 1, {});
	Token* R14W = new Token(TOKEN::NONVOLATILE, "r14w", 2, { R14B });
	Token* R14D = new Token(TOKEN::NONVOLATILE, "r14d", 4, { R14W });
	Token* R14 = new Token(TOKEN::NONVOLATILE , "r14", 8, { R14D });

	Token* R15B = new Token(TOKEN::NONVOLATILE, "r15b", 1, {});
	Token* R15W = new Token(TOKEN::NONVOLATILE, "r15w", 2, { R15B });
	Token* R15D = new Token(TOKEN::NONVOLATILE, "r15d", 4, { R15W });
	Token* R15 = new Token(TOKEN::NONVOLATILE , "r15", 8, { R15D });

	if (sys->Info.OS == "win")
		Parameter_Registers = { RCX, RDX, R8, R9, XMM0, XMM1, XMM2, XMM3 };
	else
		Parameter_Registers = { RDI, RSI, RDX, RCX, R8, R9, XMM0, XMM1, XMM2, XMM3, XMM4, XMM5, XMM6 };
	Registers = { 
		RAX, EAX, AX, AH, AL,
		RBX, EBX, BX, BH, BL,
		RCX, ECX, CX, CH, CL,
		RDX, EDX, DX, DH, DL,
		RDI, EDI, DI, DIL,
		RSI, ESI, SI, SIL,
		RBP, EBP, BP, BPL,
		RSP, ESP, SP, SPL,
		RIP, EIP, IP, IPL,
		XMM0D, XMM1D, XMM2D, XMM3D, XMM4D, XMM5D, XMM6D, XMM7D, XMM8D, XMM9D, XMM10D, XMM11D, XMM12D, XMM13D, XMM14D, XMM15D,
		XMM0Q, XMM1Q, XMM2Q, XMM3Q, XMM4Q, XMM5Q, XMM6Q, XMM7Q, XMM8Q, XMM9Q, XMM10Q, XMM11Q, XMM12Q, XMM13Q, XMM14Q, XMM15Q,
		XMM0, XMM1, XMM2, XMM3, XMM4, XMM5, XMM6, XMM7, XMM8, XMM9, XMM10, XMM11, XMM12, XMM13, XMM14, XMM15,
		R8, R8B, R8D, R8W,
		R9, R9B, R9D, R9W,
		R10, R10B, R10D, R10W,
		R11, R11B, R11D, R11W,
		R12, R12B, R12D, R12W,
		R13, R13B, R13D, R13W,
		R14, R14B, R14D, R14W,
		R15, R15B, R15D, R15W,
	};
	using namespace TOKEN;
	Token* Register = new Token(REGISTER | NONVOLATILE | VOLATILE | RETURNING | QUOTIENT | REMAINDER | PARAMETER | STACK_POINTTER);
	Token* Register_Float = new Token(REGISTER | NONVOLATILE | VOLATILE | RETURNING | DECIMAL | PARAMETER);
	Token* Scalar = new Token(NUM, {
		new Token(NUM, "1"),
		new Token(NUM, "2"),
		new Token(NUM, "4"),
		new Token(NUM, "8")
		}, "scaler");
	Token* Const = new Token(NUM | STACK_ALLOCATION_CONSTANT, "const");
	Token* Decimal = new Token(DECIMAL | NUM, "const");

	long long Additional_Memory_Info = CALL_PARAMETER_SPACE | PARAMETER_SPACE | PUSH_SPACE | REGISTER_SAVE_SPACE | LOCAL_VARIABLE_SCOPE;

	Token* Memory = new Token(MEMORY | Additional_Memory_Info, {
			{ new Token(REGISTER), 2},
			{ new Token(SCALER | ALL_ARGS_SAME_SIZE, {
				{{Register, {1, 8}}, {Scalar, {1, 8}}},
				{{Scalar, {1, 8}}, {Register, {1, 8}}},
				{{Scalar, {1, 8}}, {Scalar, {1, 8}}}
				}), 1},
			{ new Token(OFFSETTER | ALL_ARGS_SAME_SIZE, {
				{{Register, {1, 8}}, {Register, {1, 8}}},
				{{Register, {1, 8}}, {Const, {1, 8}}},
				{{Const, {1, 8}}, {Register, {1, 8}}},
				{{Const, {1, 8}}, {Const, {1, 8}}},
				}), INT32_MAX},
			{ new Token(DEOFFSETTER | ALL_ARGS_SAME_SIZE, {
				{{Register, {1, 8}}, {Register, {1, 8}}},
				{{Register, {1, 8}}, {Const, {1, 8}}},
				{{Const, {1, 8}}, {Register, {1, 8}}},
				{{Const, {1, 8}}, {Const, {1, 8}}},
				}), INT32_MAX}
		}, "memory");
	Token* Memory_Float = new Token(MEMORY | DECIMAL | Additional_Memory_Info, {
			{ new Token(REGISTER), 2},
			{ new Token(SCALER | ALL_ARGS_SAME_SIZE, {
				{{Register, {1, 8}}, {Scalar, {1, 8}}},
				{{Scalar, {1, 8}}, {Register, {1, 8}}},
				{{Scalar, {1, 8}}, {Scalar, {1, 8}}}
				}), 1},
			{ new Token(OFFSETTER | ALL_ARGS_SAME_SIZE, {
				{{Register, {1, 8}}, {Register, {1, 8}}},
				{{Register, {1, 8}}, {Const, {1, 8}}},
				{{Const, {1, 8}}, {Register, {1, 8}}},
				{{Const, {1, 8}}, {Const, {1, 8}}},
				}), INT32_MAX},
			{ new Token(DEOFFSETTER | ALL_ARGS_SAME_SIZE, {
				{{Register, {1, 8}}, {Register, {1, 8}}},
				{{Register, {1, 8}}, {Const, {1, 8}}},
				{{Const, {1, 8}}, {Register, {1, 8}}},
				{{Const, {1, 8}}, {Const, {1, 8}}},
				}), INT32_MAX}
		}, "memory");
	Token* Label = new Token(LABEL | GLOBAL_VARIABLE, "label");
	Token* Data = new Token(NUM | STRING | LABEL);

	Utility = {
		Register,
		Scalar,
		Const,
		Memory,
		Label,
		Data
	};

	Token* BYTE = new Token(SIZE_INDENTIFIER, "byte ptr", 1);
	Token* WORD = new Token(SIZE_INDENTIFIER, "word ptr", 2);
	Token* DWORD = new Token(SIZE_INDENTIFIER, "dword ptr", 4);
	Token* QWORD = new Token(SIZE_INDENTIFIER, "qword ptr", 8);

	Size_Identifiers = {
		BYTE,
		WORD,
		DWORD,
		QWORD
	};

	//2reg, 1mul, inf*const, inf*operator
	//*(reg, const) | *(const, const) | *(const, reg)
	//+-(reg, reg) | +-(reg, const) | +-(const, reg) | +-(const, const)
	
	IR* MOV = new IR("move", new Token(OPERATOR, "mov"), {
		{{Register, {1, 8}}, {Memory, {1, 8}} },
		{{Register, {1, 8}}, {Label, {1, 8}} },
		{{Memory, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Const, {1, 8}} },
		{{Memory, {1, 8}}, {Const, {1, 8}} }
		});

	IR* SET = new IR("=", new Token(OPERATOR, "mov"), {
		{{Register, {1, 8}}, {Memory, {1, 8}} },
		{{Register, {1, 8}}, {Label, {1, 8}} },
		{{Memory, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Const, {1, 8}} },
		{{Memory, {1, 8}}, {Const, {1, 8}} },

		{ {Memory_Float, {4, 4}}, {Register, {4, 4}} }
		});

	IR* XOR = new IR("ï¿½", new Token(OPERATOR, "xor"), {
		{{Register, {1, 8}}, {Memory, {1, 8}} },
		{{Register, {1, 8}}, {Label, {1, 8}} },
		{{Memory, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Const, {1, 8}} },
		{{Memory, {1, 8}}, {Const, {1, 8}} }
	});

	IR* LEA = new IR("evaluate", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "lea"), {
		{ {Register, { 1, 8 }}, { Memory, {1, 8} } }
		});

	IR* ADD = new IR("+", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "add"), {
		{{Register, {1, 8}}, {Memory, {1, 8}} },
		{{Memory, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Const, {1, 8}} },
		{{Memory, {1, 8}}, {Const, {1, 8}} }
		});

	IR* SUB = new IR("-", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "sub"), {
		{{Register, {1, 8}}, {Memory, {1, 8}} },
		{{Memory, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Const, {1, 8}} },
		{{Memory, {1, 8}}, {Const, {1, 8}} }
		});	

	IR* MUL = new IR("mul", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "mul"), {
		{{Register, {1, 8}}},
		{{Memory, {1, 8}}},
		});	

	IR* DIV = new IR("div", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "div"), {
		{{Register, {1, 8}}},
		{{Memory, {1, 8}}},
			});
	
	IR* C_MUL = new IR("*", new Token(OPERATOR), {
		//accepted arguments
		{{Register, {1, 8}}, {Memory, {1, 8}} },
		{{Memory, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Register, {1, 8}} },
		{{Const, {1, 8}}, {Register, {1, 8}} },
		{{Const, {1, 8}}, {Memory, {1, 8}} },
		{{Register, {1, 8}}, {Const, {1, 8}} },
		{{Memory, {1, 8}}, {Const, {1, 8}} },
		},
		[](vector<Token*> args) {
			vector<IR*> Result;
			Token* eax = nullptr;
			Token* mul = nullptr;
			if (args[1]->is(NUM)) {
				eax = args[1];
				mul = args[0];
			}
			else {
				eax = args[0];
				mul = args[1];
			}
			Token* quotient = new Token(QUOTIENT | REGISTER, eax->Get_Name() + "_QUOTIENT" + to_string(rand()), eax->Get_Size());
			if (mul->is(NUM)) {
				//you cant give mul a num as a arg so move it to a register.
				Token* tmp = mul;
				mul = new Token(REGISTER, mul->Get_Name() + "_REG" + to_string(rand()), mul->Get_Size());
				Result.push_back(new IR(new Token(OPERATOR, "="), { mul, tmp }, nullptr));
			}

			//save the rdx if it has some valuable value inside of it.
			//this can occur when a multiplication has been done
			Token* Save_Hold_Remainder = new Token(TOKEN::REGISTER, mul->Get_Name() + "_REMAINDER" + to_string(rand()), _SYSTEM_BIT_SIZE_);
			Token* Remainder = new Token(TOKEN::REMAINDER | TOKEN::REGISTER, "REMAINDER_" + to_string(rand()), _SYSTEM_BIT_SIZE_);

			Result.push_back(new IR(new Token(OPERATOR, "="), { Save_Hold_Remainder, Remainder }, nullptr));
			Result.push_back(new IR(new Token(OPERATOR, "="), { quotient, eax }, nullptr));
			Result.push_back(new IR(new Token(OPERATOR, "mul"), { mul }, nullptr));
			Result.push_back(new IR(new Token(OPERATOR, "="), { args[0], quotient }, nullptr));
			Result.push_back(new IR(new Token(OPERATOR, "="), { Remainder, Save_Hold_Remainder }, nullptr));
			return Result;
		}
	);

	IR* C_MOD = new IR("%", new Token(OPERATOR), {
		//accepted arguments
		{{Register, {1, 8}}, {Memory, {1, 8}} },
		{{Memory, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Register, {1, 8}} },
		{{Const, {1, 8}}, {Register, {1, 8}} },
		{{Const, {1, 8}}, {Memory, {1, 8}} },
		{{Register, {1, 8}}, {Const, {1, 8}} },
		{{Memory, {1, 8}}, {Const, {1, 8}} },
		},
		[](vector<Token*> args) {
			vector<IR*> Result;
			Token* eax = nullptr;
			Token* div = nullptr;
			if (args[1]->is(NUM)) {
				eax = args[1];
				div = args[0];
			}
			else {
				eax = args[0];
				div = args[1];
			}
			Token* quotient = new Token(QUOTIENT | REGISTER, eax->Get_Name() + "_QUOTIENT" + to_string(rand()), eax->Get_Size());
			Token* Remainder = new Token(REMAINDER | REGISTER, eax->Get_Name() + "_REMAINDER" + to_string(rand()), eax->Get_Size());
			if (div->is(NUM)) {
				//you cant give mul a num as a arg so move it to a register.
				Token* tmp = div;
				div = new Token(REGISTER, div->Get_Name() + "_REG" + to_string(rand()), div->Get_Size());
				Result.push_back(new IR(new Token(OPERATOR, "="), { div, tmp }, nullptr));
			}
			//\u00a4
			Result.push_back(new IR(new Token(OPERATOR, "ï¿½"), { Remainder, Remainder }, nullptr));
			Result.push_back(new IR(new Token(OPERATOR, "="), { quotient, eax }, nullptr));
			Result.push_back(new IR(new Token(OPERATOR, "div"), { div }, nullptr));
			Result.push_back(new IR(new Token(OPERATOR, "="), { args[0], Remainder }, nullptr));
			return Result;
		}
	);

	IR* C_DIV = new IR("/", new Token(OPERATOR), {
		//accepted arguments
		{{Register, {1, 8}}, {Memory, {1, 8}} },
		{{Memory, {1, 8}}, {Register, {1, 8}} },
		{{Register, {1, 8}}, {Register, {1, 8}} },
		{{Const, {1, 8}}, {Register, {1, 8}} },
		{{Const, {1, 8}}, {Memory, {1, 8}} },
		{{Register, {1, 8}}, {Const, {1, 8}} },
		{{Memory, {1, 8}}, {Const, {1, 8}} },
		},
		[](vector<Token*> args) {
			vector<IR*> Result;
			Token* eax = nullptr;
			Token* div = nullptr;
			if (args[1]->is(NUM)) {
				eax = args[1];
				div = args[0];
			}
			else {
				eax = args[0];
				div = args[1];
			}
			Token* quotient = new Token(QUOTIENT | REGISTER, eax->Get_Name() + "_QUOTIENT" + to_string(rand()), eax->Get_Size());
			Token* Remainder = new Token(REMAINDER | REGISTER, eax->Get_Name() + "_REMAINDER" + to_string(rand()), eax->Get_Size());
			if (div->is(NUM)) {
				//you cant give mul a num as a arg so move it to a register.
				Token* tmp = div;
				div = new Token(REGISTER, div->Get_Name() + "_REG" + to_string(rand()), div->Get_Size());
				Result.push_back(new IR(new Token(OPERATOR, "="), { div, tmp }, nullptr));
			}
			//\u00a4
			Result.push_back(new IR(new Token(OPERATOR, "ï¿½"), { Remainder, Remainder }, nullptr));
			Result.push_back(new IR(new Token(OPERATOR, "="), { quotient, eax }, nullptr));
			Result.push_back(new IR(new Token(OPERATOR, "div"), { div }, nullptr));
			Result.push_back(new IR(new Token(OPERATOR, "="), { args[0], quotient }, nullptr));
			return Result;
		}
	);

	IR* MOVQ = new IR("=", new Token(OPERATOR, "movq"), {
		{{Register_Float, {8, 12}}, {Register, {8, 8}}},
		{{Register, {8, 8}}, {Register_Float, {8, 8}}},
	});	

	IR* MOVD = new IR("=", new Token(OPERATOR, "movd"), {
		{{Register_Float, {4, 4}}, {Register, {4, 4}}},
		{{Register, {4, 4}}, {Register_Float, {4, 4}}},
	});

	IR* MOVSS = new IR("=", new Token(OPERATOR, "movss"), {
		{{Register_Float, {4, 4}}, {Register_Float, {4, 4}}},
		{{Register_Float, {4, 4}}, {Memory_Float, {4, 4}}},
		{{Memory_Float, {4, 4}}, {Register_Float, {4, 4}}},
	});

	IR* MOVSD = new IR("=", new Token(OPERATOR, "movsd"), {
		{{Register_Float, {8, 8}}, {Register_Float, {8, 8}}},
		{{Register_Float, {8, 8}}, {Memory_Float, {8, 8}}},
		{{Memory_Float, {8, 8}}, {Register_Float, {8, 8}}},
	});

	IR* CONVERTI2F = new IR("convert", new Token(OPERATOR, "cvtsi2ss"), {
		{{Register_Float, {4, 4}}, {Memory, {4, 4}}},
		{{Register_Float, {4, 4}}, {Register, {4, 4}}},
	});

	IR* CONVERTI2D = new IR("convert", new Token(OPERATOR, "cvtsi2sd"), {
		{{Register_Float, {8, 12}}, {Memory, {4, 8}}},
		{{Register_Float, {8, 12}}, {Register, {4, 8}}},
	});

	IR* CONVERTF2I = new IR("convert", new Token(OPERATOR, "cvttss2si"), {
		{{Register, {4, 8}}, {Register_Float, {4, 4}}},
		{{Register, {4, 8}}, {Memory_Float, {4, 4}}},
	});

	IR* CONVERTD2I = new IR("convert", new Token(OPERATOR, "cvttsd2si"), {
		{{Register, {4, 8}}, {Register_Float, {8, 12}}},
		{{Register, {4, 8}}, {Memory_Float, {8, 12}}},
		});

	IR* CONVERTD2F = new IR("convert", new Token(OPERATOR, "cvtsd2ss"), {
		{{Register_Float, {4, 4}}, {Register_Float, {8, 12}}},
		{{Register_Float, {4, 4}}, {Memory_Float, {8, 12}}},
		});

	IR* CONVERTF2D = new IR("convert", new Token(OPERATOR, "cvtss2sd"), {
	{{Register_Float, {8, 12}}, {Register_Float, {4, 4}}},
	{{Register_Float, {8, 12}}, {Register_Float, {4, 4}}},
	});


	IR* F_MOV = new IR("=", new Token(OPERATOR), {
		//accepted arguments
		{{Register_Float, {4, 12}}, {Memory, {4, 8}} },
		{{Memory, {4, 8}}, {Register_Float, {4, 12}} },
		{{Register_Float, {4, 12}}, {Memory_Float, {4, 8}} },
		{{Memory_Float, {4, 8}}, {Register_Float, {4, 12}} },
		{{Memory_Float, {4, 8}}, {Decimal, {4, 12}} },
		{{Register_Float, {4, 12}}, {Register_Float, {4, 12}} },
		{{Register_Float, {4, 12}}, {Const, {4, 8}} },
		{{Memory, {4, 8}}, {Const, {4, 8}} },
		{{Register_Float, {4, 12}}, {Decimal, {4, 8}} },
		{{Memory, {4, 8}}, {Decimal, {4, 8}} },
		},
		[](vector<Token*> args) {
			vector<IR*> Result;
			Token* Left = args[0];
			Token* Right = args[1];
			//transform right side into xmm0
			if (Right->is(NUM)) {
				long long Name;
				if (Right->Get_Size() == 8) {
					double tmp = atof(Right->Get_Name().c_str());
					Name = *(long long*)&tmp;
				}
				else {
					float tmp = atof(Right->Get_Name().c_str());
					Name = *(long*)&tmp;
				}
				Token* R = new Token(TOKEN::REGISTER, "REG_" + to_string(Name + rand()), Right->Get_Size());
				//mov the number into 
				Result.push_back(new IR(new Token(TOKEN::OPERATOR, "="), {
					R,
					new Token(TOKEN::NUM, to_string(Name), Right->Get_Size())
					}, nullptr));

				if (!Left->is(MEMORY)) {
					Token* R2 = new Token(TOKEN::REGISTER | TOKEN::DECIMAL, "MEDIA_" + to_string(Name + rand()), Right->Get_Size());
					Result.push_back(new IR(new Token(TOKEN::OPERATOR, "="), {
						R2, R
						}, nullptr));
					Right = R2;
				}
				else
					Right = R;
			}
			else if (Right->is(DECIMAL) && Left->is(DECIMAL) && Right->Get_Size() != Left->Get_Size()) {
				Token* R = new Token(REGISTER | DECIMAL, "MEDIA_" + Right->Get_Name() + to_string(rand()), Left->Get_Size());
				Result.push_back(new IR(new Token(OPERATOR, "convert"), { R, Right }, nullptr));
				Right = R;
			}
			else if (Right->is(MEMORY | DECIMAL)) {
				Token* R = new Token(REGISTER | DECIMAL, "REG_" + Right->Get_Name() + to_string(rand()), Right->Get_Size());
				Result.push_back(new IR(new Token(OPERATOR, "="), {
					R, Right
					}, nullptr));
				Right = R;
			}
			else if (Right->is(MEMORY)) {
				Token* R = new Token(REGISTER | DECIMAL, "MEDIA_" + Right->Get_Name() + to_string(rand()), Right->Get_Size());
				Result.push_back(new IR(new Token(OPERATOR, "convert"), {
					R, Right
					}, nullptr));
				Right = R;
			}
			else if (!Right->is(DECIMAL) && Right->is(REGISTER)) {
				Token* R = new Token(REGISTER | DECIMAL, "MEDIA_" + Right->Get_Name() + to_string(rand()), Right->Get_Size());
				string Type = "convert";
				if (Right->is(DECIMAL))
					Type = "=";
				Result.push_back(new IR(new Token(OPERATOR, Type), { R, Right }, nullptr));
				Right = R;
			}
			else
				return vector<IR*>();

			Result.push_back(new IR(new Token(OPERATOR, "="), {
				Left, Right
			}, nullptr));

			return Result;
		}
	);

	IR* F_ADD = new IR("+", new Token(OPERATOR | ALL_ARGS_SAME_SIZE), {
		//accepted arguments		
		{{Register_Float, {4, 8}}, {Memory_Float, {4, 8}} },
		{{Memory_Float, {4, 8}}, {Register_Float, {4, 8}} },
		{{Register_Float, {4, 8}}, {Register_Float, {4, 8}} },
		{{Register_Float, {4, 8}}, {Decimal, {4, 8}} },
		{{Memory_Float, {4, 8}}, {Decimal, {4, 8}} },
		{ {Decimal, {4, 8}}, {Register_Float, {4, 8}} },
		{{Decimal, {4, 8}}, {Memory_Float, {4, 8}} }
		},
		[](vector<Token*> args) {
			vector<IR*> Result;
			Token* Left = args[0];
			Token* Right = args[1];
			if (Right->is(NUM)) {
				double tmp = atof(Right->Get_Name().c_str());
				long long Name = *(long long*)&tmp;
				Token* R = new Token(TOKEN::REGISTER, "REG_" + to_string(Name + rand()), Right->Get_Size());
				//mov the number into 
				Result.push_back(new IR(new Token(TOKEN::OPERATOR, "="), {
					R,
					new Token(TOKEN::NUM, to_string(Name), Right->Get_Size())
					}, nullptr));

				Token* R2 = new Token(TOKEN::REGISTER | TOKEN::DECIMAL, "MEDIA_" + to_string(Name + rand()), Left->Get_Size());
				Result.push_back(new IR(new Token(TOKEN::OPERATOR, "="), {
					R2, R
				}, nullptr));
				Right = R2;
			}
			if (Left->is(MEMORY)) {
				Token* L = new Token(REGISTER | DECIMAL, "MEDIA_" + Left->Get_Name(), Left->Get_Size());
				Result.push_back(new IR(new Token(TOKEN::OPERATOR, "="), {
					L, Left
				}, nullptr));
				Left = L;
			}

			Result.push_back(new IR(new Token(OPERATOR, "addF"), {
				Left, Right
				}, nullptr));

			return Result;
		}
	);

	IR* F_SUB = new IR("-", new Token(OPERATOR | ALL_ARGS_SAME_SIZE), {
		//accepted arguments		
		{{Register_Float, {4, 8}}, {Memory_Float, {4, 8}} },
		{{Memory_Float, {4, 8}}, {Register_Float, {4, 8}} },
		{{Register_Float, {4, 8}}, {Register_Float, {4, 8}} },
		{{Register_Float, {4, 8}}, {Decimal, {4, 8}} },
		{{Memory_Float, {4, 8}}, {Decimal, {4, 8}} },
		{ {Decimal, {4, 8}}, {Register_Float, {4, 8}} },
		{{Decimal, {4, 8}}, {Memory_Float, {4, 8}} }
		},
		[](vector<Token*> args) {
			vector<IR*> Result;
			Token* Left = args[0];
			Token* Right = args[1];
			if (Right->is(NUM)) {
				double tmp = atof(Right->Get_Name().c_str());
				long long Name = *(long long*)&tmp;
				Token* R = new Token(TOKEN::REGISTER, "REG_" + to_string(Name + rand()), Right->Get_Size());
				//mov the number into 
				Result.push_back(new IR(new Token(TOKEN::OPERATOR, "="), {
					R,
					new Token(TOKEN::NUM, to_string(Name), Right->Get_Size())
					}, nullptr));

				Token* R2 = new Token(TOKEN::REGISTER | TOKEN::DECIMAL, "MEDIA_" + to_string(Name + rand()), Left->Get_Size());
				Result.push_back(new IR(new Token(TOKEN::OPERATOR, "="), {
					R2, R
					}, nullptr));
				Right = R2;
			}
			if (Left->is(MEMORY)) {
				Token* L = new Token(REGISTER | DECIMAL, "MEDIA_" + Left->Get_Name(), Left->Get_Size());
				Result.push_back(new IR(new Token(TOKEN::OPERATOR, "="), {
					L, Left
					}, nullptr));
				Left = L;
			}

			Result.push_back(new IR(new Token(OPERATOR, "subF"), {
				Left, Right
				}, nullptr));

			return Result;
		}
	);

	IR* F_MUL = new IR("*", new Token(OPERATOR | ALL_ARGS_SAME_SIZE), {
		//accepted arguments		
		{{Register_Float, {4, 8}}, {Memory_Float, {4, 8}} },
		{{Memory_Float, {4, 8}}, {Register_Float, {4, 8}} },
		{{Register_Float, {4, 8}}, {Register_Float, {4, 8}} },
		{{Register_Float, {4, 8}}, {Decimal, {4, 8}} },
		{{Memory_Float, {4, 8}}, {Decimal, {4, 8}} },
		{ {Decimal, {4, 8}}, {Register_Float, {4, 8}} },
		{{Decimal, {4, 8}}, {Memory_Float, {4, 8}} }
		},
		[](vector<Token*> args) {
			vector<IR*> Result;
			Token* Left = args[0];
			Token* Right = args[1];
			if (Right->is(NUM)) {
				double tmp = atof(Right->Get_Name().c_str());
				long long Name = *(long long*)&tmp;
				Token* R = new Token(TOKEN::REGISTER, "REG_" + to_string(Name + rand()), Right->Get_Size());
				//mov the number into 
				Result.push_back(new IR(new Token(TOKEN::OPERATOR, "="), {
					R,
					new Token(TOKEN::NUM, to_string(Name), Right->Get_Size())
					}, nullptr));

				Token* R2 = new Token(TOKEN::REGISTER | TOKEN::DECIMAL, "MEDIA_" + to_string(Name + rand()), Left->Get_Size());
				Result.push_back(new IR(new Token(TOKEN::OPERATOR, "="), {
					R2, R
					}, nullptr));
				Right = R2;
			}
			if (Left->is(MEMORY)) {
				Token* L = new Token(REGISTER | DECIMAL, "MEDIA_" + Left->Get_Name(), Left->Get_Size());
				Result.push_back(new IR(new Token(TOKEN::OPERATOR, "="), {
					L, Left
					}, nullptr));
				Left = L;
			}

			Result.push_back(new IR(new Token(OPERATOR, "mulF"), {
				Left, Right
				}, nullptr));

			return Result;
		}
	);

	IR* F_DIV = new IR("/", new Token(OPERATOR | ALL_ARGS_SAME_SIZE), {
		//accepted arguments		
		{{Register_Float, {4, 8}}, {Memory_Float, {4, 8}} },
		{{Memory_Float, {4, 8}}, {Register_Float, {4, 8}} },
		{{Register_Float, {4, 8}}, {Register_Float, {4, 8}} },
		{{Register_Float, {4, 8}}, {Decimal, {4, 8}} },
		{{Memory_Float, {4, 8}}, {Decimal, {4, 8}} },
		{ {Decimal, {4, 8}}, {Register_Float, {4, 8}} },
		{{Decimal, {4, 8}}, {Memory_Float, {4, 8}} }
		},
		[](vector<Token*> args) {
			vector<IR*> Result;
			Token* Left = args[0];
			Token* Right = args[1];
			if (Right->is(NUM)) {
				double tmp = atof(Right->Get_Name().c_str());
				long long Name = *(long long*)&tmp;
				Token* R = new Token(TOKEN::REGISTER, "REG_" + to_string(Name + rand()), Right->Get_Size());
				//mov the number into 
				Result.push_back(new IR(new Token(TOKEN::OPERATOR, "="), {
					R,
					new Token(TOKEN::NUM, to_string(Name), Right->Get_Size())
					}, nullptr));

				Token* R2 = new Token(TOKEN::REGISTER | TOKEN::DECIMAL, "MEDIA_" + to_string(Name + rand()), Left->Get_Size());
				Result.push_back(new IR(new Token(TOKEN::OPERATOR, "="), {
					R2, R
					}, nullptr));
				Right = R2;
			}
			if (Left->is(MEMORY)) {
				Token* L = new Token(REGISTER | DECIMAL, "MEDIA_" + Left->Get_Name(), Left->Get_Size());
				Result.push_back(new IR(new Token(TOKEN::OPERATOR, "="), {
					L, Left
					}, nullptr));
				Left = L;
			}

			Result.push_back(new IR(new Token(OPERATOR, "divF"), {
				Left, Right
				}, nullptr));

			return Result;
		}
	);

	IR* F_ADDSS = new IR("addF", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "addss"), {
		{{Register_Float, {4, 4}}, {Memory_Float, {4, 4}} },
		{{Memory_Float, {4, 4}}, {Register_Float, {4, 4}} },
		{{Register_Float, {4, 4}}, {Register_Float, {4, 4}} },
		{{Register_Float, {4, 4}}, {Decimal, {4, 4}} },
		{{Memory_Float, {4, 4}}, {Decimal, {4, 4}} }
	});

	IR* F_ADDSD = new IR("addF", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "addsd"), {
		{{Register_Float, {8, 8}}, {Memory_Float, {8, 8}} },
		{{Memory_Float, {8, 8}}, {Register_Float, {8, 8}} },
		{{Register_Float, {8, 8}}, {Register_Float, {8, 8}} },
		{{Register_Float, {8, 8}}, {Decimal, {8, 8}} },
		{{Memory_Float, {8, 8}}, {Decimal, {8, 8}} }
	});

	IR* F_SUBSS = new IR("subF", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "subss"), {
		{{Register_Float, {4, 4}}, {Memory_Float, {4, 4}} },
		{{Memory_Float, {4, 4}}, {Register_Float, {4, 4}} },
		{{Register_Float, {4, 4}}, {Register_Float, {4, 4}} },
		{{Register_Float, {4, 4}}, {Decimal, {4, 4}} },
		{{Memory_Float, {4, 4}}, {Decimal, {4, 4}} }
	});

	IR* F_SUBSD = new IR("subF", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "subsd"), {
		{{Register_Float, {8, 8}}, {Memory_Float, {8, 8}} },
		{{Memory_Float, {8, 8}}, {Register_Float, {8, 8}} },
		{{Register_Float, {8, 8}}, {Register_Float, {8, 8}} },
		{{Register_Float, {8, 8}}, {Decimal, {8, 8}} },
		{{Memory_Float, {8, 8}}, {Decimal, {8, 8}} }
	});

	IR* F_MULSS = new IR("mulF", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "mulss"), {
		{{Register_Float, {4, 4}}, {Memory_Float, {4, 4}} },
		{{Memory_Float, {4, 4}}, {Register_Float, {4, 4}} },
		{{Register_Float, {4, 4}}, {Register_Float, {4, 4}} },
		{{Register_Float, {4, 4}}, {Decimal, {4, 4}} },
		{{Memory_Float, {4, 4}}, {Decimal, {4, 4}} }
	});

	IR* F_MULSD = new IR("mulF", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "mulsd"), {
		{{Register_Float, {8, 8}}, {Memory_Float, {8, 8}} },
		{{Memory_Float, {8, 8}}, {Register_Float, {8, 8}} },
		{{Register_Float, {8, 8}}, {Register_Float, {8, 8}} },
		{{Register_Float, {8, 8}}, {Decimal, {8, 8}} },
		{{Memory_Float, {8, 8}}, {Decimal, {8, 8}} }
	});

	IR* F_DIVSS = new IR("divF", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "divss"), {
		{{Register_Float, {4, 4}}, {Memory_Float, {4, 4}} },
		{{Memory_Float, {4, 4}}, {Register_Float, {4, 4}} },
		{{Register_Float, {4, 4}}, {Register_Float, {4, 4}} },
		{{Register_Float, {4, 4}}, {Decimal, {4, 4}} },
		{{Memory_Float, {4, 4}}, {Decimal, {4, 4}} }
	});

	IR* F_DIVSD = new IR("divF", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "divsd"), {
		{{Register_Float, {8, 8}}, {Memory_Float, {8, 8}} },
		{{Memory_Float, {8, 8}}, {Register_Float, {8, 8}} },
		{{Register_Float, {8, 8}}, {Register_Float, {8, 8}} },
		{{Register_Float, {8, 8}}, {Decimal, {8, 8}} },
		{{Memory_Float, {8, 8}}, {Decimal, {8, 8}} }
	});

	IR* CMP = new IR("compare", new Token(OPERATOR | ALL_ARGS_SAME_SIZE, "cmp"), {
		{{Register, {1, 8}}, {Register, {1, 8}}},
		{{Register, {1, 8}}, {Memory, {1, 8}}},
		{{Memory, {1, 8}}, {Register, {1, 8}}},
		{{Register,  {1, 8}}, {Const, {1, 8}}},
		{ {Memory,  {1, 8}}, {Const, {1, 8}}}
		});

	IR* JMP = new IR("jump", new Token(FLOW, "jmp"), { {{Label, {0, 0}}} });
	IR* JE = new IR("==", new Token(FLOW, "je"), { {{Label, {0, 0}}} });
	IR* JNE = new IR("!=", new Token(FLOW, "jne"), { {{Label, {0, 0}}} });
	IR* JL = new IR("<", new Token(FLOW, "jl"), { {{Label, {0, 0}}} });
	IR* JLE = new IR("<=", new Token(FLOW, "jle"), { {{Label, {0, 0}}} });
	IR* JNL = new IR("!<", new Token(FLOW, "jnl"), { {{Label, {0, 0}}} });
	IR* JG = new IR(">", new Token(FLOW, "jg"), { {{Label, {0, 0}}} });
	IR* JGE = new IR(">=", new Token(FLOW, "jge"), { {{Label, {0, 0}}} });
	IR* JNG = new IR("!>", new Token(FLOW, "jng"), { {{Label, {0, 0}}} });

	IR* RET = new IR("return", new Token(FLOW, "ret"), vector<vector<pair<Token*, pair<int, int>>>>{});

	IR* PUSH = new IR("push", new Token(OPERATOR, "push"), {
	{{Memory, {2, 8}}},
	{{Register, {2, 8}}},
	{{Const, {1, 4}}},
		}); 
	IR* POP = new IR("pop", new Token(OPERATOR, "pop"), {
	{{Memory, {2, 8}}},
	{{Register, {2, 8}}},
			});

	IR* CALL = new IR("call", new Token(TOKEN::CALL, "call"), {
		{{Label, {0, 0}}},
		{{Register, {_SYSTEM_BIT_SIZE_, _SYSTEM_BIT_SIZE_}}},
		{ {Memory, {_SYSTEM_BIT_SIZE_, _SYSTEM_BIT_SIZE_}}}
	});	

	IR* GLOBAL = new IR("global", new Token(TOKEN::GLOBAL_LABEL, ".global"), {
		{{Label, {0, 0}}}
		}); 
	IR* EXTERN = new IR("extern", new Token(TOKEN::GLOBAL_LABEL, ".extern"), {
		{{Label, {0, 0}}}
	});
	IR* SECTION = new IR("section", new Token(TOKEN::OPERATOR, ".section"), {
		{{Label, {0, 0}}}
	});
	IR* FILE = new IR("file", new Token(TOKEN::OPERATOR, ".file"), {
		{{Label, {0, 1}}}
	});

	IR* DB = new IR("init", new Token(TOKEN::SET_DATA, ".byte"), {
		{{Data, {1, 1}}}
		}); 
	IR* ASCII = new IR("ascii", new Token(TOKEN::SET_DATA, ".asciz"), {
		{{Data, {0, 1}}}
	});
	IR* DW = new IR("init", new Token(TOKEN::SET_DATA, ".word"), {
		{{Data, {2, 2}}}
		});
	IR* DD = new IR("init", new Token(TOKEN::SET_DATA, ".long"), {
		{{Data, {4, 4}}}
		});
	IR* DQ = new IR("init", new Token(TOKEN::SET_DATA, ".quad"), {
		{{Data, {8, 8}}}
		});
	IR* SECREL32 = new IR("secrel32", new Token(TOKEN::SET_DATA, ".secrel32"), {
		{{Data, {4, 8}}}
	});
	IR* LOCATOIN = new IR("location", new Token(TOKEN::SET_DATA, ".loc"), {
		{{Data, {0, 0}}}
	});
	IR* CFI_START = new IR("cfi_start", new Token(TOKEN::SET_DATA, ".cfi_startproc"), {});
	IR* CFI_END = new IR("cfi_end", new Token(TOKEN::SET_DATA, ".cfi_endproc"), {});
	IR* CFI_OFFSET = new IR("cfi_offset", new Token(TOKEN::SET_DATA, ".cfi_def_cfa_offset"), {
		{{Data, {0, 4}}}
	});


	Opcodes = {
		MOV,
		LEA,
		ADD,
		SUB,
		MUL,
		C_MUL,
		DIV,
		C_DIV,
		C_MOD,
		CMP,
		XOR,
		JMP,
		JE,
		JNE,
		JL,
		JLE,
		JNL,
		JG,
		JGE,
		JNG,
		RET,
		SET,
		PUSH,
		POP,
		CALL,
		GLOBAL,
		EXTERN,
		SECTION,
		FILE,
		DB,
		DW,
		DD,
		DQ,
		SECREL32,
		LOCATOIN,
		CFI_START,
		CFI_END,
		CFI_OFFSET,
		ASCII,
		MOVQ,
		MOVD,
		MOVSS,
		MOVSD,
		CONVERTI2F,
		CONVERTI2D,
		CONVERTF2D,
		CONVERTF2I,
		CONVERTD2I,
		CONVERTD2F,
		F_MOV,
		F_ADD,
		F_ADDSS,
		F_ADDSD,
		F_SUB,
		F_SUBSS,
		F_SUBSD,
		F_MUL,
		F_DIV,
		F_MULSS,
		F_MULSD,
		F_DIVSS,
		F_DIVSD
	};
}

C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Cpp\Docker\ASM.cpp" 
#include "../../H/Docker/ASM.h"
#include "../../H/UI/Safe.h"

void ASM::ASM_Analyzer(vector<string>& Output)
{
	//here we will just make an prototype from every label. Parser can analyse wich one is a function, and what is not.
	//and after that we want to give Evie Core the "use "filename"" without the preprosessor so that Evie Core can implement an
	//post-prosessing include
	vector<string> Header_Data = DOCKER::Get_Header(DOCKER::FileName.back());
	if (Header_Data.size() < 1)
		Header_Data = DOCKER::Get_Header("asm..e");
	if (Header_Data.size() < 1)
		Header_Data = DOCKER::Default_ASM_Header_Data;
	if (Header_Data.size() < 1)
		Report(Observation(ERROR, "Docker didn't find Header file for " + DOCKER::FileName.back(), Position()));
	//DOCKER::Separate_Identification_Patterns(Header_Data);
	vector<uint8_t> tmp = DOCKER::Get_Char_Buffer_From_File(DOCKER::FileName.back(), DOCKER::Working_Dir.back().second);
	string buffer = string((char*)tmp.data(), tmp.size());
	Section Function_Section = DOCKER::Get_Section_From_String(buffer); 

	string Tmp = string((char*)Function_Section.start, Function_Section.size);
	auto Types = DOCKER::Separate_Identification_Patterns(Header_Data);
	vector<pair<string, string>> Raw_Data = DOCKER::Get_Names_Of(Tmp, Types);
	for (auto& i : Raw_Data) {
		if (i.second.find("global ") != -1)
			i.second.erase(i.second.find("global "), 7);
	}
	DOCKER::Append(Output, Raw_Data);
	//
	//Syntax_Correcter(Raw_Data);
	//now make the obj token for YASM
	DOCKER::Assembly_Source_File.push_back(DOCKER::Working_Dir.back().second + DOCKER::FileName.back());
	return;
}

C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Cpp\Docker\Docker.cpp" 
#include "../../H/Docker/Docker.h"
#include "../../H/UI/Safe.h"
#include "../../H/UI/Usr.h"

vector<string> DOCKER::Libs;
vector<string> DOCKER::Assembly_Source_File;
vector<string> DOCKER::FileName;
//			Directive changing FileName, directive.
vector<pair<string, string>> DOCKER::Working_Dir;
vector<string> DOCKER::Priority_Type; 
//TODO: make own implemitation of STD::MAP for vivid
map<string, vector<string>> DOCKER::Output;
//vector<ID, function ID>
vector<pair<Location, pair<string, void (*)(vector<string>&)>>> DOCKER::Translators;
void (*DOCKER::Default)(vector<string>&) = nullptr;
vector<string> DOCKER::Included_Files;
vector<bool> DOCKER::Is_Local;
vector<string>(*DOCKER::Slicer)(string);
bool DOCKER::WORKING_DIR_IS_ABSOLUTE = false;

extern Usr* sys;

vector<string> DOCKER::Default_ASM_Header_Data = {
	"func local = \"global\\ +([A-Za-z0-9_@]+)\"",
	"func local = \"export\\ +([A-Za-z0-9_@]+)\"",
	//func local = "global\ +([A-Za-z0-9_@]+)"
};

vector<string> DOCKER::Default_Header_Data = {
	"loyal std = \"_(\\w * @*) * \"\n",
	"func Generic = \"[a-zA-Z0-9]+\""
};

void DOCKER::Start_Analyzer()
{
	Is_Local.push_back(false);
	//https http ftp ftps 
	if (Default == nullptr) {
		Report(Observation(ERROR, "The default translator is missing!", Position()));
		return;
	}

	//file type  calculation.
	int Dot_Location = FileName.back().find_last_of('.');
	string File_Type = FileName.back().substr(Dot_Location + 1);
	
	char Buffer[16];
	//read Max_ID size into a buffer
	for (int i = 0; i < 16; i++) {
		if (!(i > FileName.back().size()))
			Buffer[i] = FileName.back().c_str()[i];
	}
	//for not overlapping wrong file type into lexer
	bool Wrong_Type = false;
	//iterate every map ID in Translators map
	for (auto i : Translators) {
		if (i.first == Location::Header) {
			if (strncmp(Buffer, i.second.first.c_str(), i.second.first.size()) == 0) {
				Wrong_Type = false;
				if (Priority_Type.back() == "txt") {
					Wrong_Type = true;
					continue;
				}
				i.second.second(Output[FileName.back()]);
				//sys->Info.Libs.push_back(Working_Dir + FileName);
				return;
			}
		}
	}
	if (Wrong_Type) {
		//cout << "Warning: No specific header file for " << FileName << "." << endl;
		return;
	}
	bool Try_Local = true;
	for (auto i : Output) {
		if (i.second.size() > 0)
			Try_Local = false;
	}
	if (Try_Local) {
		Is_Local.back() = true;
		FileName.back() = DOCKER::Update_Working_Dir(FileName.back());
		//if everything fails to check out it means,
		//that it is a txt file and thus call the lexer for that purpose.
		ifstream file(Working_Dir.back().second + FileName.back());
		//safe check
		//read Max_ID size into a buffer
		file.read(Buffer, 16);

		//for not overlapping wrong file type into lexer
		Wrong_Type = false;

		//iterate every map ID in Translators map
		for (auto i : Translators) {
			if (i.first == Location::Header) {
				if (strncmp(Buffer, i.second.first.c_str(), i.second.first.size()) == 0) {
					Wrong_Type = false;
					if (Priority_Type.back() == "txt") {
						Wrong_Type = true;
						continue;
					}
					i.second.second(Output[FileName.back()]);
					//sys->Info.Libs.push_back(Working_Dir + FileName);
					return;
				}
			}
			//check if the file name type is same as the translator filter
			else if (i.second.first == File_Type) {
				i.second.second(Output[FileName.back()]);

				return;
			}
		}
		if (Wrong_Type) {
			//cout << "Warning: No specific header file for " << FileName << "." << endl;
			return;
		}
		Default(Output[FileName.back()]);
	}
	return;
}

vector<string> DOCKER::Get_Header(string File_Name)
{
	vector<string> Result;
	string Name_No_Extension = "";
	int i = (int)File_Name.find_last_of('.');
	if (i != -1)
		Name_No_Extension = File_Name.substr(0, (size_t)i);
	else
		Name_No_Extension = File_Name;
	vector<string> Files;
	//collect all filenames in the working dir
	for (auto& p : filesystem::directory_iterator(Working_Dir.back().second))
	{
		string file_name = p.path().filename().string();
		if (file_name.find(Name_No_Extension) == 0)
			if (file_name != File_Name)
				Files.push_back(file_name);
	}
	//now iterate the files with Docker within the Priority type of txt.
	for (string s : Files) {
		Docker d(s, "txt");
		if (DOCKER::Output[s].size() > 0) {
			Result = DOCKER::Output[s];
			DOCKER::Output.erase(s);
		}
	}
	return Result;
}

vector<pair<string, string>>  DOCKER::Separate_Identification_Patterns(vector<string> list)
{
	vector<pair<string, string>> Types;
	vector<string> Tokens;
	for (auto i : list)
		DOCKER::Append(Tokens, DOCKER::Slicer(i));
	//try to find operattor that contains rightsided 
	//string for regexing and left side for type info
	for (int i = 0; i < Tokens.size(); i++) {
		if (Tokens[i] == "=" && Tokens[(size_t)i + 1][0] == '"') {
			Types.push_back({ Tokens[(size_t)i - 2], Tokens[(size_t)i + 1].substr(1, Tokens[(size_t)i + 1].size() - 2) });
			Tokens.erase(Tokens.begin() + i - 2, Tokens.begin() + i + 2);
			i--;
		}
	}
	Tokens.erase(remove_if(Tokens.begin(), Tokens.end(), [](string s) {return s == "\n"; }), Tokens.end());
	//gahther the remaining tokens for parser.
	//DOCKER::Append(Output[FileName.back()], Tokens);
	return Types;
}

vector<unsigned char> DOCKER::Get_Char_Buffer_From_File(string FN, string WD)
{
	ifstream inFile(WD + FN, ios_base::binary);
	if (!inFile.is_open()) {
		Report(Observation(ERROR, "Cannot open file!", Position()));
		return vector<unsigned char>();
	}
	inFile.seekg(0, ios_base::end);
	size_t length = inFile.tellg();
	inFile.seekg(0, ios_base::beg);

	vector<unsigned char> buffer;
	buffer.reserve(length);
	copy(istreambuf_iterator<char>(inFile),
		istreambuf_iterator<char>(),
		back_inserter(buffer));
	inFile.close();
	return buffer;
}

//		    name, type
vector<pair<string, string>> DOCKER::Get_Names_Of(string Input, vector<pair<string, string>> Types)
{
	vector<pair<string, string>> Result;
	for (auto i : Types) {
		smatch matches;
		regex Pattern(i.second);
		int Previus_Size = (int)Input.size();
		while (regex_search(Input, matches, Pattern)) {
			Result.push_back({ i.first, matches.str() });
			Input = matches.prefix().str() + matches.suffix().str();
			if (Previus_Size == (int)Input.size()) {
				Report(Observation(ERROR, "Regex string " + i.second + " looped infinitely!", Position()));
				break;
			}
			Previus_Size = (int)Input.size();
		}
	}
	return Result;
}

Section DOCKER::Get_Section_From_String(string& text)
{
	return Section{ (uint8_t*)text.c_str(), text.size() };
}

string DOCKER::ReplaceAll(string str, const string& from, const string& to) {
	size_t start_pos = 0;
	while ((start_pos = str.find(from, start_pos)) != string::npos) {
		str.replace(start_pos, from.length(), to);
		start_pos += to.length(); // Handles case where 'to' is a substring of 'from'
	}
	return str;
}

void DOCKER::Add_Translator(Location filter_location, string id, void (*f)(vector<string>&)) {
	Translators.push_back({ filter_location, { id, f } });
}

void DOCKER::Set_Default_Translator(void (*f)(vector<string>&)) {
	Default = f;
}

string DOCKER::Get_File_Extension(string raw) {
	string Name_No_Extension = "";
	int i = (int)raw.find_last_of('.');
	if (i != -1)
		Name_No_Extension = raw.substr((size_t)i + 1, raw.size());
	else
		Name_No_Extension = raw;
	return Name_No_Extension;
}

string DOCKER::Update_Working_Dir(string File_Name)
{
	int i = (int)File_Name.find_last_of('/');
	string Prevous_Dir = "";

	if (Working_Dir.size() > 0)
		Prevous_Dir = Working_Dir.back().second;

	if (WORKING_DIR_IS_ABSOLUTE)
		Prevous_Dir = "";

	if (i != -1)
	{
		Working_Dir.push_back({Prevous_Dir + File_Name , Prevous_Dir + File_Name.substr(0, (size_t)i + 1) });
		return File_Name.substr((size_t)i + 1);
	}
	return File_Name;
}

string DOCKER::Update_Working_Dir(string File_Name, string& dir)
{
	int i = (int)File_Name.find_last_of('/');
	if (i != -1)
	{
		dir += File_Name.substr(0, (size_t)i + 1);
		return File_Name.substr((size_t)i + 1);
	}
	return File_Name;
}

vector<string> DOCKER::Get_File_List(string Dir)
{
	vector<string> Files;
	//collect all filenames in the working dir
	for (auto& p : filesystem::directory_iterator(Dir))
	{
		string file_name = p.path().filename().string();
				Files.push_back(file_name);
	}
	return Files;
}

vector<string> DOCKER::Chop_Chop(string raw, char skip)
{
	vector<string> Result;
	string Current = "";
	for (auto i : raw) {
		if (i == skip) {
			if (Current.size() > 0)
				Result.push_back(Current);
			Current = "";
		}
		else
			Current += i;
	}
	if (Current != "")
		Result.push_back(Current);
	return Result;
}

string DOCKER::Remove(string raw, char id, int cut)
{
	string Result = "";
	int current = 0;
	for (auto i : raw) {
		if (cut == current)
			break;
		if (i == id)
			current++;
		Result += i;
	}

	return Result;
}

bool DOCKER::Is_Folder(string path)
{
	vector<string> Files;
	//collect all filenames in the working dir
	if (filesystem::is_directory(path)) {
		return true;
	}
	return false;
}

bool DOCKER::Is_Same_File(string first, string second)
{
	string tmp = "";
	string JustNameF = DOCKER::Update_Working_Dir(first, tmp);
	char* BufferF = Read_Bin_File(JustNameF);
	string JustNameS = DOCKER::Update_Working_Dir(second, tmp);
	char* BufferS = Read_Bin_File(JustNameS);

	if (JustNameF != JustNameS)
		return false;


	string F(BufferF);
	string S(BufferS);

	if (F.size() != S.size())
		return false;


	if (memcmp(BufferF, BufferS, S.size()) != 0)
		return false;

	return true;
}

char* DOCKER::Read_Bin_File(string fileName)
{
	ifstream file(DOCKER::Working_Dir.back().second + fileName, std::ios::binary);
	file.seekg(0, ios_base::end);
	long long size = file.tellg();
	char* Buffer = new char[size+1];
	file.seekg(0, ios_base::beg);
	file.read(Buffer, size);
	Buffer[size] = '\0';
	file.close();
	return Buffer;
}

string DOCKER::Find(string File_Name)
{
	string Result = "";

	vector<string> Locations;

	//try check if the env are already cached for us.
	string Cache = Open_File(sys->Info.Evie_Location + ".Chached_Env_Paths.txt");
	//transform into a vector of paths.
	//"abc//",
	//"cbd//",
	//...
	vector<string> Chached_Paths;
	for (auto i : Lexer::GetComponents(Cache)) {
		Locations.push_back(i.Value.substr(1, i.Value.size() - 2));
		Chached_Paths.push_back(i.Value.substr(1, i.Value.size() - 2));
	}

	Locations.push_back(sys->Info.Evie_Location);

	for (auto i : DOCKER::Get_System_Paths())
		Locations.push_back(i);

	for (auto i : Locations) {
		try {
			for (auto p : filesystem::directory_iterator(i))
			{
				filesystem::path File_Path = p.path();
				if (!DOCKER::Is_Folder(File_Path.string()))
					if (File_Path.filename().string() == File_Name) {
						//find recursively in the Evie folder location
						//return sys->Info.Evie_Location;
						bool Found = false;
						for (auto j : Chached_Paths)
							if (j == File_Path.remove_filename().string())
								Found = true;
						if (!Found)
							Write_File(sys->Info.Evie_Location + ".Chached_Env_Paths.txt", "\"" + File_Path.remove_filename().string() + "\"\n");
						return File_Path.string();
					}
					else
						continue;

				string Folder = DOCKER::Find(File_Name, p);
				if (Folder != "")
					return Folder;
			}
		}
		catch (...) {
			continue;
		}
	}
	return "";
}

string DOCKER::Find(string File_Name, filesystem::directory_entry Folder)
{
	for (auto p : filesystem::directory_iterator(Folder))
	{
		filesystem::path File_Path = p.path();
		if (!DOCKER::Is_Folder(File_Path.string()))
			if (File_Path.filename().string() == File_Name)
				return Folder.path().string();
			else
				continue;

		string Folder = DOCKER::Find(File_Name, p);
		if (Folder != "")
			return Folder;
	}
	return "";
}

vector<string> DOCKER::Get_System_Paths()
{
	char Path_Seperator = ';';
	if (sys->Info.OS == "unix")
		Path_Seperator = ':';

	string Result = "";

	const char* Path_Type = "Path";
	if (sys->Info.OS == "unix")
		Path_Type = "PATH";

	char* Path = getenv(Path_Type);
	if (Path == nullptr) {
		throw::runtime_error("Cannot get environment variable '" + (string)Path_Type + "'!");
	}
	string List = string(Path);

	vector<string> Paths;
	string tmp = "";
	for (auto i : List) {
		if (i == '\\')
			i = '/';
		if (i == Path_Seperator) {
			if (tmp == "")
				continue;
			Paths.push_back(tmp);
			tmp = "";
		}
		else
			tmp += i;
	}
	if (tmp != "")
		Paths.push_back(tmp);

	return Paths;
}

string DOCKER::Open_File(string File_Name)
{
	fstream file(File_Name, std::ios::in | std::ios::out | std::ios::app | std::ios::binary);

	file.seekg(0, ios_base::end);
	long long size = file.tellg();
	char* Buffer = new char[size];
	file.seekg(0, ios_base::beg);
	file.read(Buffer, size);
	file.close();

	return string(Buffer, size);
}

void DOCKER::Write_File(string File_Name, string Buffer)
{
	string File_Remains = Open_File(File_Name);

	std::ofstream ofs(File_Name);
	ofs << File_Remains + Buffer;
	ofs.close();
}

void DOCKER::Clear_File(string File_Name)
{
	std::ofstream ofs(File_Name);
	ofs << "";
	ofs.close();
}

vector<string>& DOCKER::Append(vector<string>& d, vector<pair<string, string>> s) {
	for (int i = 0; i < s.size(); i++) {
		string r = s[i].first + " " + s[i].second;
		d.push_back(r);
	}
	return d;
}
C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Cpp\Docker\ELF.cpp" 
#include "../../H/Docker/ELF.h"
#include "../../H/UI/Safe.h"

// Returns true if the ELF-file is 32-bit, otherwise false
bool ELF::Get_Bits_Size(uint8_t* buffer)
{
   return reinterpret_cast<elf32_hdr*>(buffer)->e_ident[EI_CLASS] == 1;
}

uint64_t ELF::Get_Section_Header_Offset(uint8_t* buffer)
{
	return Get_Bits_Size(buffer) ? reinterpret_cast<elf32_hdr*>(buffer)->e_shoff : reinterpret_cast<elf64_hdr*>(buffer)->e_shoff;
}

uint64_t ELF::Get_Header_Amount(uint8_t* buffer)
{
	return Get_Bits_Size(buffer) ? reinterpret_cast<elf32_hdr*>(buffer)->e_shnum : reinterpret_cast<elf64_hdr*>(buffer)->e_shnum;
}

uint8_t* ELF::Get_Section_Names(uint8_t* buffer) {
    bool BIT_SIZE = Get_Bits_Size(buffer);
    uint16_t Index = Get_Bits_Size(buffer) ? reinterpret_cast<elf32_hdr*>(buffer)->e_shstrndx : reinterpret_cast<elf64_hdr*>(buffer)->e_shstrndx;
    uint64_t Current_Section_Header = Get_Section_Header_Offset(buffer);
    //uint64_t Header_Count = Get_Header_Amount(buffer);
    vector<string> Names;

    if (BIT_SIZE) {
        elf32_shdr* Section_Headers = reinterpret_cast<elf32_shdr*>(&buffer[Current_Section_Header]);
        elf32_shdr& Section_Header = Section_Headers[Index];

        /*
            Made by Joonas Lehto 13/05/2020
              Master header:
              is x86 or x86-64
        | <-- sh_offset: int
              e_shstrndx: int (INDEX) = 31
        |
        |
        |
        |
        |-->  First Section Header:

              type: int
              name: int (index)

              .
              .
              .

              .rdata Section Header: (30)
              type: int
              name: int (index) = 2

              .rdata Section Header: (31)
              type: int
              name: int (index) = 2

              .
              .
              .

              TARGET e_shstrndx (31)
              type: int
              name: int (index)
              position: int (pointer)


              .
              .
              .

              Last Section Header:

              type: int
              name: int (index)









   2443FG F DF
  3qerFEF
  REFRFE
  WEF W FR  _glfwInit \0



  wdwwd                                                    0        1        2
  dwdwwwwwwwwwwwwwwgrrfrfefe ...........dw  3 r3rr  4 3 -> .text \0 .data \0 .rdata \0 => { .text, .data, .rdata }




        */

        return reinterpret_cast<uint8_t*>(&buffer[Section_Header.sh_offset]);

        /*string type = "";
        for (int i = 0; i < Section_Header.sh_size; i++)
        {
            if (position[i] == 0) {
                Names.push_back(type);
                type = "";
                continue;
            }
            type.push_back(position[i]);
        }*/
    }
    else
    {
        //this summer coming soon!
        elf64_shdr* Section_Headers = reinterpret_cast<elf64_shdr*>(&buffer[Current_Section_Header]);
        elf64_shdr& Section_Header = Section_Headers[Index];

        return reinterpret_cast<uint8_t*>(&buffer[Section_Header.sh_offset]);

        /*string type = "";
        for (int i = 0; i < Section_Header.sh_size; i++)
        {
            if (position[i] == 0) {
                Names.push_back(type);
                type = "";
                continue;
            }
            type.push_back(position[i]);
        }*/
    }
    //Names.insert(Names.begin() + 1, ".hash");       //!!!!
    //return Names;
}

Section ELF::Find_Section(uint8_t* buffer, string type) {
    bool BIT_SIZE = Get_Bits_Size(buffer);
    uint64_t Current_Section_Header = Get_Section_Header_Offset(buffer);
    uint64_t Header_Count = Get_Header_Amount(buffer);

    uint8_t* Names = Get_Section_Names(buffer);

    if (BIT_SIZE) {
        elf32_shdr* Section_Headers = reinterpret_cast<elf32_shdr*>(&buffer[Current_Section_Header]);
        for (int i = 0; i < Header_Count; i++)
        {
            elf32_shdr& Section_Header = Section_Headers[i];

            string name = (const char*)&Names[Section_Header.sh_name];

            if (name == type)
            {
                return { &buffer[Section_Header.sh_offset], Section_Header.sh_size };
            }
        }
    }
    else
    {
        elf64_shdr* Section_Headers = reinterpret_cast<elf64_shdr*>(&buffer[Current_Section_Header]);
        for (int i = 0; i < Header_Count; i++)
        {
            elf64_shdr& Section_Header = Section_Headers[i];

            string name = (const char*)&Names[Section_Header.sh_name];

            if (name == type)
            {
                return { &buffer[Section_Header.sh_offset], Section_Header.sh_size };
            }
        }
    }
    Report(Observation(ERROR, "Couldn't find section " + type, Position()));
    throw "Yeet";
}

void ELF::ELF_Analyzer(vector<string>& output)
{
    vector<string> Header_Data = DOCKER::Get_Header(DOCKER::FileName.back());
    if (Header_Data.size() < 1)
        Header_Data = DOCKER::Get_Header("elf..e");
    if (Header_Data.size() < 1)
        Header_Data = DOCKER::Default_Header_Data;
    if (Header_Data.size() < 1)
        Report(Observation(ERROR, "Docker didn't find Header file for " + DOCKER::FileName.back(), Position()));
    
    //open & read the bin file
    vector<unsigned char> File_Buffer = DOCKER::Get_Char_Buffer_From_File(DOCKER::FileName.back(), DOCKER::Working_Dir.back().second);
    Section Function_Section = ELF::Find_Section(File_Buffer.data(), ".dynstr");
    for (int i = 0; i < Function_Section.size; i++) {
        if (Function_Section.start[i] == '\0')
            Function_Section.start[i] = '?';
    }
    string Tmp = string((char*)Function_Section.start, Function_Section.size);
    DOCKER::Append(output, DOCKER::Get_Names_Of(Tmp, DOCKER::Separate_Identification_Patterns(Header_Data)));
    DOCKER::Libs.push_back(DOCKER::Working_Dir.back().second + DOCKER::FileName.back());
    return;
}
C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Cpp\Docker\HTTPS.cpp" 
#include "../../H/Docker/HTTPS.h"
#include "../../H/UI/Usr.h"
#define CURL_STATICLIB
#include "../../Dependencies/Curl/curl.h"
#include "../../H/UI/Safe.h"
#include <regex>

extern Usr* sys;

string HTTPS::File_Name;

size_t WriteMemoryCallback(void* contents, size_t size, size_t nmemb, void* userp) {
	size_t realsize = size * nmemb;
	struct MemoryStruct* mem = (struct MemoryStruct*)userp;

	void* ptr = realloc(mem->memory, mem->size + realsize + 1);
	if (ptr == NULL) {
		printf("error: not enough memory\n");
		return 0;
	}

	mem->memory = (char*)ptr;
	memcpy(&(mem->memory[mem->size]), contents, realsize);
	mem->size += realsize;
	mem->memory[mem->size] = 0;

	return realsize;
}

void HTTPS::HTTPS_Analyser(vector<string>& output)
{
	//we need to set all those remotely included libs into a subfolder
	//idk maybe Remote/??
	string Path;
	string Name = DOCKER::Update_Working_Dir(DOCKER::FileName.back(), Path);
	string Remote_Dir = sys->Info.Repo_Dir;
	vector<string> Info = DOCKER::Chop_Chop(DOCKER::FileName.back(), '/');
	//[0] = https:			--method //
	//[1] = github			--interface /
	//[2] = Gabidal			--author /
	//[3] = Evie			--repo name /
	//[x > 3] = subfolders	--sub folders ../
	//[last] = cstd.e		--file/folder name
	//get URL
	string URL = DOCKER::Remove(Path, '/', 5);

	string Double_Command_Mark = " ; ";

	if (sys->Info.HOST_OS == "win") {
		Double_Command_Mark = " && ";
	}

	string Seperator = "";
	if (Remote_Dir[0] != '/' && DOCKER::Working_Dir.back().second.back() != '/')
		Seperator = '/' + Seperator;
	string Remote_Dir_Location = DOCKER::Working_Dir.back().second + Seperator + Remote_Dir;

	//check if the Remote folder exists
	bool Repo_Folder = false;
	if (DOCKER::Is_Folder(Remote_Dir_Location))
		Repo_Folder = true;

	/*for (auto i : DOCKER::Get_File_List(DOCKER::Working_Dir.back().second)) {
		if (i == Remote_Dir)
			Repo_Folder = true;
	}*/

	if (Repo_Folder == false) {
		//This could also mean that the repo folder is given as a absolute path.
		if (DOCKER::Is_Folder(Remote_Dir)) {
			Remote_Dir_Location = Remote_Dir;
			Repo_Folder = true;
			DOCKER::WORKING_DIR_IS_ABSOLUTE = true;
		}
	}

	if (Repo_Folder == false) {
		Report(Observation(WARNING, "folder " + Remote_Dir_Location + " does not exist, making a new one.", Position()));
		system(("mkdir \"" + Remote_Dir_Location + "\"").c_str());
	}

	bool New_Repo = true;
	//try to see if there is already a git folder for this git repo.
	for (auto i : DOCKER::Get_File_List(Remote_Dir_Location)) {
		//the i contains the reponame
		if (i == Info[3]) {
			New_Repo = false;
			break;
		}
	}

	if (Remote_Dir_Location[Remote_Dir_Location.size()-1] != '/')
		Remote_Dir_Location += '/';

	string Command = "cd " + Remote_Dir_Location + Info[3] + Double_Command_Mark + "git pull --quiet \"" + URL + "\"";

	if (New_Repo) {
		Command = "cd " + Remote_Dir_Location + Double_Command_Mark + "git clone --quiet \"" + URL + "\"";
	}
	string Repo_Folder_Dest_Path;

	if (system(Command.c_str()) != 0) {

		//try git stash to fix git merge.
		string Stash = "cd " + Remote_Dir_Location + Info[3] + Double_Command_Mark + "git stash --quiet ";
		system(Stash.c_str());
		
		if (system(Command.c_str()) == 0)
			goto Git_Merge_Error_Fixed;

		Report(Observation(INFO, "Given URL is not git based, going into fallback mode.", Position()));
		//this URL is not a git based file repo.
		//use curl
		CURL* curl_handle;
		CURLcode res;

		MemoryStruct chunk;

		curl_handle = curl_easy_init();
		if (curl_handle) {
			if (sys->Info.VT_API != "") {
				//use virustotal to check the url
				curl_easy_setopt(curl_handle, CURLOPT_URL, "https://www.virustotal.com/vtapi/v2/url/scan");
				curl_easy_setopt(curl_handle, CURLOPT_FOLLOWLOCATION, 1L);
				curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
				curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void*)&chunk);
				curl_easy_setopt(curl_handle, CURLOPT_USERAGENT, "libcurl-agent/1.0");
				string Data = "apikey=" + sys->Info.VT_API + "&url=" + (Path + Name);
				curl_easy_setopt(curl_handle, CURLOPT_POSTFIELDS, Data.c_str());

				res = curl_easy_perform(curl_handle);

				if (res != CURLE_OK)
					Report(Observation(ERROR, curl_easy_strerror(res), Position()));
				else {
					curl_easy_cleanup(curl_handle);
					curl_handle = curl_easy_init();
					free(chunk.memory);
					chunk = MemoryStruct();

					curl_easy_setopt(curl_handle, CURLOPT_URL, "https://www.virustotal.com/vtapi/v2/url/report");
					curl_easy_setopt(curl_handle, CURLOPT_FOLLOWLOCATION, 1L);
					curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
					curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void*)&chunk);
					curl_easy_setopt(curl_handle, CURLOPT_USERAGENT, "libcurl-agent/1.0");
					string Data = "apikey=" + sys->Info.VT_API + "&resource=" + (Path + Name);
					curl_easy_setopt(curl_handle, CURLOPT_POSTFIELDS, Data.c_str());

					res = curl_easy_perform(curl_handle);
					if (res != CURLE_OK)
						Report(Observation(ERROR, curl_easy_strerror(res), Position()));
					else {
						regex expression("\"positives\": [0-9]+");
						smatch matches;
						string Buffer = chunk.memory;
						if (!regex_search(Buffer, matches, expression)) {
							Report(Observation(ERROR, "Could not get VT report.", Position()));
						}

						int Positives = atoi(matches.str().substr(12).c_str());
						if (Positives > 0) {
							Report(Observation(WARNING, "Suspicious URL " + Path + Name, Position()));
						}
						//printf("Size: %lu\n", (unsigned long)chunk.size);
						//printf("Data: %s\n", chunk.memory);
					}
				}
				curl_easy_cleanup(curl_handle);
				curl_handle = curl_easy_init();
				free(chunk.memory);
				chunk = MemoryStruct();
			}
			curl_easy_setopt(curl_handle, CURLOPT_URL, (Path + Name).c_str());
			curl_easy_setopt(curl_handle, CURLOPT_FOLLOWLOCATION, 1L);
			curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
			curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void*)&chunk);
			curl_easy_setopt(curl_handle, CURLOPT_USERAGENT, "libcurl-agent/1.0");

			res = curl_easy_perform(curl_handle);

			if (res != CURLE_OK) {
				Report(Observation(ERROR, curl_easy_strerror(res), Position()));
			}
			else {
				ofstream o(Remote_Dir_Location + Name.c_str());
				if (!o.is_open()) {
					Report(Observation(ERROR, "Could not save contents of " + Name, Position()));
				}
				o.write(chunk.memory, (unsigned long)chunk.size);
				o.close();
				//printf("Size: %lu\n", (unsigned long)chunk.size);
				//printf("Data: %s\n", chunk.memory);
			}
			curl_easy_cleanup(curl_handle);
			free(chunk.memory);
			Repo_Folder_Dest_Path = Remote_Dir_Location + Name.c_str();
		}
	}
	else {
	Git_Merge_Error_Fixed:;
		if (Remote_Dir[Remote_Dir.size()-1] != '/')
			Remote_Dir += '/';
		//now we have the repo, next we need to know if we want to build the whole folder or just get a single file.
		Repo_Folder_Dest_Path = Remote_Dir;
		for (int i = 3; i < Info.size() - 1; i++) {
			Repo_Folder_Dest_Path += Info[i] + '/';
		}
		Repo_Folder_Dest_Path += Info.back();
	}


	bool Need_Make_Build = true;
	string File_Path = "";
	for (int i = 3; i < Info.size() - 1; i++) {
		File_Path += Info[i] + "/";
	}
	File_Path += Info[Info.size() - 1];

	string Dir = "";
	string File = DOCKER::Update_Working_Dir(File_Path, Dir);
	for (auto f : DOCKER::Get_File_List(Remote_Dir_Location + Dir))
		if (f == File)
			Need_Make_Build = false;

	if (DOCKER::Is_Folder(Repo_Folder_Dest_Path) || Need_Make_Build) {
		//we build it here.
		string Make = "";
		if (sys->Info.HOST_OS == "unix") {
			if (system("which make") != 0)
				Report(Observation((MSG_Type)1, "Is make-utility installed and visible to this program?", Position()));
			Make = "make";
		}
		else {
			if (system(".\\Dependencies\\Mingw\\make.exe -v") != 0) {
				Report(Observation((MSG_Type)1, "nmake-utility is needed to be in the same folder or in environment varibles", Position()));
			}
			Make = ".\\Dependencies\\Mingw\\make.exe";
		}
		int error = system((Make + " all").c_str());

		bool All_Argument_Made_It = false;
		if (error != 0) {
			Report(Observation((MSG_Type)1, to_string(error) + " Could not build with default argument, going into fallback mode.", Position()));
		}
		else
			for (auto f : DOCKER::Get_File_List(Remote_Dir_Location + Dir))
				if (f == File)
					All_Argument_Made_It = true;

		if (!All_Argument_Made_It)
			if (system((Make + " -B").c_str()) != 0) {
				Report(Observation((MSG_Type)1, "Make-utility build error, please fix the problems first.", Position()));
			}
		DOCKER::FileName.back() = Remote_Dir_Location + Dir + File;
		DOCKER::Output.erase(DOCKER::Output.rbegin()->first);
		Docker D(Remote_Dir_Location + Dir + File);
	}
	else {
		DOCKER::FileName.back() = Repo_Folder_Dest_Path;
		DOCKER::Output.erase(DOCKER::Output.rbegin()->first);
		Docker D(Repo_Folder_Dest_Path);
	}
	DOCKER::WORKING_DIR_IS_ABSOLUTE = false;
	return;
}

C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Cpp\Docker\LIB.cpp" 
#include "../../H/Docker/LIB.h"
#include "../../H/UI/Safe.h"

extern Usr* sys;

void LIB::Generate_Binary_Symbols(string filename, string WD)
{
	string NM_Posix = "";
	//first start the NM.exe
	if (sys->Info.HOST_OS == "win32")
		NM_Posix = "nm.exe ";
	else
		NM_Posix = "./nm ";

	system((NM_Posix + WD + filename + " --extern-only --defined-only -P > .TMP.txt").c_str());
	return;
}

void LIB::LIB_Analyzer(vector<string>& Output)
{
	vector<string> Header_Data = DOCKER::Get_Header(DOCKER::FileName.back());
	if (Header_Data.size() < 1)
		Header_Data = DOCKER::Get_Header("lib..e");
	if (Header_Data.size() < 1)
		Header_Data = DOCKER::Default_Header_Data;
	if (Header_Data.size() < 1)
		Report(Observation(ERROR,  "Docker didn't find Header file for " + DOCKER::FileName.back(), Position()));
	
	//write the lib with nm to .TMP.txt file
	LIB::Generate_Binary_Symbols(DOCKER::FileName.back(), DOCKER::Working_Dir.back().second);
	vector<uint8_t> tmp = DOCKER::Get_Char_Buffer_From_File(".TMP.txt", "");
	string buffer = string((char*)tmp.data(), tmp.size());
	//use filtters
	buffer = DOCKER::ReplaceAll(buffer, "\r\n", "\n");
	regex filtter("(\\?.*)|(\\ .\\ [0-9]+)|(.+:)|(__.+@.+)");
	buffer = regex_replace(buffer, filtter, "");
	regex filtter2("(\\n{2,})");
	buffer = regex_replace(buffer, filtter2, "\n");
	Section Function_Section = DOCKER::Get_Section_From_String(buffer);
	for (int i = 0; i < Function_Section.size; i++) {
		if (Function_Section.start[i] == '\0')
			Function_Section.start[i] = '?';
	}
	string Tmp = string((char*)Function_Section.start, Function_Section.size);
	DOCKER::Append(Output, DOCKER::Get_Names_Of(Tmp, DOCKER::Separate_Identification_Patterns(Header_Data)));
	DOCKER::Libs.push_back(DOCKER::Working_Dir.back().second + DOCKER::FileName.back());
	return;
}

C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Cpp\Docker\Mangler.cpp" 
#include "../../H/Docker/Mangler.h"
#include "../../H/Nodes/Node.h"
#include <iomanip>
#include <sstream>

vector<pair<string, vector<pair<string, pair<int, string>>>>> MANGLER::IDS;
bool Functoin_Name_Is_Before_End_Of_Namespace = false;

string MANGLER::Un_Mangle(string raw) {
	//try to find if there are any prefixes and remove them into another string
	string PreFix;
	if ((int)raw.find_last_of(' ') >= 0) {
		int pre_i = (int)raw.find_last_of(' ');
		PreFix = raw.substr(0, (size_t)pre_i + 1);
		raw = raw.substr((size_t)pre_i + 1, raw.size());
	}
	bool Func_Name = true;
	bool Namespace = false;

	string Function = "";
	vector<string> Parenthesis;
	string Return_Type = "";
	string Current;
	string Current_Variable = "";
	string Current_PreFix = "";
	string Current_Complex_Name = "";
	vector<string> Scope_Path;
	string STD = "";
	vector<string> Current_Parameter_Inheritted;
	bool Return_Type_Section = false;
	//type ptr new  type
	if (raw[0] == '_' && raw[1] == 'Z') {
		//C++ unmangler
		//_Z3NEWi3ABC
		STD = "cpp";
		vector<pair<string, pair<int, string>>>& Current_IDS = *Find_STD_List(STD);
		for (int i = 2; i < raw.size(); i++) {
			Current = raw[i];
			Current_Complex_Name += raw[i];
			//for char based aliases.
			if (Find(Current, &Current_IDS) != nullptr) {
				if (Find(Current, &Current_IDS)->first == MANGLER::VARIABLE) {
					//when a new variable starts appearing we want to push the previus into the function-
					//parameters string.
					if (Current_Variable != "") {
						Parenthesis.push_back(Current_Variable);
						Current_Variable = "";
						Current_PreFix = "";
					}
					Current_Complex_Name = "";
					if (Current_PreFix != "")
						Current_Variable = Current_PreFix + " ";
					Current_Variable += Find(Current, &Current_IDS)->second + " ";
				}
				else if (Find(Current, &Current_IDS)->first == MANGLER::POSTFIX) {
					Current_Variable += Find(Current, &Current_IDS)->second + " ";
					Current_Complex_Name = "";
				}
				else if (Find(Current, &Current_IDS)->first == MANGLER::PREFIX) {
					if (Current_Variable != "")
						Parenthesis.push_back(Current_Variable);
					Current_PreFix += Find(Current, &Current_IDS)->second + " ";
					Current_Complex_Name = "";
				}
				else if (Find(Current, &Current_IDS)->first == MANGLER::CLASS && Current_Complex_Name.size() == 1) {
					Namespace = true;
					if (Functoin_Name_Is_Before_End_Of_Namespace)
						Func_Name = false;
				}
				else if (Find(Current, &Current_IDS)->first == MANGLER::END_CLASS && Current_Complex_Name.size() == 1) {
					Namespace = false;
				}
			}
			else if (Find(Current, &Current_IDS) != nullptr) {
				//for multi char based aliases.
				if (Find(Current_Complex_Name, &Current_IDS)->first == MANGLER::VARIABLE) {
					//when a new variable starts appearing we want to push the previus into the function-
					//parameters string.
					if (Current_Variable != "") {
						Parenthesis.push_back(Current_Variable);
						Current_Variable = "";
					}
					Current = "";
					if (Current_PreFix != "")
						Current_Variable = Current_PreFix + " ";
					Current_Variable += Find(Current_Complex_Name, &Current_IDS)->second + " ";
				}
				else if (Find(Current_Complex_Name, &Current_IDS)->first == MANGLER::POSTFIX) {

					Current = "";
					Current_Variable += Find(Current_Complex_Name, &Current_IDS)->second + " ";
				}
				else if (Find(Current_Complex_Name, &Current_IDS)->first == MANGLER::PREFIX) {
					if (Current_Variable != "") {
						Parenthesis.push_back(Current_Variable);
						Current_Variable = "";
					}

					Current = "";

					Current_PreFix += Find(Current_Complex_Name, &Current_IDS)->second + " ";
				}
			}
			//TODO: add that if the current complex name is bigger than 2(.., current num) then dont do this.
			else if (((raw[i] >= 48) && (raw[i] <= 57))) {
				string tmp = "";
				tmp += raw[i];
				for (int j = i + 1; j < raw.size(); j++) {
					if (((raw[j] >= 48) && (raw[j] <= 57)))
						tmp += (char)raw[j];
					else
						break;
				}
				int size = atoi(tmp.c_str());
				string name = "";
				for (int j = i + (int)tmp.size(); (j < (size + i + (int)tmp.size())) && j < (int)raw.size(); j++) {
					name += (char)raw[j];
				}
				if (Namespace) {
					Scope_Path.push_back(name);
				}
				else if (Func_Name) {
					Function = name;
					Func_Name = false;
				}
				else {

					//class based parameters.
					if (Current_Variable != "") {
						Parenthesis.push_back(Current_Variable);
						Current_Variable = "";
					}

					Current_Variable = Current_PreFix + " " + name;
				}
				i += size + (int)tmp.size() - 1;
			}
		}
		if (Current_Variable != "") {
			Parenthesis.push_back(Current_Variable);
		}
	}
	//else if (raw[0] == '_' && raw[1] == 'E') {
	//	STD = "evie";
	//}
	else if (raw[0] == '_' && raw[1] == 'V') {
		STD = "vivid";
		vector<pair<string, pair<int, string>>>& Current_IDS = *Find_STD_List(STD);
		for (int i = 2; i < raw.size(); i++) {
			Current = raw[i];
			Current_Complex_Name += raw[i];
			//for char based aliases.
			if (Find(Current, &Current_IDS) != nullptr) {
				if (Find(Current, &Current_IDS)->first == MANGLER::VARIABLE) {
					//when a new variable starts appearing we want to push the previus into the function-
					//parameters string.
					if (Current_Variable != "") {
						if (Return_Type_Section) {
							Return_Type += " " + Current_Variable;
							Current_Variable = "";
							Current_PreFix = "";
						}
						else {
							Parenthesis.push_back(Current_Variable);
							Current_Variable = "";
							Current_PreFix = "";
						}
					}
					Current_Complex_Name = "";
					if (Current_PreFix != "")
						Current_Variable = Current_PreFix + " ";
					Current_Variable += Find(Current, &Current_IDS)->second + " ";
				}
				else if (Find(Current, &Current_IDS)->first == MANGLER::POSTFIX) {
					Current_Variable += Find(Current, &Current_IDS)->second + " ";
					Current_Complex_Name = "";
				}
				else if (Find(Current, &Current_IDS)->first == MANGLER::PREFIX) {
					if (Current_Variable != "")
						Parenthesis.push_back(Current_Variable);
					Current_PreFix += Find(Current, &Current_IDS)->second + " ";
					Current_Complex_Name = "";
					Current_Variable = "";
				}
				else if (Find(Current, &Current_IDS)->first == MANGLER::CLASS && Current_Complex_Name.size() == 1) {
					Namespace = true;
					if (Functoin_Name_Is_Before_End_Of_Namespace)
						Func_Name = false;
				}
				else if (Find(Current, &Current_IDS)->first == MANGLER::END_CLASS && Current_Complex_Name.size() == 1) {
					Namespace = false;
				}
			}
			else if (Find(Current, &Current_IDS) == nullptr && Current_Complex_Name.size() > 1 && Find(Current_Complex_Name, &Current_IDS) != nullptr) {
				//for multi char based aliases.
				if (Find(Current_Complex_Name, &Current_IDS)->first == MANGLER::VARIABLE) {
					//when a new variable starts appearing we want to push the previus into the function-
					//parameters string.
					if (Current_Variable != "") {
						Parenthesis.push_back(Current_Variable);
						Current_Variable = "";
					}
					Current = "";
					if (Current_PreFix != "")
						Current_Variable = Current_PreFix + " ";
					Current_Variable += Find(Current_Complex_Name, &Current_IDS)->second + " ";
				}
				else if (Find(Current_Complex_Name, &Current_IDS)->first == MANGLER::POSTFIX) {

					Current = "";
					Current_Variable += Find(Current_Complex_Name, &Current_IDS)->second + " ";
				}
				else if (Find(Current_Complex_Name, &Current_IDS)->first == MANGLER::PREFIX) {
					if (Current_Variable != "") {
						Parenthesis.push_back(Current_Variable);
						Current_Variable = "";
					}

					Current = "";

					Current_PreFix += Find(Current_Complex_Name, &Current_IDS)->second + " ";
				}
				else if (Find(Current_Complex_Name, &Current_IDS)->first == MANGLER::RETURN) {
					//_rPh -> ptr char xxxx(xxxx)
					Return_Type_Section = true;
				}
			}
			//TODO: add that if the current complex name is bigger than 2(.., current num) then dont do this.
			else if (((raw[i] >= 48) && (raw[i] <= 57))) {
				string tmp = "";
				tmp += raw[i];
				for (int j = i + 1; j < raw.size(); j++) {
					if (((raw[j] >= 48) && (raw[j] <= 57)))
						tmp += (char)raw[j];
					else
						break;
				}
				int size = atoi(tmp.c_str());
				string name = "";
				for (int j = i + (int)tmp.size(); (j < (size + i + (int)tmp.size())) && j < (int)raw.size(); j++) {
					name += (char)raw[j];
				}
				if (Namespace) {
					Scope_Path.push_back(name);
				}
				else if (Func_Name) {
					Function = name;
					Func_Name = false;
				}
				else if (Return_Type_Section) {
					Return_Type += " " + name;
				}
				else {
					//class based parameters.
					if (Current_Variable != "") {
						Parenthesis.push_back(Current_Variable);
						Current_Variable = "";
					}

					Current_Variable = Current_PreFix + " " + name;
				}
				i += size + (int)tmp.size() - 1;
			}
			//else if (Current_Variable != "") {
			//	Parenthesis.push_back(Current_Variable);
			//}
		}
		if (Current_Variable != "") {
			if (Return_Type_Section)
				Return_Type += " " + Current_Variable;
			else
				Parenthesis.push_back(Current_Variable);
		}
		if (Return_Type != "")
			PreFix = "";
	}
	else {
		//this lauches when no call type is identifyed.
		Function = raw;
	}

	//if the return type only has ptr then add 'type' keyword for template returning
	if (Return_Type == "ptr")
		Return_Type = "type ptr";


	string Result = Return_Type + " " + STD + " ";

	if (Scope_Path.size() > 0 && Functoin_Name_Is_Before_End_Of_Namespace) {
		Function = Scope_Path.back();
		Scope_Path.pop_back();
	}

	for (auto s : Scope_Path)
		Result += s + ".";
	
	Result += Function + "( ";


	for (int i = 0; i < ((int)Parenthesis.size()) - 1; i++) {
		Result += Parenthesis[i] + ", ";
	}
	if (Parenthesis.size() > 0)
		Result += Parenthesis.back();
	Result += ")";
	return PreFix + Result;
}

vector<string> Classes;

string MANGLER::Mangle(Node* raw, string Force_Complex)
{
	string Result = "";

	if ((raw->is("vivid") != -1) || (raw->Scope->is("vivid") != -1) || Force_Complex == "vivid") {

		string STD = "vivid";
		if (raw->is(FUNCTION_NODE) || raw->is(IMPORT) || raw->is(PROTOTYPE)) {
			Classes.clear();
			Result = "_V";

			if (raw->Scope->is(CLASS_NODE) && raw->Scope->Name != "GLOBAL_SCOPE") {
				Result += "N";

				for (auto i : raw->Get_Scope_Path())
					Result += to_string(i->Name.size()) + i->Name;

				Result += to_string(raw->Name.size()) + raw->Name;

				Result += "E";
			}
			else if (raw->Fetcher != nullptr) {
				Result += "N";

				for (auto i : raw->Get_All_Fetchers())
					Result += to_string(i->Name.size()) + i->Name;


				Result += to_string(raw->Name.size()) + raw->Name;

				Result += "E";
			}
			else
				Result += to_string(raw->Name.size()) + raw->Name;


			if (raw->Parameters.size() < 1)
				Result += "v";

			for (auto i : raw->Parameters) {
				Result += Mangle(i, "vivid");
			}

			bool Mark_Return_Type = false;
			if (raw->Inheritted.size() > 0)
				for (auto i : raw->Inheritted) {
					if (Lexer::GetComponent(i).is(Flags::KEYWORD_COMPONENT)) {
						if (i == "ptr")
							Mark_Return_Type = true;
					}
					else
						Mark_Return_Type = true;
				}

			if (Mark_Return_Type)
				Result += "_r";

			for (auto i : raw->Inheritted) {
				if (Lexer::GetComponent(i).is(Flags::KEYWORD_COMPONENT)) {
					if (i == "ptr")
						Result += Get_Key(i, STD);
				}
				else if (Get_Key(i, STD) != "")
					Result += Get_Key(i, STD);
				else
					Result += to_string(i.size()) + i;
			}
		}
		else if (raw->is(CLASS_NODE)) {
			string p = "";
			string r;
			if (raw->is("ptr") != -1) {
				for (auto i : raw->Inheritted) {
					if (i == "ptr")
						p += "P";
				}
				r = p + r;
			}
			if (Is_Base_Type(raw)) {
				return p + Get_Key(raw->Name, STD);
			}
			else {
				if (Find_Classes(raw->Name) != -1) {
					stringstream stream;
					stream << hex << Find_Classes(raw->Name);
					r = "S" + string(stream.str()) + "_";
				}
				else
					r = to_string(raw->Name.size()) + raw->Name;
				return r;
			}
		}
		else if (raw->is(OBJECT_DEFINTION_NODE) || raw->is(OBJECT_NODE) || raw->is(PARAMETER_NODE)) {
			int I = 0;
			string p = "";
			if (raw->is("ptr") != -1) {
				for (auto i : raw->Inheritted) {
					if (i == "ptr")
						p += "P";
				}
			}
			for (auto i : raw->Inheritted) {
				if (!Lexer::GetComponents(i)[0].is(Flags::KEYWORD_COMPONENT))
					I++;
				if (I > 1) {
					//PcIic = char int char ptr a
					//Evie engine 3.0.0 cannot export multi inheritted variables yet.
					//TODO: Make that happen.
					throw::runtime_error("Exporting multi inheritted variables is not yet supported.");
				}
			}
			if (Is_Template(raw)) {
				//uugabuuga?
				Result = p + "t";
			}
			else if (Is_Based_On_Base_Type(raw)) {
				//int a;
				string Type = "";
				for (auto i : raw->Inheritted)
					if (!Lexer::GetComponents(i)[0].is(Flags::KEYWORD_COMPONENT))
						Type = i;
				Result = p + string(Type.data(), 1);
			}
			else {
				//banana a;
				string Type = "";
				for (auto i : raw->Inheritted)
					if (!Lexer::GetComponents(i)[0].is(Flags::KEYWORD_COMPONENT))
						Type = i;
				Result = p + to_string(Type.size()) + Type;
			}
		}

	}
	else if ((raw->is("evie") != -1) || (raw->Scope->is("evie") != -1)){
		//if the function call uses the Evie standard.
	}
	else if ((raw->is("plain") != -1) || (raw->Scope->is("plain") != -1)) {
		//generic name labels for normal .
		Result = raw->Name;
	}
	else /*((raw->is("cpp") != -1) || (raw->Scope->is("cpp") != -1) || Force_Complex == "cpp")*/ {
		//if the function call uses the C standard.
		//_import_func_cpp_internal_print__char__int to
		//_Z14internal_printPci
		if (raw->is(FUNCTION_NODE) || raw->is(IMPORT) || raw->is(PROTOTYPE)) {
			Classes.clear();
			Result = "_Z";

			if (raw->Scope->is(CLASS_NODE) && raw->Scope->Name != "GLOBAL_SCOPE") {
				Result += "N";

				for (auto i : raw->Get_Scope_Path())
					Result += to_string(i->Name.size()) + i->Name;

				Result += to_string(raw->Name.size()) + raw->Name;

				Result += "E";
			}
			else if (raw->Fetcher != nullptr) {
				Result += "N";

				for (auto i : raw->Get_All_Fetchers())
					Result += to_string(i->Name.size()) + i->Name;


				Result += to_string(raw->Name.size()) + raw->Name;

				Result += "E";
			}
			else
				Result += to_string(raw->Name.size()) + raw->Name;


			if (raw->Parameters.size() < 1)
				Result += "v";

			for (auto i : raw->Parameters) {
				Result += Mangle(i, "cpp");
			}
		}
		else if (raw->is(CLASS_NODE)) {
			string p = "";
			string r;
			if (raw->is("ptr") != -1) {
				for (auto i : raw->Inheritted) {
					if (i == "ptr")
						p += "P";
				}
				r = p + r;
			}
			if (Is_Base_Type(raw)) {
				return p + string(raw->Name.data(), 1);
			}
			else {
				if (Find_Classes(raw->Name) != -1) {
					stringstream stream;
					stream << hex << Find_Classes(raw->Name);
					r = "S" + string(stream.str()) + "_";
				}
				else
					r = to_string(raw->Name.size()) + raw->Name;
				return r;
			}
		}
		else if (raw->is(OBJECT_DEFINTION_NODE) || raw->is(OBJECT_NODE) || raw->is(PARAMETER_NODE)) {
			int I = 0;
			string p = "";
			if (raw->is("ptr") != -1) {
				for (auto i : raw->Inheritted) {
					if (i == "ptr")
						p += "P";
				}
			}
			for (auto i : raw->Inheritted) {
				if (!Lexer::GetComponents(i)[0].is(Flags::KEYWORD_COMPONENT))
					I++;
				if (I > 1) {
					//PcIic = char int char ptr a
					//Evie engine 3.0.0 cannot export multi inheritted variables yet.
					//TODO: Make that happen.
					throw::runtime_error("Exporting multi inheritted variables is not yet supported.");
				}
			}
			if (Is_Template(raw)) {
				//uugabuuga?
				Result = p + "t";
			}
			else if (Is_Based_On_Base_Type(raw)) {
				//int a;
				string Type = "";
				for (auto i : raw->Inheritted)
					if (!Lexer::GetComponents(i)[0].is(Flags::KEYWORD_COMPONENT))
						Type = i;
				Result = p + string(Type.data(), 1);
			}
			else {
				//banana a;
				string Type = "";
				for (auto i : raw->Inheritted)
					if (!Lexer::GetComponents(i)[0].is(Flags::KEYWORD_COMPONENT))
						Type = i;
				Result = p + to_string(Type.size()) + Type;
			}
		}

	}
	return Result;
}

string MANGLER::Get_Function_Name(string func)
{	//int ptr Start_Test()
	int Paranthesis_Index = func.find_first_of('(');
	int Name_Index = func.substr(0, Paranthesis_Index).find_last_of(" ") + 1;
	return func.substr(Name_Index, Paranthesis_Index - Name_Index);
}

bool MANGLER::Is_Base_Type(Node* n)
{
	if (n->is(NUMBER_NODE) || n->is(OPERATOR_NODE) || n->is(ASSIGN_OPERATOR_NODE) || n->is(CONDITION_OPERATOR_NODE) || n->is(BIT_OPERATOR_NODE) || n->is(ARRAY_NODE) || n->is(CALL_NODE))
		return false;
	bool Result = true;
	for (auto i : n->Childs) {
		if (i->Name == "size" && i->is("const") != -1)
			continue;
		else if (i->Name == "format" && i->is("const") != -1)
			continue;
		Result = false;	//because base types do not have any other member other than the Size.
		break;
	}
	
	for (auto i : n->Inheritted) {
		if (Lexer::GetComponents(i)[0].is(Flags::KEYWORD_COMPONENT))
			continue;
		Result = false;	//because base types do not inherit other classes, only features.
		break;
	}
	return Result;
}

bool MANGLER::Is_Based_On_Base_Type(Node* n)
{
	bool Result = true;
	//int a;
	for (auto i : n->Inheritted) {
		if (Lexer::GetComponents(i)[0].is(Flags::KEYWORD_COMPONENT))
			continue;
		if (!Is_Base_Type(n->Find(i, n->Scope)))
			Result = false;
	}
	return Result;
}

bool MANGLER::Is_Template(Node* n)
{
	bool Result = true;
	for (auto i : n->Inheritted)
		if (!Lexer::GetComponents(i)[0].is(Flags::KEYWORD_COMPONENT)) {
			Result = false;
			break;
		}
	return Result;
}

int MANGLER::Find_Classes(string s)
{
	for (int i = 0; i < Classes.size(); i++)
		if (Classes[i] == s)
			return i;
	Classes.push_back(s);
	return -1;
}

void MANGLER::Add_ID(string Lang, pair<string, pair<int, string>> id) {
	if (Find_STD_List(Lang) == nullptr) {
		IDS.push_back(pair<string, vector<pair<string, pair<int, string>>>>());
		IDS.back().first = Lang;
	}

	if (Find(id.first, Find_STD_List(Lang)) != nullptr) {
		cout << "Warning: ID " << id.first << " already exist's" << endl;
		return;
	}
	else
		Find_STD_List(Lang)->push_back(id);
}

string MANGLER::Get_Key(string Val, string Lang)
{
	if (!Lexer::GetComponent(Val).is(Flags::KEYWORD_COMPONENT))
		if (Is_Base_Type(Global_Scope->Find(Val))) {
			string New_Val = to_string(Global_Scope->Find(Val)->Size) + " " + Global_Scope->Find(Val)->Format;
			Val = New_Val;
		}

	for (auto i : *Find_STD_List(Lang)) {
		if (i.second.second == Val)
			return i.first;
	}
	return "";
}

vector<pair<string, pair<int, string>>>* MANGLER::Find_STD_List(string Lang)
{
	for (auto& i : IDS) {
		if (i.first == Lang)
			return &i.second;
	}
	return nullptr;
}

pair<int, string>* MANGLER::Find(string Key, vector<pair<string, pair<int, string>>>* Current_IDS)
{
	for (auto& i : *Current_IDS)
		if (i.first == Key)
			return &i.second;

	return nullptr;
}

void MANGLER::Clear_Class_Zipping_List()
{
	Classes.clear();
}



C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Cpp\Docker\OBJ.cpp" 
#include "../../H/Docker/OBJ.h"

void OBJ::OBJ_Analyser(vector<string>& Output) {
	return;
}
C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Cpp\Docker\TXT.cpp" 
#include "../../H/Docker/TXT.h"

void TXT::TXT_Analyzer(vector<string>& Output)
{
	ifstream file(DOCKER::Working_Dir.back().second + DOCKER::FileName.back(), std::ios::binary);

	if (!file.is_open()) {
		throw::runtime_error("FILE NOT FOUND!");
	}
	file.seekg(0, ios_base::end);
	long long size = file.tellg();
	char* Buffer = new char[size + 1];
	file.seekg(0, ios_base::beg);
	file.read(Buffer, size);
	Buffer[size] = '\0';
	file.close();
	Output.push_back(string(Buffer));
	return;
}

vector<string> TXT::Unwrap(string raw)
{
	vector<string> Result;
	for (auto i : Lexer::GetComponents(raw)) {
		Result.push_back(i.Value);
	}
	return Result;
}

C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Cpp\Lexer\Component.cpp" 
#include "../../H/Lexer/Component.h"
#include "../../H/Lexer/Lexer.h"
#include "../../H/Nodes/Node.h"

Component* Component::Copy_Component() {
    Component* Result = new Component(*this);

    if (Result->node)
        Result->node = Result->node->Copy_Node(Result->node, Result->node->Scope);

    for (auto& i : Result->Components)
        i = *i.Copy_Component();

    return Result;
}
C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Cpp\Lexer\Lexer.cpp" 
//
//
//
//  Made by Joonas Lehto at 10/5/2020 0:47AM
//  Few fixes by Gabe at 10/5/2020 0:47:00001AM
//
//
//
#include "../../H/Lexer/Lexer.h"
#include <stdexcept>
#include <sstream>
#include <optional>
#include <algorithm>
#include <fstream>
#include <cmath>
#include "../../H/UI/Safe.h"
#include "../../H/UI/Usr.h"

constexpr char LineEnding = '\n';
constexpr char BITWISE_XOR = '\xa4';

extern Usr* sys;

char Lexer::SingleLineCommentIdentifier = 0;
char Lexer::StringIdentifier = 0;
char Lexer::DecimalSeparator = 0;
char Lexer::ExponentSeparator = 0;

vector<string> Lexer::Operators;
vector<string> Lexer::Keywords;

enum class Type
{
    UNSPECIFIED,
    TEXT,
    COMMENT,
    NUMBER,
    PARENTHESIS,
    OPERATOR,
    STRING,
    HEXADECIMAL,
    END
};

struct Area
{
    Type Type = Type::UNSPECIFIED;

    string Text;

    Position Start;
    Position End;
};

template <typename T>
bool Exists(const vector<T> &source, const T &value)
{
    return find(source.begin(), source.end(), value) != source.end();
}

char GetParenthesisClosing(char opening, Position p)
{
    if (opening == '(')
    {
        return ')';
    }
    if (opening == '[')
    {
        return ']';
    }
    if (opening == '{')
    {
        return '}';
    }

    Report(Observation(ERROR, "Unrecognized parenthesis opening '" + opening + (string)"'", p));
}

/// <summary>
/// Returns all the characters which can mix with the specified character.
/// If this function returns null, it means the specified character can mix with any character.
/// </summary>
const char* GetMixingCharacters(char c)
{
    switch (c)
    {
        case '.': return ".0123456789";
        case ',': return "";
        case ':': return "";
        case '<': return "=";
        case '>': return "=-";
        default: return nullptr;
    }
}

/// <summary>
/// Returns whether the two specified characters can mix
/// </summary>
bool Mixes(char a, char b)
{
    auto x = GetMixingCharacters(a);
    if (x != nullptr) return strchr(x, b) != nullptr;

    auto y = GetMixingCharacters(b);
    if (y != nullptr) return strchr(y, a) != nullptr;

    return true;
}

bool IsOperator(char c)
{
    return ((c >= 33 && c <= 47) || (c >= 58 && c <= 64) || c == '^' || c == '|' || c == BITWISE_XOR) && c != Lexer::SingleLineCommentIdentifier && c != Lexer::StringIdentifier ;
}

bool IsStartOfHexadecimal(char current, char next)
{
    return current == '0' && next == 'x';
}

bool IsDigit(char c)
{
    return c >= '0' && c <= '9';
}

bool IsText(char c)
{
    return c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z' || c == '_' || c == '@';
}

bool IsParenthesis(char c)
{
    return c == '(' || c == '[' || c == '{' || c == ')' || c == ']' || c == '}';
}

bool IsComment(char c)
{
    return c == Lexer::SingleLineCommentIdentifier;
}

bool IsString(char c)
{
    return c == Lexer::StringIdentifier;
}

Type GetType(char current, char next)
{
    if (IsText(current)) return Type::TEXT;
    if (IsStartOfHexadecimal(current, next)) return Type::HEXADECIMAL;
    if (IsDigit(current))  return Type::NUMBER;
    if (IsParenthesis(current)) return Type::PARENTHESIS;
    if (IsOperator(current)) return Type::OPERATOR;
    if (IsComment(current)) return Type::COMMENT;
    if (IsString(current)) return Type::STRING;
    if (current == LineEnding) return Type::END;

    return Type::UNSPECIFIED;
}

bool IsPartOf(Type previous_type, Type current_type, char previous, char current, char next)
{
    // Ensure the previous and the current character mix
    if (!Mixes(previous, current)) return false;

    if (current_type == previous_type || previous_type == Type::UNSPECIFIED) return true;

    switch (previous_type)
    {

    case Type::TEXT: return current_type == Type::NUMBER;

    case Type::HEXADECIMAL: return current_type == Type::NUMBER || 
            (previous == '0' && current == 'x') ||
            (current >= 'a' && current <= 'f') || (current >= 'A' && current <= 'F');

    case Type::NUMBER:
    {
        return (current == Lexer::DecimalSeparator && IsDigit(next)) || // Example: 7.0
               current == Lexer::ExponentSeparator || // Example: 100e0
               (previous == Lexer::ExponentSeparator && (current == '+' || current == '-')); // Examples: 3.14159e+10, 10e-10
    }

    default:
        return false;
    }
}

Position SkipSpaces(const string &text, Position &position)
{
    while (position.GetLocal() < text.size())
    {
        char current = text[position.GetLocal()];
        if (current != ' ') break;

        position.NextCharacter();
    }

    return position;
}

Position SkipComment(const string& text, const Position& start)
{
    int i = (int)text.find(LineEnding, start.GetLocal());

    if (i != -1)
    {
        int length = i - start.GetLocal();
        return Position(start.GetLine(), start.GetCharacter() + length, start.GetLocal() + length, i).NextLine();
    }
    int length = (int)text.size() - start.GetLocal();
    return Position(start.GetLine(), start.GetCharacter() + length, start.GetLocal() + length, (int)text.size());
}

Position SkipString(const string &text, const Position &start)
{
    int i = (int)text.find(Lexer::StringIdentifier, (size_t)start.GetLocal() + 1);
    int j = (int)text.find(LineEnding, (size_t)start.GetLocal() + 1);

    if (i == -1 || j != -1 && j < i)
    {
        MSG_Type Terminate = ERROR;

        if (sys->Info.Is_Service) Terminate = WARNING;

        Report(Observation(Terminate, "Couldn't find the end of the string", start));
    }

    int length = i + 1 - start.GetLocal();

    return Position(start.GetLine(), start.GetCharacter() + length, start.GetLocal() + length, i + 1);
}

Position SkipParenthesis(const string &text, const Position &start)
{
    Position position = start.Clone();

    char opening = text[position.GetLocal()];
    char closing = GetParenthesisClosing(opening, start);

    int count = 0;

    while (position.GetLocal() < text.size())
    {
        char current = text[position.GetLocal()];

        if (current == LineEnding)
        {
            position.NextLine();
        }
        else if (current == Lexer::SingleLineCommentIdentifier)
        {
            position = SkipComment(text, position);
        }
        else if (current == Lexer::StringIdentifier)
        {
            position = SkipString(text, position);
        }
        else
        {
            if (current == opening) { count++; }
            else if (current == closing) { count--; }

            position.NextCharacter();
        }

        if (count == 0) return position;
    }

    MSG_Type Terminate = ERROR;

    if (sys->Info.Is_Service) Terminate = WARNING;

    Report(Observation(Terminate, "Couldn't find closing parenthesis", start));
}

optional<Area> GetNextComponent(const string &text, Position start)
{
    // Firsly the spaces must be skipped to find the next token
    Position position = SkipSpaces(text, start);

    // Verify there's text to iterate
    if (position.GetLocal() == text.size()) return nullopt;

    char current = text[position.GetLocal()];
    char next = position.Local + 1 < text.size() ? text[position.GetLocal() + 1] : (char)0;

    Area area;
    area.Start = position.Clone();
    area.Type = GetType(current, next);

    switch (area.Type)
    {

    case Type::COMMENT:
    {
        area.End = SkipComment(text, area.Start);
        area.Text = text.substr(area.Start.GetLocal(), (size_t)area.End.GetLocal() - area.Start.GetLocal());
        return area;
    }

    case Type::PARENTHESIS:
    {
        area.End = SkipParenthesis(text, area.Start);
        area.Text = text.substr(area.Start.GetLocal(), (size_t)area.End.GetLocal() - area.Start.GetLocal());
        return area;
    }

    case Type::END:
    {
        area.End = position.Clone().NextLine();
        area.Text = "\n";
        return area;
    }

    case Type::STRING:
    {
        area.End = SkipString(text, area.Start);
        area.Text = text.substr(area.Start.GetLocal(), (size_t)area.End.GetLocal() - area.Start.GetLocal());
        return area;
    }

    default:
        break;
    }

    position.NextCharacter();

    // Possible types are now: TEXT, NUMBER, OPERATOR
    while (position.GetLocal() < text.size())
    {
        char previous = current;
        current = next;
        next = position.GetLocal() + 1 < text.size() ? text[position.GetLocal() + 1] : (char)0;

        if (IsParenthesis(current)) break;

        // Determine what area type the current character represents
        Type type = GetType(current, next);

        if (!IsPartOf(area.Type, type, previous, current, next)) break;

        position.NextCharacter();
    }

    area.End = position;
    area.Text = text.substr(area.Start.GetLocal(), (size_t)area.End.GetLocal() - area.Start.GetLocal());

    return area;
}

Component ParseTextComponent(string text)
{
    if (Exists(Lexer::Operators, text))
    {
        return Component(text, Flags::OPERATOR_COMPONENT);
    }
    if (Exists(Lexer::Keywords, text))
    {
        return Component(text, Flags::KEYWORD_COMPONENT);
    }
    return Component(text, Flags::TEXT_COMPONENT);
}

optional<int> TryParseInt(string text)
{
    try
    {
        return stoi(text);
    }
    catch (...)
    {
        return nullopt;
    }
}

optional<int64_t> TryParseLong(string text)
{
    try
    {
        return stoll(text);
    }
    catch (...)
    {
        return nullopt;
    }
}

optional<double> TryParseDouble(string text)
{
    try
    {
        return stod(text);
    }
    catch (...)
    {
        return nullopt;
    }
}

string GetNumberPart(string text)
{
    int end = 0;

    for (; end < text.size() && (IsDigit(text[end]) || text[end] == Lexer::DecimalSeparator); end++);

    return text.substr(0, end);
}

int GetExponent(const string& text, Position p)
{
    int exponent_start = (int)text.find(Lexer::ExponentSeparator);

    if (exponent_start == -1)
    {
        return 0;
    }
    exponent_start++;

    int index = exponent_start;

    // Ensure that there's the exponent value
    if (index == text.size())
    {
        MSG_Type Terminate = ERROR;

        if (sys->Info.Is_Service) Terminate = WARNING;
        Report(Observation(Terminate, "Invalid number exponent '" + text + "'", p));
    }

    // Skip the potential exponent sign
    if (text[(size_t)index + 1] == '+' || text[(size_t)index + 1] == '-')
    {
        index++;

        // Ensure that there's the exponent value
        if (index == text.size())
        {
            MSG_Type Terminate = ERROR;

            if (sys->Info.Is_Service) Terminate = WARNING;
            Report(Observation(Terminate, "Invalid number exponent '" + text + "'", p));
        }
    }

    int exponent_end = index;

    // Get the exponent value's end index
    for (; exponent_end < text.size() && IsDigit(text[exponent_end]); exponent_end++);

    if (auto exponent = TryParseInt(text.substr(exponent_start, exponent_end)))
    {
        return exponent.value();
    }
    Report(Observation(ERROR, "Invalid number exponent '" + text + "'", p));
}

bool IsDecimal(string text)
{
    return text.find(Lexer::DecimalSeparator) != -1;
}

Component CreateNumberComponent(string text, const Position& position)
{
    int exponent = GetExponent(text, position);
    string number_part = GetNumberPart(text);

    if (IsDecimal(text))
    {
        if (auto number = TryParseDouble(number_part))
        {
            double value = number.value() * pow((long double)10.0, (long double)exponent);

            return Component(to_string(value), Flags::NUMBER_COMPONENT);
        }
        string s = "Invalid decimal number '" + text + "'";
        Report(Observation(ERROR, s, position));
    }
    else
    {
        if (auto number = TryParseLong(number_part))
        {
            int64_t value = number.value() * (int64_t)pow(10.0, exponent);

            return Component(to_string(value), Flags::NUMBER_COMPONENT);
        }
        string s = "Invalid integer number '" + text + "'";

        Report(Observation(ERROR, s, position));
    }
}

vector<Component> GetComponents(string text, Position anc);

Component CreateParenthesisComponent(string text, Position position)
{
    Component component(text, Flags::PAREHTHESIS_COMPONENT);
    component.Components = GetComponents(text.substr(1, text.size() - 2), position.NextCharacter());

    return component;
}

unsigned long long ParseHexadecimal(const Area& area)
{
    char* end;
    auto text = area.Text.c_str() + 2;
    auto value = strtoull(text, &end, 16);

    if (*end != 0)
    {
        string s = "Invalid hexadecimal number '" + area.Text + "'";
        Report(Observation(ERROR, s, area.Start));
    }

    return value;
}

Component ParseComponent(const Area& area)
{
    switch (area.Type)
    {
    case Type::TEXT:
        return ParseTextComponent(area.Text);
    case Type::NUMBER:
        return CreateNumberComponent(area.Text, area.Start);
    case Type::OPERATOR:
        return Component(area.Text, Flags::OPERATOR_COMPONENT);
    case Type::PARENTHESIS:
        return CreateParenthesisComponent(area.Text, area.Start);
    case Type::END:
        return Component("\n", Flags::END_COMPONENT);
    case Type::STRING:
        return Component(area.Text, Flags::STRING_COMPONENT);
    case Type::COMMENT:
        return Component(area.Text, Flags::COMMENT_COMPONENT);
    case Type::HEXADECIMAL:
        return Component(to_string(ParseHexadecimal(area)), Flags::NUMBER_COMPONENT);
    default:
    {
        string s = "Unrecognized token '" + area.Text + "'";

        Report(Observation(ERROR, s, area.Start));
    }

    }
}

vector<Component> GetComponents(string text, Position anchor)
{
    vector<Component> components;
    Position position(anchor.GetLine(), anchor.GetCharacter(), 0, anchor.GetAbsolute());

    replace(text.begin(), text.end(), '\t', ' ');
    replace(text.begin(), text.end(), '\r', ' ');

    while (position.GetLocal() < text.size())
    {
        optional<Area> area = GetNextComponent(text, position);

        if (!area) break;

        Component component = ParseComponent(area.value());
        component.Location = area->Start;
        components.push_back(component);
        
        position = area->End;
    }

    return components;
}

vector<Component> Lexer::GetComponents(string text)
{
    return GetComponents(text, Position());
}

Component Lexer::GetComponent(string text)
{
    Position position(0, 0, 0, 0);

    replace(text.begin(), text.end(), '\t', ' ');
    replace(text.begin(), text.end(), '\r', ' ');

    optional<Area> area = GetNextComponent(text, position);

    if (!area)
    {
        MSG_Type Terminate = ERROR;

        if (sys->Info.Is_Service) Terminate = WARNING;
        Report(Observation(Terminate, "Could not generate component from string '" + text + "'.", position));
    }

    Component component = ParseComponent(area.value());
    component.Location = area->Start;

    return component;
}

vector<Component> Lexer::GetComponentsFromFile(string file)
{
    if (Lexer::SingleLineCommentIdentifier == 0 || Lexer::StringIdentifier == 0 || Lexer::DecimalSeparator == 0 || Lexer::ExponentSeparator == 0)
    {
        Report(Observation(ERROR, "Please configure all the identifiers and separators needed by the lexer", Position()));
    }

    ifstream stream(file);

    if (!stream.is_open())
    {
        stringstream message;
        Report(Observation(ERROR, "Couldn't find or open file '" + file + "'", Position()));
    }

    string text;
    string line;

    while (getline(stream, line))
    {
        replace(line.begin(), line.end(), '\t', ' ');
        replace(text.begin(), text.end(), '\r', ' ');
        text += line + LineEnding;
    }

    stream.close();

    return GetComponents(text);
}
C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Cpp\Lexer\Position.cpp" 
#include "../../H/Lexer/Position.h"
#include <vector>
#include <string>

#include "../../H/Docker/Docker.h"

using namespace std;

string* FileName = new string("No File");

Position::Position(int line, int character, int local, int absolute)
{
	Line = line;
	Character = character;
	Local = local;
	Absolute = absolute;
	File_Name = FileName->c_str();
}

int Position::GetFileIndex()
{
	for (int i = 0; i < DOCKER::Included_Files.size(); i++)
		if (DOCKER::Included_Files[i] == File_Name)
			return i;
}

C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Cpp\Nodes\Node.cpp" 
#include "../../H/Nodes/Node.h"
#include "../../H/Nodes/Token.h"
#include "../../H/Parser/Algebra.h"
#include "../../H/Docker/Mangler.h"
#include "../../H/UI/Safe.h"
#include "../../H/UI/Usr.h"

#include <vector>
#include <string>
#include <climits>

extern Usr* sys;

using namespace std;

void Node::Update_Defined_Stack_Offsets()
{
	//skip the returnin address.
	int Parameter_Offset = 8;
	int Local_Offset = 0;
	//first conmpute all the memory locaitions.
	for (auto& i : Defined) {
		if (i->is(OBJECT_NODE) || i->is(OBJECT_DEFINTION_NODE)) {
			//every local variable is defined default as a value in a register.
			if (i->Requires_Address) {
				i->Memory_Offset = Local_Offset/* + Size_of_Call_Space*/;
				Local_Offset += i->Get_Size();
			}
		}
		if (i->is(PARAMETER_NODE)) {
			if (Token(i, true).is(TOKEN::REGISTER)) {
				//This happends when the parameter would be in a register but its in debug, so it uses stack
				//we need to tell the system that it CAN use the Local_Offset as storing the parameter
				i->Memory_Offset = Local_Offset/* + Size_of_Call_Space*/;
				Local_Offset += i->Get_Size();
			}
			else if (!Token(i).is(TOKEN::REGISTER)) {
				//the parameters locate below the local variable space and the returning address 
				//also, do remeber that, the pushes that the code needs for the nonvolatiles
				//those come before the parameter space.
				i->Memory_Offset = Parameter_Offset/* + Size_of_Call_Space*/;
				Parameter_Offset += i->Get_Size();
			}
		}
	}
}

Variable_Descriptor::Variable_Descriptor(Node* v, int i, vector<Node*> source) {
	Define_Index = i;
	Var = v;

	vector<Node*> Linear_Ast = v->Get_all({OBJECT_DEFINTION_NODE, OBJECT_NODE, PARAMETER_NODE});
	//for complex inlinings
	for (int n = i; n < source.size(); n++) {
		if (source[n]->is(ASSIGN_OPERATOR_NODE) || source[n]->is(POSTFIX_NODE)) {
			for (auto c : Linear_Ast) {
				if (source[n]->Left->Name == c->Name) {
					Expiring_Index = n;
					goto Stop;
				}
			}
		}
		if (source[n]->is(PREFIX_NODE)) {
			for (auto c : Linear_Ast) {
				if (source[n]->Right->Name == c->Name) {
					Expiring_Index = n;
					goto Stop;
				}
			}
		}
		if (source[n]->is(CALL_NODE)) {
			for (auto c : Linear_Ast) {
				for (auto p : source[n]->Function_Implementation->Parameters) {
					if (p->is("ptr") != -1)
						if (p->Name == c->Name) {
							Expiring_Index = n;
							goto Stop;
						}
				}
			}
		}
		Expiring_Index = n;
	}
Stop:;
}

vector<string> Node::Get_Inheritted(bool Skip_Prefixes, bool Get_Name, bool Skip_Keywords) {
	vector<string> Result;
	if (MANGLER::Is_Base_Type(this) || Get_Name) {
		return { Name };
	}
	else if (is(NUMBER_NODE)) {
		//1.29348
		if (find(Name.begin(), Name.end(), '.') != Name.end()) {
			if ((Name.end() - find(Name.begin(), Name.end(), '.')) <= 7)
				return Find(4, Global_Scope, "decimal")->Get_Inheritted(Skip_Prefixes, true);
			else
				return Find(8, Global_Scope, "decimal")->Get_Inheritted(Skip_Prefixes, true);
		}
		else {
			if (atoll(Name.c_str()) > INT_MAX) {
				return Find(8, Global_Scope, "integer")->Get_Inheritted(Skip_Prefixes, true);
			}
			return Find(4, Global_Scope, "integer")->Get_Inheritted(Skip_Prefixes, true);
		}
	}
	else {
		for (int i = 0; i < Inheritted.size(); i++) {
			if (Skip_Prefixes && ((Inheritted[i] == "ptr") || (Inheritted[i] == "ref")))
				continue;
			if (Skip_Keywords && Lexer::GetComponent(Inheritted[i]).is(::Flags::KEYWORD_COMPONENT) && Inheritted[i] != "ptr")
				continue;
			Result.push_back(Inheritted[i]);
		}
		return Result;
	}
}

string Node::Get_Inheritted(string seperator, bool Skip_Prefixes, bool Get_Name, bool skip_keywords) {
	if (MANGLER::Is_Base_Type(this) || Get_Name) {
		return seperator + Name;
	}
	else if (is(NUMBER_NODE) && Cast_Type == nullptr) {
		//1.29348
		if (find(Name.begin(), Name.end(), '.') != Name.end()) {
			if ((Name.end() - find(Name.begin(), Name.end(), '.')) <= 7)
				return Find(4, Global_Scope, "decimal")->Get_Inheritted(seperator, Skip_Prefixes, true);
			else
				return Find(8, Global_Scope, "decimal")->Get_Inheritted(seperator,  Skip_Prefixes, true);
		}
		else {
			if (atoll(Name.c_str()) > INT_MAX) {
				return Find(8, Global_Scope, "integer")->Get_Inheritted(seperator, Skip_Prefixes, true);
			}
			return Find(4, Global_Scope, "integer")->Get_Inheritted(seperator, Skip_Prefixes, true);
		}
	}
	else if (is(NUMBER_NODE) && Cast_Type != nullptr) {
		if (Cast_Type != nullptr)
			return seperator + Cast_Type->Name;
	}
	else {
		string result = "";
		for (int i = 0; i < Inheritted.size(); i++) {
			if (Skip_Prefixes && ((Inheritted[i] == "ptr") || (Inheritted[i] == "ref")))
				continue;
			else if (skip_keywords && Lexer::GetComponents(Inheritted[i])[0].is(Flags::KEYWORD_COMPONENT))
				continue;
			result += seperator + Inheritted[i];
		}
		if (Cast_Type != nullptr)
			result = seperator + Cast_Type->Name;
		return result;
	}
}

int Node::Calculate_Inheritted_Distance(Node* Val, Node* Loader, string type)
{
	int Val_Ptr_Count = Val->Get_All(type);
	int Loader_Ptr_Count = Loader->Get_All(type);

	//if there is ptr involved					&& if the ptr distance is more than 1 
	if ((Val_Ptr_Count + Loader_Ptr_Count > 0) && (abs(Val_Ptr_Count - Loader_Ptr_Count) > 2)) {
		if (Loader_Ptr_Count > Val_Ptr_Count && type == "ptr") {
			//this means that the Loader ptr count is greter than the Val ptr by *2
			Report(Observation(ERROR, "Cannot wrap " + Val->Name + to_string(abs(Val_Ptr_Count - Loader_Ptr_Count)) + " times into " + Loader->Name, *Val->Location));
		}
	}

	return abs(Val_Ptr_Count - Loader_Ptr_Count);
}

Node* Node::Find_Scope(Node* n)
{
	Node* Current_Scope = n->Scope;
	vector<Node*> Fetchers = n->Get_All_Fetchers();

	reverse(Fetchers.begin(), Fetchers.end());

	while (true) {
		for (auto& i : Current_Scope->Defined) {
			if (Fetchers.back()->Name == i->Name) {
				Current_Scope = i;
				Fetchers.pop_back();
			}
			if (Fetchers.size() == 0)
				break;
		}

		if (Fetchers.size() == 0)
			break;
		if (Current_Scope->Scope == nullptr)
			return nullptr;

		Current_Scope = Current_Scope->Scope;
	}

	return Current_Scope;
}

Node* is(Node* Result) {
	if (Result) {
		return Result;
	}

	//out of bounds
	else if (Result == nullptr) {
		return 0;
	}
}

#define TOO_BIG (Node*)1

#define TOO_SMOLL nullptr

//this algorithm is optimized by starting from low-hi.
//because this system ingnores automatically if the node is already beoynd the line and character number.
//Returns 1 if not found and returns 0 if the node is beyond the location.
vector<Node*> Find_Trace;
Node* Node::Find(Position& location)
{
	for (int j = 0; j < Find_Trace.size(); j++) {
		if (this == Find_Trace[j]) {
			return TOO_BIG;
		}
	}

	Find_Trace.push_back(this);

	if (Location->GetAbsolute() > location.GetAbsolute()) {
		Find_Trace.pop_back();
		return TOO_BIG;
	}
	else if (Location->GetAbsolute() < location.GetAbsolute()) {

		vector<Node*> Defined_Reversed = Defined;

		::sort(Defined_Reversed.begin(), Defined_Reversed.end(), [](Node* a, Node* b) { 
			return ((a->Location->GetFileIndex() > b->Location->GetFileIndex())
				|| (a->Location->GetFileIndex() == b->Location->GetFileIndex()
					&& a->Location->GetLine() > b->Location->GetLine()
					));

			//!((file1 > file2) || (file1 == file2 && line1 > line))
		});

		/*return += { 
			reverse(Defined.begin(), Defined.end());
		}*/
		for (auto& i : Defined_Reversed) {
			Node* Result = i->Find(location);

			if (Result == TOO_BIG)
				continue;

			else if (Result == TOO_SMOLL)
				break;	//we have gone over the result

			else {
				Find_Trace.pop_back();
				return Result;
			}
		}

		vector<Node*> Childs_Reversed = Childs; 
		
		::sort(Childs_Reversed.begin(), Childs_Reversed.end(), [](Node* a, Node* b) {
			return ((a->Location->GetFileIndex() > b->Location->GetFileIndex())
				|| (a->Location->GetFileIndex() == b->Location->GetFileIndex()
					&& a->Location->GetLine() > b->Location->GetLine()
					));

			//!((file1 > file2) || (file1 == file2 && line1 > line))
			});

		for (auto& i : Childs_Reversed) {
			Node* Result = i->Find(location);

			if (Result == TOO_BIG)
				continue;

			else if (Result == TOO_SMOLL)
				break;	//we have gone over the result

			else {
				Find_Trace.pop_back();
				return Result;
			}
		}

		vector<Node*> Parameter_Reversed = Parameters;
		reverse(Parameter_Reversed.begin(), Parameter_Reversed.end());

		for (auto& i : Parameter_Reversed) {
			Node* Result = i->Find(location);

			if (Result == TOO_BIG)
				continue;

			else if (Result == TOO_SMOLL)
				break;	//we have gone over the result

			else {
				Find_Trace.pop_back();
				return Result;
			}
		}

		if (Left) {
			Node* Result = Left->Find(location);

			if (Result != TOO_BIG && Result != TOO_SMOLL) {
				Find_Trace.pop_back();
				return Result;
			}
		}
		if (Right) {
			Node* Result = Right->Find(location);

			if (Result != TOO_BIG && Result != TOO_SMOLL) {
				Find_Trace.pop_back();
				return Result;
			}
		}
		if (Fetcher) {
			Node* Result = Fetcher->Find(location);

			if (Result != TOO_BIG && Result != TOO_SMOLL) {
				Find_Trace.pop_back();
				return Result;
			}
		}
		if (Cast_Type) {
			Node* Result = Cast_Type->Find(location);

			if (Result != TOO_BIG && Result != TOO_SMOLL) {
				Find_Trace.pop_back();
				return Result;
			}
		}
	}
	else {
		Find_Trace.pop_back();
		return this;
	}

	Find_Trace.pop_back();
	return TOO_SMOLL;
}

Node* Node::Find_Template(Node* T)
{
	for (auto i : Templates)
		if (i->Name == T->Name)
			return i;

	for (auto i : Inheritable_templates)
		if (i->Name == T->Name)
			return i;

	if (Scope)
		return Scope->Find_Template(T);

	return nullptr;
}

Node* Node::Find_Template(string T)
{
	for (auto i : Templates)
		if (i->Name == T)
			return i;

	for (auto i : Inheritable_templates)
		if (i->Name == T)
			return i;

	if (Scope)
		return Scope->Find_Template(T);

	return nullptr;
}

bool Node::Compare_Fetchers(Node* other)
{
	string This_Fethcers = "";
	for (auto i : Get_All_Fetchers()) {
		if (Find(i, Scope, CLASS_NODE) || (Scope->Name == i->Name && Scope->is(CLASS_NODE)))
			This_Fethcers += i->Name;
		else
			This_Fethcers += i->Get_Inheritted("", false, false, false);

		//multi dimensional templates are disabled
		for (auto j : i->Templates)
			This_Fethcers += j->Name;
	}
	if (this->Fetcher == nullptr)
		if (this->Has({ FUNCTION_NODE, CALL_NODE }))
			This_Fethcers += this->Name;

	string Other_Fethcers = "";
	for (auto i : other->Get_All_Fetchers()) {
		if (Find(i, Scope, CLASS_NODE) || (Scope->Name == i->Name && Scope->is(CLASS_NODE)))
			Other_Fethcers += i->Name;
		else
			Other_Fethcers += i->Get_Inheritted("", false, false, false);

		for (auto j : i->Templates)
			Other_Fethcers += j->Name;
	}
	if (other->Fetcher == nullptr)
		if (other->Has({ FUNCTION_NODE, CALL_NODE }))
			Other_Fethcers += other->Name;

	if (This_Fethcers == Other_Fethcers)
		return true;
	return false;
}

vector<Node*> Node::Get_All_Fetchers()
{
	vector<Node*> Result;
	if (Fetcher != nullptr) {
		vector<Node*> tmp = Fetcher->Get_All_Fetchers();
		Result.insert(Result.end(), tmp.begin(), tmp.end());
		Result.push_back(Fetcher);
	}
	//Result.push_back(this);
	return Result;
}

Node* Node::Get_Scope_As(int F, Node* scope) {
	if (scope->is(F))
		return scope;
	if (scope->Scope != nullptr)
		return Get_Scope_As(F, scope->Scope);
	Report(Observation(ERROR, "Parent NULL!!", *Location));
	throw::runtime_error("ERROR!");
}

Node* Node::Get_Scope_As(int F, vector<string> inheritted, Node* scope)
{
	if (!scope->is(F))
		return Get_Scope_As(F, inheritted, scope->Scope);

	for (auto i : inheritted)
		if (scope->is(i) == -1)
			goto Not_Right_Scope;

	return scope;
	
	Not_Right_Scope:;
	return Get_Scope_As(F, inheritted, scope->Scope);
}

Node* Node::Get_Context_As(int F, Node* Context)
{
	if (Context->is(F))
		return Context;
	if (Context->Context)
		return Get_Context_As(F, Context->Context);
	return nullptr;
}

Node* Node::Get_Context_As(string n, Node* Context)
{
	if (Context->Name == n)
		return Context;
	if (Context->Context)
		return Get_Context_As(n, Context->Context);
	return nullptr;
}

/// <summary>
/// Gets a list of all the upper parents that this is defined in, up to global scope :D
/// </summary>
/// <returns></returns>
vector<Node*> Node::Get_Scope_Path()
{
	vector<Node*> Result;
	Node* Current_Scope = Scope;
	while (Current_Scope->Name != "GLOBAL_SCOPE") {

		Result.push_back(Current_Scope);
		Current_Scope = Current_Scope->Scope;

		if (Current_Scope == nullptr)
			Report(Observation(ERROR, "Parental Scope was not found.", *this->Location));
	}
	return Result;
}

Node* Node::Find(Node* n, Node* s)
{
	//some criteria
	if (n->Name == "\n")
		return nullptr;
	if (n->is(NUMBER_NODE) || n->is(STRING_NODE) || n->is(LABEL_NODE))
		return n;
	if (s == nullptr) {
		Report(Observation(ERROR, "Critical Error: parent is null!", *Location));
		throw::runtime_error("ERROR!");
	}

	if (n->is(TEMPLATE_NODE))
		for (auto& i : s->Templates)
			if (i->Templates.size() == n->Templates.size())
				if (i->Name == n->Name)
					return i;

	//The feching find that finds the Scope_Path, algorithm will be start before normal search-
	//because of same named objects in the current scope.
	//Normal current and above going scope search algorithm
	for (Node* i : s->Defined)
		if (i->Templates.size() == n->Templates.size())
			if (i->Name == n->Name) {
				if (n->Cast_Type != nullptr) {
					Node* tmp = i->Copy_Node(i, i->Scope);
					tmp->Cast_Type = n->Cast_Type;
					return tmp;
				}
				return i;
			}

	for (Node* i : s->Inlined_Items) {
		if (i->Templates.size() == n->Templates.size())
			if (i->Name == n->Name) {
				if (n->Cast_Type != nullptr) {
					Node* tmp = i->Copy_Node(i, i->Scope);
					tmp->Cast_Type = n->Cast_Type;
					return tmp;
				}
				return i;
			}
	}

	if (n->Fetcher != nullptr)
		if (n->Fetcher != s)
			for (auto& i : Find_Scope(n)->Defined)
				if (i->Templates.size() == n->Templates.size())
					if (i->Name == n->Name)
						return i;

	if (s->Fetcher != nullptr)
		if (s->Fetcher != s->Scope)
			for (auto& i : Find_Scope(s)->Defined)
				if (i->Templates.size() == n->Templates.size())
					if (i->Name == n->Name)
						return i;

	//If the current scope doesn't have the wanted object, then try at one spet higher scope.
	if (s->Scope != nullptr)
		if (Find(n, s->Scope) != nullptr)
			return Find(n, s->Scope);

	//IDK what this does, please explain!
	if (s->Cast_Type != nullptr)
		for (auto& i : s->Find(s->Cast_Type, s, CLASS_NODE)->Defined)
			if (i->Templates.size() == n->Templates.size())
				if (i->Name == n->Name)
					return i;

	return nullptr;
}

Node* Node::Find(int size, Node* parent, int flags, string f, bool Needs_To_Be_Base_Type) {

	for (Node* i : parent->Defined)
		if (i->is(flags) && (i->Size == size))
			if (i->Format == f)
				if (Needs_To_Be_Base_Type && MANGLER::Is_Base_Type(i))
					return i;

	for (Node* i : parent->Inlined_Items)
		if (i->is(flags) && (i->Size == size))
			if (i->Format == f)
				if (Needs_To_Be_Base_Type && MANGLER::Is_Base_Type(i))
					return i;

	if (parent->Scope != nullptr) {
		return Find(size, parent->Scope, flags, f, Needs_To_Be_Base_Type);
	}

	return nullptr;
}

Node* Node::Find(Node* n, Node* s, int f)
{
	//some criteria
	if (n->Name == "\n")
		return nullptr;
	if (n->is(NUMBER_NODE) || n->is(STRING_NODE) || n->is(LABEL_NODE))
		return n;
	if (s == nullptr) {
		Report(Observation(ERROR, "Critical Error: parent is null!", *Location));
		throw::runtime_error("ERROR!");
	}

	if (n->is(TEMPLATE_NODE))
		for (auto& i : s->Templates)
			if (i->is(n->Type))
				if (i->Templates.size() == n->Templates.size())
					if (i->Name == n->Name)
						return i;

	//The feching find that finds the Scope_Path, algorithm will be start before normal search-
	//because of same named objects in the current scope.
	//Normal current and above going scope search algorithm
	for (Node* i : s->Defined)
		if (i->is(f))
			if (i->Templates.size() == n->Templates.size())
				if (i->Name == n->Name) {
					if (n->Cast_Type != nullptr) {
						Node* tmp = i->Copy_Node(i, i->Scope);
						tmp->Cast_Type = n->Cast_Type;
						return tmp;
					}
					return i;
				}

	for (Node* i : s->Inlined_Items) {
		if (i->is(f))
			if (i->Templates.size() == n->Templates.size())
				if (i->Name == n->Name) {
					if (n->Cast_Type != nullptr) {
						Node* tmp = i->Copy_Node(i, i->Scope);
						tmp->Cast_Type = n->Cast_Type;
						return tmp;
					}
					return i;
				}
	}

	if (n->Fetcher != nullptr)
		for (auto& i : Find_Scope(n)->Defined)
			if (i->is(f))
				if (i->Templates.size() == n->Templates.size())
					if (i->Name == n->Name)
						return i;

	if (s->Fetcher != nullptr) {
		Node* F = Find_Scope(s);
		if (F != nullptr)
			if (Find(n, F, f) != nullptr)
				return Find(n, F, f);
	}

	//If the current scope doesn't have the wanted object, then try at one spet higher scope.
	if (s->Scope != nullptr)
		if (Find(n, s->Scope, f) != nullptr)
			return Find(n, s->Scope, f);

	//IDK what this does, please explain!
	if (s->Cast_Type != nullptr && s->Cast_Type->Name != n->Name)
			for (auto& i : s->Find(s->Cast_Type, s, CLASS_NODE)->Defined)
				if (i->is(f))
					if (i->Templates.size() == n->Templates.size())
						if (i->Name == n->Name)
							return i;
	
	return nullptr;
}

Node* Node::Find(string name, Node* s, int flags) {
	if (name == "\n")
		return nullptr;
	if (s == nullptr) {
		Report(Observation(ERROR, "Critical Error: parent is null!", *Location));
		throw::runtime_error("ERROR!");
		return nullptr;
	}

	for (auto& i : s->Templates)
		if (i->is(flags))
			if (i->Name == name)
				return i;

	for (Node* i : s->Defined)
		if (i->is(flags))
			if (i->Name == name)
				return i;

	for (Node* i : s->Inlined_Items)
		if (i->is(flags))
			if (i->Name == name)
				return i;

	if (s->Fetcher != nullptr) {
		Node* F = Find_Scope(s);
		if (F != nullptr)
			if (Find(name, F, flags) != nullptr)
				return Find(name, F, flags);
	}

	if (s->Scope != nullptr)
		if (Find(name, s->Scope, flags) != nullptr)
			return Find(name, s->Scope, flags);

	if (s->Cast_Type != nullptr && s->Cast_Type->Name != name && s->Find(s->Cast_Type, s, flags) != nullptr)
		for (auto& i : s->Find(s->Cast_Type, s, { CLASS_NODE, OBJECT_DEFINTION_NODE, OBJECT_NODE })->Defined)
				if (i->Name == name)
					return i;

	//if (s->Fetcher != nullptr) {
	//	Node* F = Find_Scope(s);
	//	if (F != nullptr)
	//		if (Find(name, F, flags) != nullptr)
	//			return Find(name, F, flags);
	//}
	return nullptr;
}

Node* Node::Find(string name, Node* s, bool Need_Parent_existence) {
	if (name == "\n")
		return nullptr;
	if (s == nullptr /*&& Need_Parent_existance*/) {
		Report(Observation(ERROR, "Critical Error: parent is null!", *Location));
		throw::runtime_error("ERROR!");
		return nullptr;
	}

	for (auto& i : s->Templates)
		if (i->Name == name)
			return i;

	for (Node* i : s->Defined)
		if (i->Name == name)
			return i;

	for (Node* i : s->Inlined_Items)
		if (i->Name == name)
			return i;

	//List<T>.Foo(){}
	if (s->Fetcher != nullptr) {
		Node* F = Find_Scope(s);
		if (F != nullptr)
			if (Find(name, F, Need_Parent_existence) != nullptr)
				return Find(name, F, Need_Parent_existence);
	}

	if (s->Scope != nullptr)
		if (Find(name, s->Scope, Need_Parent_existence) != nullptr)
			return Find(name, s->Scope, Need_Parent_existence);

	if (s->Cast_Type != nullptr && s->Cast_Type->Name != name )
		for (auto& i : s->Find(s->Cast_Type, s, { CLASS_NODE, OBJECT_DEFINTION_NODE, OBJECT_NODE })->Defined)
				if (i->Name == name)
					return i;

	//if (s->Fetcher != nullptr) {
	//	Node* F = Find_Scope(s);
	//	if (F != nullptr)
	//		if (Find(name, F, Need_Parent_existence) != nullptr)
	//			return Find(name, F, Need_Parent_existence);
	//}
	return nullptr;
}

void Node::Get_Inheritted_Class_Members() {
	for (auto Inherit : Inheritted) {
		if (Lexer::GetComponent(Inherit).is(::Flags::KEYWORD_COMPONENT))
			continue;
		vector<Node*> Inheritted_Members = Find(Inherit, Scope)->Defined;

		reverse(Inheritted_Members.begin(), Inheritted_Members.end());

		for (auto Member : Inheritted_Members)
			if (Member->is("const") == -1)
				if (Locate(Member->Name, Defined) == false)
					Defined.insert(Defined.begin(), Member);
	}
}

void Node::Update_Inheritance() {
	if (Cast_Type != nullptr)
		return;
	//save all keyword inheritances.
	vector<string> Keyword_Inheritance;
	for (auto i : Inheritted)
		if (Lexer::GetComponents(i)[0].is(Flags::KEYWORD_COMPONENT))
			Keyword_Inheritance.push_back(i);
	//remove all inheritances
	Inheritted.clear();

	Inheritted.push_back(Cast_Type->Name);
	Inheritted.insert(Inheritted.end(), Keyword_Inheritance.begin(), Keyword_Inheritance.end());
}

void Node::Transform_Dot_To_Fechering(Node* To)
{
	//(((A.B).C).D).Banana()
	//we start at the Dot that is left side of Banana()
	//((A.B).C).D | this == (..).D
	if (Name == ".") {
		//set the left side to To
		To->Fetcher = Right;
		if (Left->Name == ".") {
			Left->Transform_Dot_To_Fechering(Right);
		}
	}
	else
		To->Fetcher = this;
}

Node* Node::Get_Closest_Context(int Flags)
{
	if (!this)
		return nullptr;

	if (is(Flags))
		return this;

	Node* Closest_Context = Context->Get_Closest_Context(Flags);

	if (Closest_Context)
		return Closest_Context;

	return nullptr;
}

void Node::Clean()
{
	Header.clear();
	Defined.clear();
	Parameters.clear();
	Childs.clear();
	Inlined_Items.clear();
	Member_Functions.clear();
	Operator_Overloads.clear();
	Templates.clear();
	Inheritable_templates.clear();
	Template_Children.clear();
	Numerical_Return_Types.clear();
}

vector<Node*> Trace_Update_Size;
int Node::Update_Size() {
	if (is("const") != -1 && Size != 0 || Is_Template_Object)
		return Size;

	for (int j = 0; j < Trace_Update_Size.size(); j++)
		if (this == Trace_Update_Size[j]) {
			Trace_Update_Size.pop_back();
			if (is("ptr") != -1 || is("func") != -1)
				return _SYSTEM_BIT_SIZE_;
			return Size;
		}

	Trace_Update_Size.push_back(this);

	Size = 0;
	if (!is(FUNCTION_NODE))
		for (auto Member : Defined) {
			if (Member->Has({ FUNCTION_NODE, PROTOTYPE, IMPORT, EXPORT }))
				Member->Update_Size();
			else
				Size += Member->Update_Size();
		}

	//this must be done after the members size are all set because the ptr will override them size.
	for (auto Inherit : Inheritted) {
		if (Lexer::GetComponent(Inherit).is(Flags::KEYWORD_COMPONENT)) {
			if (Inherit == "ptr" || Inherit == "func") {
				Size = _SYSTEM_BIT_SIZE_;
				break;
			}
			continue;
		}
		else if (MANGLER::Is_Base_Type(Find(Inherit)))
			Size += Find(Inherit)->Update_Size();
	}
	Trace_Update_Size.pop_back();
	return Size;
}

vector<Node*> Node::Get_all(int f, vector<Node*> Trace)
{

	if (this->is(FUNCTION_NODE))
		if (this->is(f) || f == -1)
			return { this };
		else
			return {};


	for (int j = 0; j < Trace.size(); j++)
		if (this == Trace[j]) {
			Trace.pop_back();
			if (this->is(f))
				return { new Node(*this) };
			return {};
		}

	Trace.push_back(this);

	vector<Node*> Result;
	if (Left != nullptr) {
		vector<Node*> left = Left->Get_all(f, Trace);
		Result.insert(Result.end(), left.begin(), left.end());
	}
	if (Right != nullptr) {
		vector<Node*> right = Right->Get_all(f, Trace);
		Result.insert(Result.end(), right.begin(), right.end());
	}
	if (Succsessor != nullptr) {
		vector<Node*> Succsessors = Succsessor->Get_all(f, Trace);
		Result.insert(Result.end(), Succsessors.begin(), Succsessors.end());
	}
	if (Predecessor != nullptr) {
		vector<Node*> Predecessors = Predecessor->Get_all(f, Trace);
		Result.insert(Result.end(), Predecessors.begin(), Predecessors.end());
	}
	if (Fetcher != nullptr) {
		//vector<Node*> Fetchers = Fetcher->Get_all(f, Trace);
		//Result.insert(Result.end(), Fetchers.begin(), Fetchers.end());
		if (Fetcher->is(f))
			Result.push_back(Fetcher);
	}
	for (Node* i : Header) {
		vector<Node*> Headers = i->Get_all(f, Trace);
		Result.insert(Result.end(), Headers.begin(), Headers.end());
	}
	for (Node* i : Childs) {
		vector<Node*> childs = i->Get_all(f, Trace);
		Result.insert(Result.end(), childs.begin(), childs.end());
	}
	for (Node* i : Parameters) {
		vector<Node*> childs = i->Get_all(f, Trace);
		Result.insert(Result.end(), childs.begin(), childs.end());
	}
	for (Node* i : Defined) {
		vector<Node*> childs = i->Get_all(f, Trace);
		Result.insert(Result.end(), childs.begin(), childs.end());
	}
	if (Cast_Type) {
		//vector<Node*> childs = Cast_Type->Get_all(f, Trace);
		//Result.insert(Result.end(), childs.begin(), childs.end());
		if (Cast_Type->is(f))
			Result.push_back(Cast_Type);
	}

	if (is(f) || f == -1)
		Result.push_back(this);

	for (int i = 0; i < Result.size(); i++)
		for (int j = 0; j < Result.size(); j++)
			if (Result[i] == Result[j] && i != j)
				Result.erase(Result.begin() + j--);

	Trace.pop_back();

	return Result;
}

//			old  , new
vector<pair<Node*, Node*>> Trace;
Node* Node::Copy_Node(Node* What_Node, Node* p)
{
	if (What_Node == nullptr)
		return nullptr;

	//disable recursive funciton copying
	if (Trace.size() > 0)
		if (What_Node->is(FUNCTION_NODE))
			return What_Node;

	for (int j = 0; j < Trace.size(); j++) {
		if (What_Node == Trace[j].first) {
			return Trace[j].second;
		}
	}

	//this will only copy the ptrs in list but we want to also copy what those ptr point to.
	Node* Result = new Node(*What_Node);
	Result->Scope = p;

	Trace.push_back({ What_Node, Result });

	//lets start from defined
	for (int i = 0; i < Result->Defined.size(); i++)
		Result->Defined[i] = Copy_Node(Result->Defined[i], Result);

	for (int i = 0; i < Result->Templates.size(); i++)
		Result->Templates[i] = Copy_Node(Result->Templates[i], Result);

	for (int i = 0; i < Result->Childs.size(); i++)
		if (Result->is(CONTENT_NODE))
			Result->Childs[i] = Copy_Node(Result->Childs[i], p);
		else
			Result->Childs[i] = Copy_Node(Result->Childs[i], Result);

	for (int i = 0; i < Result->Member_Functions.size(); i++)
		Result->Member_Functions[i] = Copy_Node(Result->Member_Functions[i], Result);

	for (int i = 0; i < Result->Operator_Overloads.size(); i++)
		Result->Operator_Overloads[i] = Copy_Node(Result->Operator_Overloads[i], Result);

	for (int i = 0; i < Result->Parameters.size(); i++) {
		Node* scope = Result;
		if (Result->is(CALL_NODE))
			scope = Result->Scope;

		Result->Parameters[i] = Copy_Node(Result->Parameters[i], scope);

		if (Result->is(CALL_NODE))
			Result->Parameters[i]->Context = Result;
	}

	for (int i = 0; i < Result->Header.size(); i++)
		Result->Header[i] = Copy_Node(Result->Header[i], p);


	for (int i = 0; i < Result->Numerical_Return_Types.size(); i++)
		Result->Numerical_Return_Types[i] = Copy_Node(Result->Numerical_Return_Types[i], p);

	if (Result->Left) {
		Result->Left = Copy_Node(Result->Left, p);
		Result->Left->Context = Result;
	}
	if (Result->Right) {
		Result->Right = Copy_Node(Result->Right, p);
		Result->Right->Context = Result;
	}

	Result->Succsessor = Copy_Node(Result->Succsessor, p);
	Result->Predecessor = Copy_Node(Result->Predecessor, p);

	if (Result->Fetcher)
		Result->Fetcher = Copy_Node(Result->Fetcher, p);


	if (Result->Succsessor) {
		Result->Succsessor->Predecessor = Result;
	}
	if (Result->Predecessor) {
		Result->Predecessor->Succsessor = Result;
	}

	if (Result->Location)
		Result->Location = new Position(*Result->Location);

	if (Result->Cast_Type)
		Result->Cast_Type = Copy_Node(Result->Cast_Type, p);

	//The copying prosess must go downwards not upwards, otherwise it will loop forever!
	//Result->Holder = Copy_Node(Result->Holder, p);

	Trace.pop_back();
	//now we have copyed every ptr into a new base to point.
	return Result;
}
C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Cpp\Nodes\Token.cpp" 
#include "../../H/Nodes/Token.h"
#include "../../H/BackEnd/Selector.h"
#include "../../H/UI/Usr.h"
#include "../../H/UI/Safe.h"
#include "../../H/Docker/Mangler.h"

extern Selector* selector;
extern Usr* sys;

Token::Token(Node* n, bool Skip_Needed_Address_Protocol) {
	if (n->is(OBJECT_NODE) || n->is(OBJECT_DEFINTION_NODE)) {
		if (n->Find(n, n->Scope)->Scope->is("static") != -1 || n->is("static") != -1 || (n->Fetcher != nullptr && n->Fetcher->is("static") != -1) || n->Find(n, n->Scope)->Has({FUNCTION_NODE, PROTOTYPE, IMPORT, EXPORT}))
			Flags = TOKEN::GLOBAL_VARIABLE | TOKEN::CONTENT;
		else if (n->Find(n, n->Scope)->Requires_Address)
			Flags = TOKEN::CONTENT;
		else
			Flags = TOKEN::REGISTER;

		if (n->Find(n, n)->Format == "decimal")
			Flags |= TOKEN::DECIMAL;
	}
	else if (n->is(NUMBER_NODE)) {
		Flags = TOKEN::NUM;
		if (n->Format == "decimal") {
			Flags |= TOKEN::DECIMAL;
			Has_Floating_Point_Value = true;
		}
		if (n->Coefficient == -1)
			n->Name = "-" + n->Name;
	}
	else if (n->is(PARAMETER_NODE)) {
		//first get the index this paremet is
		int Max_Integer_Registers = selector->Get_Numerical_Parameter_Register_Count(n->Get_Scope_As(FUNCTION_NODE, n->Scope)->Parameters);
		int Current_Integer_Register_Count = 0;
		int Max_Floating_Registers = selector->Get_Floating_Parameter_Register_Count(n->Get_Scope_As(FUNCTION_NODE, n->Scope)->Parameters);
		int Current_Float_Register_Count = 0;

		bool Requires_Address = n->Find(n, n->Scope)->Requires_Address && !Skip_Needed_Address_Protocol;

		//find the curresponding register
		for (int i = 0; i < n->Get_Scope_As(FUNCTION_NODE, n->Scope)->Parameters.size(); i++) {
			if (n->Get_Scope_As(FUNCTION_NODE, n->Scope)->Parameters[i]->Name == n->Name) {
				if (n->Find(n->Get_Scope_As(FUNCTION_NODE, n->Scope)->Parameters[i]->Name)->Format == "decimal") {
					if (Current_Float_Register_Count < Max_Floating_Registers && !Requires_Address) {
						Flags = TOKEN::REGISTER | TOKEN::DECIMAL | TOKEN::PARAMETER;
						Parameter_Index = i;
					}
					else
						Flags = TOKEN::CONTENT | TOKEN::DECIMAL;
					break;
				}
				else {
					if (Current_Integer_Register_Count < Max_Integer_Registers && !Requires_Address) {
						Flags = TOKEN::REGISTER | TOKEN::PARAMETER;
						Parameter_Index = i;
					}
					else
						Flags = TOKEN::CONTENT;
					break;
				}
			}
			if (n->Find(n->Get_Scope_As(FUNCTION_NODE, n->Scope)->Parameters[i]->Name)->Format == "decimal")
				Current_Float_Register_Count++;
			else
				Current_Integer_Register_Count++;
		}
	}
	else if (n->is(STRING_NODE))
		Flags = TOKEN::STRING;
	else if (n->is(LABEL_NODE)) {
		Flags = TOKEN::LABEL;
		n->Size = _SYSTEM_BIT_SIZE_;//for giving the address
	}
	else
		return;
	Size = n->Find(n, n->Scope)->Size;

	Name = n->Name;

	if (n->Find(n, n->Scope)->Has({ FUNCTION_NODE, IMPORT, EXPORT }))
		Name = MANGLER::Mangle(n->Function_Implementation, "");

	if (n->is("static") != -1 || (n->Fetcher != nullptr && n->Fetcher->is("static") != -1))
		Name = n->Fetcher->Name + "_" + Name;

	Parent = n->Scope;

	if (Flags == 0)
		Report(Observation(ERROR, "Internal error! Missing Flag in token " + Name, Position()));
}

vector<Token*> Token::Get_All(vector<long long> F)
{
	vector<Token*> Result;
	for (auto i : F) {
		vector<Token*> Tmp = Get_All(i);
		Result.insert(Result.begin(), Tmp.begin(), Tmp.end());
	}
	return Result;
}

vector<Token*> Token::Get_All(long long F)
{
	vector<Token*> Result;
	for (auto i : Childs) {
		vector<Token*> Tmp = i->Get_All(F);
		Result.insert(Result.begin(), Tmp.begin(), Tmp.end());
	}	
	for (auto i : Parameters) {
		vector<Token*> Tmp = i->Get_All(F);
		Result.insert(Result.begin(), Tmp.begin(), Tmp.end());
	}
	if (Left) {
		vector<Token*> Tmp = Left->Get_All(F);
		Result.insert(Result.begin(), Tmp.begin(), Tmp.end());
	}
	if (Right) {
		vector<Token*> Tmp = Right->Get_All(F);
		Result.insert(Result.begin(), Tmp.begin(), Tmp.end());
	}

	if (this->is(F))
		Result.push_back(this);

	return Result;
}

C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Cpp\Parser\Algebra.cpp" 
#include "../../H/Parser/Algebra.h"
#include "../../H/UI/Safe.h"
#include "../../H/UI/Usr.h"
#include "../../H/Parser/PostProsessor.h"

#include <cmath>

bool Optimized = false;
long long Inlined_Function_Count = 0;
long long Unique_ID_Count = 0;
vector<string> Defined_Labels;

extern Usr* sys;

void Algebra::Factory() {
	if (sys->Info.Is_Service && sys->Service_Info != Document_Request_Type::ASM)
		return;

	for (int i = 0; i < Input->size(); i++) {
		Function_Inliner(Input->at(i), i);
	}
	for (int i = 0; i < Input->size(); i++) {
		Prosess_Return(Input->at(i), i);
		Prosess_Paranthesis(Input->at(i));
		Prosess_Conditions(Input->at(i), i);
		Inline_Variables(i);
		Set_Coefficient_Value(i);
		Combine_Scattered(Input->at(i));
		Set_Defining_Value(i);
		Reset_Defining_Value(i);
		Un_Wrap_Parenthesis(Input->at(i));
	}
	for (int i = 0; i < Input->size(); i++)
		Clean_Inlined(i); 
	for (auto& i : *Input)
		Operate_Numbers_As_Constants(i);
	for (auto& i : *Input) {
		Operate_Coefficient_Constants(i);
		Operate_Distant_Coefficients(i);
		Reduce_Operator_Operations(i);
	}
	for (auto& i : *Input) {
		//Fix_Order_Into_Real_Operator(i);
		Fix_Coefficient_Into_Real_Operator(i);
	}
	Clean_Unused();
}

//vector<Node*> Linearise(Node* ast, bool Include_Operator = false)
//{
//		vector<Node*> Result;
//		if (ast->is(OPERATOR_NODE) || ast->is(CONDITION_OPERATOR_NODE) || ast->is(BIT_OPERATOR_NODE) || ast->is(ASSIGN_OPERATOR_NODE) || ast->is(ARRAY_NODE)) {
//			vector<Node*> left = Linearise(ast->Left);
//			Result.insert(Result.end(), left.begin(), left.end());
//
//			Result.push_back(ast);
//
//			vector<Node*> right = Linearise(ast->Right);
//			Result.insert(Result.end(), right.begin(), right.end());
//		}
//		else if (ast->is(PREFIX_NODE)) {
//			vector<Node*> right = Linearise(ast->Right);
//			Result.insert(Result.end(), right.begin(), right.end());
//		}
//		else if (ast->is(POSTFIX_NODE) || ast->is(NODE_CASTER)) {
//			vector<Node*> left = Linearise(ast->Left);
//			Result.insert(Result.end(), left.begin(), left.end());
//		}
//		else if (ast->is(CONTENT_NODE)) {
//			vector<Node*> childs;
//			for (auto c : ast->Childs) {
//				vector<Node*> tmp = Linearise(c);
//				childs.insert(childs.end(), tmp.begin(), tmp.end());
//			}
//			Result.insert(Result.end(), childs.begin(), childs.end());
//		}
//		else if (ast->Has({ IF_NODE, ELSE_IF_NODE, ELSE_NODE, WHILE_NODE })) {
//			vector<Node*> childs;
//			for (auto c : ast->Parameters) {
//				vector<Node*> tmp = Linearise(c);
//				childs.insert(childs.end(), tmp.begin(), tmp.end());
//			}
//			for (auto c : ast->Childs) {
//				vector<Node*> tmp = Linearise(c);
//				childs.insert(childs.end(), tmp.begin(), tmp.end());
//			}
//			Result.insert(Result.end(), childs.begin(), childs.end());
//		}
//		else if (ast->is(CALL_NODE)) {
//			vector<Node*> childs;
//			for (auto c : ast->Parameters) {
//				vector<Node*> tmp = Linearise(c);
//				childs.insert(childs.end(), tmp.begin(), tmp.end());
//			}
//			Result.insert(Result.end(), childs.begin(), childs.end());
//
//			Result.push_back(ast);
//		}
//		else if (ast->Name == "return" && ast->Right != nullptr) {
//			for (auto c : Linearise(ast->Right))
//				Result.push_back(c);
//		}
//		else
//			Result.push_back(ast);
//
//	for (int i = 0; i < Result.size(); i++) {
//		if (Include_Operator && Result[i]->Has({ ASSIGN_OPERATOR_NODE, CONDITION_OPERATOR_NODE, BIT_OPERATOR_NODE, LOGICAL_OPERATOR_NODE, ARRAY_NODE }))
//			Result.erase(Result.begin() + i);
//	}
//
//	return Result;
//}

void Algebra::Set_Return_To_Jump(Node* n, Node* Return_Value, Node* end)
{
	if (n->Name == "return") {
		Node* Return_Paranthesis = new Node(CONTENT_NODE, n->Location);
		Return_Paranthesis->Paranthesis_Type = '{';
		Return_Paranthesis->Name = "Paranthesis";
		Return_Paranthesis->Scope = n->Scope;
		Return_Paranthesis->Context = n->Context;

		if (Return_Value) {
			Node* Assign = new Node(ASSIGN_OPERATOR_NODE, n->Location);
			Assign->Name = "=";
			Assign->Scope = n->Scope;

			Node* Left = Return_Value->Copy_Node(Return_Value, n->Scope);
			Left->Type = OBJECT_NODE;
			Left->Context = Assign;

			Node* Right = n->Copy_Node(n->Right, n->Scope);
			Right->Context = Assign;

			Assign->Left = Left;
			Assign->Right = Right;

			Return_Paranthesis->Childs.push_back(Assign);
		}
		Node* Return = new Node(FLOW_NODE, n->Location);
		Return->Name = "jump";
		Return->Right = new Node(*end);
		Return->Scope = end->Scope;
		Return->Right->Context = Return;

		Return_Paranthesis->Childs.push_back(Return);

		*n = *Return_Paranthesis;
	}
}

void Algebra::Function_Inliner(Node* c, int i)
{
	//return;
	if (!c->is(CALL_NODE) || c->Function_Ptr || c->is("import") != -1 || c->Function_Implementation->is("import") != -1)
		return;

	//copy the nodes to a safe heaven
	vector<Node*> Parameters;
	vector<Node*> Defined;
	vector<Node*> Childs;

	if (!c->Function_Implementation->is(PARSED_BY::FUNCTION_PROSESSOR)) {
		PostProsessor p(c->Function_Implementation);
		p.Open_Function_For_Prosessing(c->Function_Implementation);
	}

	for (auto j : c->Function_Implementation->Childs){
		for (auto k : j->Get_all(CALL_NODE)) {
			if (k->Function_Ptr)
				continue;
			//k->Function_Implementation->Calling_Count++;	//increase the calling count
			if (k->Function_Implementation == c->Function_Implementation)
				return;	//disable recursive funktions
		}
	}

	for (auto j : c->Function_Implementation->Childs) {
		Childs.push_back(c->Copy_Node(j, c->Scope));
	}

	for (auto j : Childs) {
		for (auto k : j->Get_all(LABEL_NODE)) {
			if (k->Inline_Return_Label == LABEL_TYPE::RETURN_LABEL && k->Context == nullptr)
				k->Inline_Return_Label = LABEL_TYPE::CAN_MODIFY_ID;
		}
	}

	//give the parameters a new name;
	for (auto j : c->Function_Implementation->Parameters) {
		Node* tmp = c->Copy_Node(j, c->Scope);
		tmp->Type = OBJECT_DEFINTION_NODE;
		tmp->Name += "_" + to_string(Inlined_Function_Count);
		Parameters.push_back(tmp);
	}

	while (true) {
		for (auto j : Defined_Labels) {
			if (j == ("Return_Here_" + to_string(Unique_ID_Count)))
				goto Label_Already_Taken;
		}
		break;
	Label_Already_Taken:;
		Unique_ID_Count++;
	}

	//generate the end_of_function_label
	Node* End_of_Function_Label = new Node(LABEL_NODE, c->Location);
	End_of_Function_Label->Name = "Return_Here_" + to_string(Unique_ID_Count);
	End_of_Function_Label->Scope = c->Scope;
	End_of_Function_Label->Inline_Return_Label = LABEL_TYPE::RETURN_LABEL;

	Childs.push_back(End_of_Function_Label);
	Defined_Labels.push_back("Return_Here_" + to_string(Unique_ID_Count));

	Node* Return_Value = nullptr;
	if (c->Context) {
		Return_Value = new Node(OBJECT_DEFINTION_NODE, c->Location);
		Return_Value->Name = "Return_Value" + to_string(Inlined_Function_Count);
		Return_Value->Scope = c->Scope;
		Return_Value->Context = c->Context;
		Return_Value->Inheritted = c->Inheritted;

		Return_Value->Get_Inheritted_Class_Members();
	}

	//go thróugh all the children and update the names
	//the defined also have the parameters so only here we need to go through all th childrens.
	for (auto i : c->Function_Implementation->Defined) {
		Node* tmp = c->Copy_Node(i, c->Scope);
		tmp->Type = OBJECT_DEFINTION_NODE;
		tmp->Name += "_" + to_string(Inlined_Function_Count);
		Defined.push_back(tmp);
	}

	for (auto j : Childs) {
		for (auto k : j->Get_all({ FLOW_NODE })) {
			//replace all the return statement with a jump to a end label command
			Set_Return_To_Jump(k, Return_Value, End_of_Function_Label);
		}
		for (auto k : j->Get_all({ PARAMETER_NODE, OBJECT_DEFINTION_NODE, OBJECT_NODE, FLOW_NODE, LABEL_NODE })) {
			for (auto i : c->Function_Implementation->Defined) {
				if (k->Name == i->Name) {
					k->Name += "_" + to_string(Inlined_Function_Count);
					if (k->is(PARAMETER_NODE))
						k->Type = OBJECT_NODE;
				}
			}
			if (k->Inline_Return_Label == LABEL_TYPE::CAN_MODIFY_ID) {
				vector<Node*> Same_Named_Labels;
				for (auto i : Childs) {
					for (auto j : i->Get_all(LABEL_NODE))
						if (j->Name == k->Name)
							Same_Named_Labels.push_back(j);
				}

				while (true) {
					for (auto j : Defined_Labels) {
						if (j == ("Return_Here_" + to_string(Unique_ID_Count)))
							goto Label_Already_Taken_1;
					}
					break;
				Label_Already_Taken_1:;
					Unique_ID_Count++;
				}

				for (auto i : Same_Named_Labels) {
					i->Name = "Return_Here_" + to_string(Unique_ID_Count);
				}

				Defined_Labels.push_back("Return_Here_" + to_string(Unique_ID_Count));
			}
		}
	}

	//first anchor the parameters to setted with the value corresponding at the callers parameters.
	for (int i = 0; i < Parameters.size(); i++) {
		Node* Left_Side = Parameters[i]->Copy_Node(Parameters[i], Parameters[i]->Scope);
		
		Node* Right_Side = c->Copy_Node(c->Parameters[i], c->Scope);

		Node* Operator = new Node(ASSIGN_OPERATOR_NODE, c->Parameters[i]->Location);
		Operator->Name = "=";
		Operator->Left = Left_Side;
		Operator->Right = Right_Side;
		Operator->Scope = c->Scope;
		Operator->Inheritted = Operator->Left->Inheritted;

		Left_Side->Context = Operator;
		Right_Side->Context = Operator;

		Childs.insert(Childs.begin(), Operator);
	}

	Node* Scope = c->Scope;

	if (Return_Value)
		Scope->Defined.push_back(Return_Value);

	Scope->Defined.insert(Scope->Defined.end(), Defined.begin(), Defined.end());

	Scope->Defined.insert(Scope->Defined.end(), c->Defined.begin(), c->Defined.end());
	c->Defined.clear();

	//c->Function_Implementation->Calling_Count--;

	if (c->Context) {
		c->Context->Header.insert(c->Context->Header.end(), Childs.begin(), Childs.end());
	}
	else
		Input->insert(Input->begin() + i, Childs.begin(), Childs.end());

	if (Return_Value) {
		Return_Value->Cast_Type = c->Cast_Type;
		*c = *Return_Value;
	}
	else
		Input->erase(Input->begin() + Childs.size() + i);

	Inlined_Function_Count++;
	Optimized = true;

	for (auto& j : Scope->Defined) {
		j->Update_Size();
	}

	/*Scope->Update_Local_Variable_Mem_Offsets();

	Scope->Update_Member_Variable_Offsets(Scope);*/
}

vector<Node*> Algebra::Get_all(Node* n, int f)
{
	vector<Node*> Result;
	if (n->Left != nullptr) {
		vector<Node*> left = Get_all(n->Left, f);
		Result.insert(Result.end(), left.begin(), left.end());
	}
	if (n->Right != nullptr) {
		vector<Node*> right = Get_all(n->Right, f);
		Result.insert(Result.end(), right.begin(), right.end());
	}
	if (n->Succsessor != nullptr) {
		vector<Node*> Succsessors = Get_all(n->Succsessor, f);
		Result.insert(Result.end(), Succsessors.begin(), Succsessors.end());
	}
	if (n->Predecessor != nullptr) {
		vector<Node*> Predecessors = Get_all(n->Predecessor, f);
		Result.insert(Result.end(), Predecessors.begin(), Predecessors.end());
	}
	if (n->Fetcher != nullptr) {
		vector<Node*> Fetchers = Get_all(n->Fetcher, f);
		Result.insert(Result.end(), Fetchers.begin(), Fetchers.end());
	}
	for (Node* i : n->Header) {
		vector<Node*> Headers = Get_all(i, f);
		Result.insert(Result.end(), Headers.begin(), Headers.end());
	}
	for (Node* i : n->Childs) {
		vector<Node*> childs = Get_all(i, f);
		Result.insert(Result.end(), childs.begin(), childs.end());
	}
	for (Node* i : n->Parameters) {
		vector<Node*> childs = Get_all(i, f);
		Result.insert(Result.end(), childs.begin(), childs.end());
	}
	for (Node* i : n->Defined) {
		vector<Node*> childs = Get_all(i, f);
		Result.insert(Result.end(), childs.begin(), childs.end());
	}

	if (n->is(f))
		Result.push_back(n);

	return Result;
}

void Algebra::Prosess_Return(Node* n, int i)
{
	if (n->Name != "return")
		return;
	if (n->Right == nullptr)
		return;
	vector<Node*> tmp = { n->Right };
	bool TMP = Optimized;
	Optimized = false;
	while (true) {
		Algebra a(n, &tmp);
		if (!Optimized)
			break;
		Optimized = false;
	}
	Optimized = TMP;

	if (n->Header.size() > 0) {
		Input->insert(Input->begin() + i, n->Header.begin(), n->Header.end());
		n->Header.clear();
	}

	if (tmp.size() == 1)
		n->Right = tmp.back();
	else {
		Input->insert(Input->begin() + i, tmp.begin(), tmp.end());
	}
}

void Algebra::Prosess_Call_Parameters(Node* n)
{
}

void Algebra::Prosess_Paranthesis(Node* n)
{
	if (!n->is(CONTENT_NODE))
		return;
	Algebra a(n, &n->Childs);
}

void Algebra::Prosess_Conditions(Node* n, int i)
{
	if (!n->Has({ IF_NODE, ELSE_IF_NODE, ELSE_NODE }))
		return;

	bool TMP = Optimized;
	if (!n->is(ELSE_NODE)) {
		Optimized = false;
		while (true) {
			Algebra a(n, &n->Parameters);
			if (!Optimized)
				break;
			Optimized = false;
		}
		Optimized = TMP;
	}

	TMP = Optimized;
	Optimized = false;
	while (true) {
		Algebra a(n, &n->Childs);
		if (!Optimized)
			break;
		Optimized = false;
	}
	Optimized = TMP;

	for (auto& j : n->Parameters) {
		if (j->Header.size() > 0) {
			Input->insert(Input->begin() + i, j->Header.begin(), j->Header.end());
		}
	}
}

void Algebra::Inline_Variables(int i)
{
	//<summary>
	//finds a math equatin and tryes to inline the used variables set Values.
	//</summary>

	vector<Node*> Linear_Ast;
	if (Input->at(i)->Has({ASSIGN_OPERATOR_NODE, OPERATOR_NODE, CONDITION_OPERATOR_NODE, BIT_OPERATOR_NODE, ARRAY_NODE, LOGICAL_OPERATOR_NODE })) {
		if (Input->at(i)->Name != "=")
			Linear_Ast = Input->at(i)->Get_all({OBJECT_NODE, OBJECT_DEFINTION_NODE});
		else {
			if (Input->at(i)->is("ptr") != -1)
				return;
			Linear_Ast = Input->at(i)->Right->Get_all({OBJECT_NODE, OBJECT_DEFINTION_NODE });
		}
	}
	else {
		return;
	}

	for (int j = 0; j < Linear_Ast.size(); j++) {
		if (Linear_Ast[j]->is(CALL_NODE)) {
			for (auto k : Linear_Ast[j]->Parameters) {
				vector<Node*> tmp = k->Get_all({ OPERATOR_NODE, CONDITION_OPERATOR_NODE, BIT_OPERATOR_NODE, ARRAY_NODE, LOGICAL_OPERATOR_NODE, OBJECT_DEFINTION_NODE, OBJECT_NODE, PARAMETER_NODE });
				Linear_Ast.insert(Linear_Ast.end(), tmp.begin(), tmp.end());
			}		
		}
	}

	for (Node* n : Linear_Ast) {
		if (!n->Has({OBJECT_NODE, OBJECT_DEFINTION_NODE}))
			continue;
		Node* d = Scope->Find(n->Name, Scope, OBJECT_DEFINTION_NODE);
		//if this is nullptr is means it is defined outside this scope.
		if (d != nullptr)
			if (d->Current_Value != nullptr) {
				if (Scope->Find(d->Current_Value->Var->Scope, Scope) == nullptr)
					continue;
				if (d->Current_Value->Var->is(NUMBER_NODE)) {
					if (n->Context->Name == "-" || n->Context->Name == "/" || n->Context->Name == "<" || n->Context->Name == ">" || n->Context->Name == "!<" || n->Context->Name == "!>" || n->Context->Name == "<=" || n->Context->Name == ">=") {
						bool Has_Other_Variables = false;
						for (auto j : n->Context->Get_all({ OBJECT_DEFINTION_NODE, OBJECT_NODE, PARAMETER_NODE })) {
							if (j != n)
								Has_Other_Variables = true;
						}
						if (Has_Other_Variables) {
							d->Cant_Inline = true;
							continue;
						}
					}
				}
				//set right current coefficient value
				//n = -1
				//a = -n
				//Node* represents the -1 and n on this example
				//Node* n is same as the -n variable on example
				if (d->Current_Value->Expiring_Index >= i) {
					//do unwrap manuever if content is optimized into singlurar content: (1 + 2) -> (3)
					if (d->Current_Value->Var->is(CONTENT_NODE))
						if (!d->Current_Value->Var->Childs[0]->Has({OPERATOR_NODE, ASSIGN_OPERATOR_NODE, CONDITION_OPERATOR_NODE, BIT_OPERATOR_NODE, LOGICAL_OPERATOR_NODE, ARRAY_NODE}))
							*d->Current_Value->Var = *d->Current_Value->Var->Childs[0];
					//d->Current_Value->Var->Coefficient *= n->Coefficient;
					d->Current_Value->Var->Context = n->Context;
					d->Current_Value->Var->Scope = n->Scope;
					*n = *d->Current_Value->Var;
					d->Inlined = true;
					//maybe this is useless:
					n->Inlined = false;
					Optimized = true;
				}
			}
	}

}

void Algebra::Reduce_Operator_Operations(Node* n)
{
	if (!n->is(OPERATOR_NODE) && !n->is(CONDITION_OPERATOR_NODE) && !n->is(ASSIGN_OPERATOR_NODE))
		return;
	
	vector<Node*> Variables = n->Get_all({OBJECT_NODE, PARAMETER_NODE});
	// 2b^2 + b = b^2 + b
	// 2b^2 + b - b = b^2
	// 2b^2 - b^2 = 0
	// b^2 = 0

	// 2b^2 + b < -b^2 - b
	// 2b^2 + b^2 + b + b < 0
	// 3b^2 + 2b < 0

	//2b^2 / b < -b^2 * b
	//2b^2 / b < -b^3 
	//now go through one side and try to delete one coefficient amount of that variable on both sides.
	for (Node* v : Variables) {
		if (v->is(OBJECT_NODE) || v->is(OBJECT_DEFINTION_NODE)) {
			if (v->Coefficient == 0)
				continue;
			//TODO: make a fucking flag for those Karens that want to crash theyre exe, by dividing by 0.
			//if (v->Holder->Name == "/")	//stuff can go wrong if the v value is 0
			//	continue;
			for (Node* other : Variables) {
				if (v == other)
					continue;
				if (v->Name != other->Name)
					continue;
				if (other->Coefficient == 0)
					continue;
				if ((v->Fetcher != nullptr && other->Fetcher != nullptr) && v->Fetcher->Name != other->Fetcher->Name)
					continue;
				if (v->Context == nullptr || other->Context == nullptr || v->Context->is(ASSIGN_OPERATOR_NODE) || other->Context->is(ASSIGN_OPERATOR_NODE))
					continue;
				//decide wich one is in wich side
				Node* l = v;
				Node* r = other;
				if (v->Context->Right == v && other->Context->Left == other) {
					r = v;
					l = other;
				}
				if (v->Context->Name == "+" || v->Context->Name == "-") {
					if (other->Order != v->Order)
						continue;
					//here it affects the coefficient of other
					l->Coefficient -= r->Coefficient;
					r->Coefficient = 0;
					goto Next;
				}
				/*else if (v->Holder->Name == "*" && l == v->Holder->Left && r == v->Holder->Right) {
					//here it affects the order of other
					l->Order += r->Order;
					l->Coefficient *= r->Coefficient;
					r->Coefficient = 0;
					goto Next;
				}
				else if (v->Holder->Name == "/" && l == v->Holder->Left && r == v->Holder->Right) {
					//here it affects the order of other
					r->Order -= l->Order;
					r->Coefficient /= l->Coefficient;
					l->Coefficient = 0;
					goto Next;
				}*/
			}
		}
	Next:;
	}

}

void Algebra::Clean_Inlined(int i)
{
	if (!Input->at(i)->is(OPERATOR_NODE) && !Input->at(i)->is(ASSIGN_OPERATOR_NODE))
		return;
	if (Input->at(i)->Name != "=")
		return;
	Node* l = Input->at(i)->Get_Most_Left();
	if (Scope->Find(l->Name, l->Get_Most_Left()->Get_Right_Parent())->Inlined == false)
		return;
	if (Scope->Find(l->Name, l->Get_Most_Left()->Get_Right_Parent())->Cant_Inline)
		return;

	//!!! MUST COMBINE THE CALLATION AND THE CLASS FETCHER!!!
	vector<Node*> Calls = Input->at(i)->Has(CALL_NODE);
	Optimized = true;

	Input->erase(Input->begin() + i);

	if (Calls.size() > 0) {
		//put the function callations into the deleted operations location else.
		Input->insert(Input->begin() + i, Calls.begin(), Calls.end());
	}

	if (i < Input->size())
		Clean_Inlined(i);
		
	return;
}

void Algebra::Set_Defining_Value(int i)
{
	//x = 12 + a
	//y = x * 2
	//x = 12
	//z = x * 4
	if (!Input->at(i)->is(ASSIGN_OPERATOR_NODE))
		return;
	//ignore arrays
	if (Input->at(i)->Left->is(ARRAY_NODE))
		return;

	if (Input->at(i)->is("ptr") != -1)
		return;

	if (Input->at(i)->Left->Fetcher != nullptr)
		return;

	//callations sould not be inlined because theyre return value may vary.
	if (Input->at(i)->Get_all(CALL_NODE).size() > 0)
		return;

	if (Is_Untrustworthy(Input->at(i)->Left))
		return;

	//if the right side is a operator wrap it in a parenthesis just because the '-' prefix!!
	Node* right = Input->at(i)->Right;

	if (Input->at(i)->Right->is(OPERATOR_NODE) || Input->at(i)->Right->is(CONDITION_OPERATOR_NODE) || Input->at(i)->Right->is(BIT_OPERATOR_NODE)) {
		//a = 1+2
		//b = a * 3 --> b = (1+2) *3;		maintain the math order
		right = new Node(CONTENT_NODE, right->Location);
		right->Paranthesis_Type = '(';
		right->Childs.push_back(Input->at(i)->Right);
		right->Scope = Input->at(i);
		right->Context = Input->at(i)->Right;
	}
	//give the defining node the current set-val.
	//this wont work with array offsets, because this doesnt save the current offsetter value to check later on.
	Variable_Descriptor* description = new Variable_Descriptor(right, i, *Input);
	Scope->Find(Input->at(i)->Left->Name, Input->at(i)->Left)->Current_Value = description;

	return;
}

void Algebra::Set_Coefficient_Value(int i)
{
	//a = x * 2
	//b = x * 2 + a
	if (!Input->at(i)->Has({OPERATOR_NODE, ASSIGN_OPERATOR_NODE, CONDITION_OPERATOR_NODE, ARRAY_NODE, BIT_OPERATOR_NODE, LOGICAL_OPERATOR_NODE}))
		return;
	//return;	//depricated
	vector<Node*> linear_ast = Input->at(i)->Get_all({ OPERATOR_NODE, ASSIGN_OPERATOR_NODE, CONDITION_OPERATOR_NODE, ARRAY_NODE, BIT_OPERATOR_NODE, LOGICAL_OPERATOR_NODE , OBJECT_DEFINTION_NODE, OBJECT_NODE, PARAMETER_NODE});

	Node* Coefficient = nullptr;
	Node* Variable = nullptr;
	Node* Operator = nullptr;

	//now try to pair these
	for (int j = 0; j < linear_ast.size(); j++) {
		if (linear_ast[j]->is(NUMBER_NODE))
			Coefficient = linear_ast[j];
		else if (linear_ast[j]->Has({OBJECT_DEFINTION_NODE, OBJECT_NODE, PARAMETER_NODE}))
			Variable = linear_ast[j];
		else if (linear_ast[j]->Name == "*")
			Operator = linear_ast[j];
		else {
			//if it is not either one of those the conditions are not met and then just zero all.
			Coefficient = nullptr;
			Variable = nullptr;
			Operator = nullptr;
		}
		if ((Coefficient != nullptr) && (Variable != nullptr) && (Operator != nullptr)) {

			linear_ast.erase(linear_ast.begin() + j - 2, linear_ast.begin() + j);

			//now apply the coefficient to the variable
			Variable->Coefficient = atoi(Coefficient->Name.c_str()) * Coefficient->Coefficient;
			Variable->Context = Operator->Context;

			/*if (Variable->Holder->Name == "-") {
				Variable->Coefficient *= -1;
				Variable->Holder->Name = "+";
			}*/


			*Operator = *Variable;
			//for next iteration
			linear_ast[j - 2] = Variable;

			j -= 2;
		}
	}
}

void Algebra::Reset_Defining_Value(int i)
{
	if (!Input->at(i)->is(POSTFIX_NODE) && !Input->at(i)->is(PREFIX_NODE))
		return;

	Node* Modified = Input->at(i)->Left;
	if (Input->at(i)->is(PREFIX_NODE))
		Modified = Input->at(i)->Right;

	//i++ | ++i -> defining val = 0

	if (Modified->Has({ OPERATOR_NODE, ARRAY_NODE }))
		Modified = Modified->Get_Most_Right();

	Scope->Find(Modified, Modified->Scope)->Current_Value = nullptr;
}

void Algebra::Clean_Unused()
{
	for (int i = 0; i < Scope->Defined.size(); i++) {
		if (Scope->Defined[i]->is(PARAMETER_NODE))
			continue;

		for (auto& j : Scope->Childs)	//							   this is for function pointters
			for (auto& k : j->Get_all({ OBJECT_DEFINTION_NODE, OBJECT_NODE, CALL_NODE }))
				if (k->Name == Scope->Defined[i]->Name)
					Scope->Defined[i]->Calling_Count++;

		//because the inlined code can also exist in parameters go and search it too.
		for (auto& j : Scope->Parameters)	//							   this is for function pointters
			for (auto& k : j->Get_all({ OBJECT_DEFINTION_NODE, OBJECT_NODE, CALL_NODE }))
				if (k->Name == Scope->Defined[i]->Name)
					Scope->Defined[i]->Calling_Count++;

		if (Scope->Defined[i]->Calling_Count == 0)
			Scope->Defined.erase(Scope->Defined.begin() + i);

	}
}

void Algebra::Operate_Coefficient_Constants(Node* op)
{
	//b = 2x * -2x
	//return; //depricated
	if (!op->is(OPERATOR_NODE) && !op->is(ASSIGN_OPERATOR_NODE))
		return;
	if (op->Left->is(OPERATOR_NODE) || op->Left->is(ASSIGN_OPERATOR_NODE))
		Operate_Coefficient_Constants(op->Left);
	if (op->Right->is(OPERATOR_NODE))
		Operate_Coefficient_Constants(op->Right);

	if (op->Left->Name != op->Right->Name)
		return;
	if (op->Left->Coefficient == 0 || op->Right->Coefficient == 0)
		return;

	if (op->Name != "*" && op->Name != "/")
		return;

	Node* New_Num;

	long left = op->Left->Coefficient;
	long right = op->Right->Coefficient;

	
	if (op->Name == "/") {
		//3b / b == 3
		if (op->Left->Order == op->Right->Order) {
			long double remainder = left / right;
			New_Num = new Node(NUMBER_NODE, op->Location);

			if (remainder - (long long)remainder == 0)
				New_Num->Name = to_string((long long)remainder);
			else
				New_Num->Name = to_string(remainder);
		}
		else {
			//3b / b^2 == 3b^-1
			long double coefficient = left / right;
			string Name = op->Left->Name;
			long Order = op->Left->Order - op->Right->Order;
			New_Num = new Node(OBJECT_NODE, op->Location);
			New_Num->Name = Name;
			New_Num->Coefficient = coefficient;
			New_Num->Order = Order;
		}
		New_Num->Context = op->Context;
		New_Num->Scope = op->Scope;
	}
	else if (op->Name == "*") {
		//3b * b == 3b^2
		//3b * b^2 == 3b^3
		long double Coefficient = left * right;
		string Name = op->Left->Name;
		long Order = op->Left->Order + op->Right->Order;
		New_Num = new Node(OBJECT_NODE, op->Location);
		New_Num->Name = Name;
		New_Num->Coefficient = Coefficient;
		New_Num->Order = Order;
		New_Num->Context = op->Context;
		New_Num->Scope = op->Scope;
	}


	*op = *New_Num;

	if (op->Coefficient == 0) {
		Node* num = new Node(NUMBER_NODE, op->Location);
		num->Name = "0";
		*op = *num;
	}

	Optimized = true;

}

void Algebra::Operate_Distant_Coefficients(Node* op)
{
	if (!op->Has({OPERATOR_NODE, ASSIGN_OPERATOR_NODE, BIT_OPERATOR_NODE, CONDITION_OPERATOR_NODE, ARRAY_NODE, LOGICAL_OPERATOR_NODE}))
		return;

	//((3 / b) - b) -> (3 / (b - b)) -> 3
	//this function tryes to find next to eachother variables and computes the result


	vector<Node*> Linear = op->Get_all({ OPERATOR_NODE, ASSIGN_OPERATOR_NODE, CONDITION_OPERATOR_NODE, ARRAY_NODE, BIT_OPERATOR_NODE, LOGICAL_OPERATOR_NODE , OBJECT_DEFINTION_NODE, OBJECT_NODE, PARAMETER_NODE });
	vector<Node*> Coefficients;
	Node* Operator = nullptr;
	for (auto i : Linear) {
		if (i->is(OPERATOR_NODE))
			Operator = i;
		else if (i->is(OBJECT_NODE)) {
			Coefficients.push_back(i);
		}
		else {
			Operator = nullptr;
			Coefficients.clear();
			continue;
		}

		if (Operator != nullptr && Coefficients.size() == 2) {

			Node* New_Num;

			if (Coefficients[0]->Name != Coefficients[1]->Name) {
				Operator = nullptr;
				Coefficients.clear();
				continue;
			}
			//find the other operators that may stuck under the operator override.
			//(6 + b) - (b * 3)
			//(6 + b) - 3b
			//b - 3b --> the 6 has been forgotten
			Node* Forgotten_Operator = nullptr;
			bool Forgotten_Operator_is_Left_Side = true;
			if (Operator->Left == Coefficients[0] && Operator->Right != Coefficients[1])
				Forgotten_Operator = Operator->Right;
			else if (Operator->Left != Coefficients[0] && Operator->Right == Coefficients[1]) {
				Forgotten_Operator_is_Left_Side = false;
				Forgotten_Operator = Operator->Left;
			}
				
			long left = Coefficients[0]->Coefficient;
			long right = Coefficients[1]->Coefficient;

			if (Operator->Name == "/") {
				//3b / b == 3
				if (Coefficients[0]->Order == Coefficients[1]->Order) {
					long double remainder = left / right;
					New_Num = new Node(NUMBER_NODE, Operator->Location);

					if (remainder - (long long)remainder == 0)
						New_Num->Name = to_string((long long)remainder);
					else
						New_Num->Name = to_string(remainder);
				}
				else {
					//3b / b^2 == 3b^-1
					long double coefficient = left / right;
					string Name = Coefficients[0]->Name;
					long Order = Coefficients[0]->Order - Coefficients[1]->Order;
					New_Num = new Node(OBJECT_NODE, Operator->Location);
					New_Num->Name = Name;
					New_Num->Coefficient = coefficient;
					New_Num->Order = Order;
				}
				New_Num->Context = Operator->Context;
				New_Num->Scope = Operator->Scope;
			}
			else if (Operator->Name == "*") {
				//3b * b == 3b^2
				//3b * b^2 == 3b^3
				long double Coefficient = left * right;
				string Name = Coefficients[0]->Name;
				long Order = Coefficients[0]->Order + Coefficients[1]->Order;
				New_Num = new Node(OBJECT_NODE, Operator->Location);
				New_Num->Name = Name;
				New_Num->Coefficient = Coefficient;
				New_Num->Order = Order;
				New_Num->Context = Operator->Context;
				New_Num->Scope = Operator->Scope;
			}
			else if (Operator->Name == "+") {
				if (Coefficients[0]->Order != Coefficients[1]->Order)
					continue;
				//here it affects the coefficient of other
				long long Coefficient = Coefficients[0]->Coefficient + Coefficients[1]->Coefficient;
				New_Num = new Node(OBJECT_NODE, Operator->Location);
				New_Num->Name = Coefficients[0]->Name;
				New_Num->Coefficient = Coefficient;
				New_Num->Order = Coefficients[0]->Order;
				New_Num->Context = Operator->Context;
				New_Num->Scope = Operator->Scope;
			}
			else if (Operator->Name == "-") {
				if (Coefficients[0]->Order != Coefficients[1]->Order)
					continue;
				//here it affects the coefficient of other				
				long long Coefficient = Coefficients[0]->Coefficient - Coefficients[1]->Coefficient;
				New_Num = new Node(OBJECT_NODE, Operator->Location);
				New_Num->Name = Coefficients[0]->Name;
				New_Num->Coefficient = Coefficient;
				New_Num->Order = Coefficients[0]->Order;
				New_Num->Context = Operator->Context;
				New_Num->Scope = Operator->Scope;
			}

			if (Forgotten_Operator != nullptr) {
				Operator->Context = Forgotten_Operator;
				if (Forgotten_Operator_is_Left_Side) {
					//put the operator into forgotten operators Left side
					Forgotten_Operator->Left = New_Num;
					New_Num->Context = Forgotten_Operator;
				}
				else {
					Forgotten_Operator->Right = New_Num;
					New_Num->Context = Forgotten_Operator;
				}
				*Operator = *Forgotten_Operator;
			}
			else
				*Operator = *New_Num;
		}
	}

}

void Algebra::Operate_Numbers_As_Constants(Node* op)
{
	if (!op->is(OPERATOR_NODE) && !op->is(ASSIGN_OPERATOR_NODE) && !op->is(BIT_OPERATOR_NODE)) // && !op->is(CONDITION_OPERATOR_NODE))
			return;
	if (op->Left->is(OPERATOR_NODE) || op->Left->is(BIT_OPERATOR_NODE)) // || op->Left->is(CONDITION_OPERATOR_NODE))
		Operate_Numbers_As_Constants(op->Left);
	else if (op->Left->is(CONTENT_NODE)) {
		for (Node* i : op->Left->Childs)
			Operate_Numbers_As_Constants(i);
		if (op->Left->Childs.size() == 1 && op->Left->Childs[0]->is(NUMBER_NODE)) {
			op->Left->Childs[0]->Coefficient *= op->Left->Coefficient;
			op->Left->Childs[0]->Context = op->Left->Context;
			*op->Left = *op->Left->Childs[0];
		}
	}
	if (op->Right->is(OPERATOR_NODE) || op->Right->is(BIT_OPERATOR_NODE)) // || op->Right->is(CONDITION_OPERATOR_NODE))
		Operate_Numbers_As_Constants(op->Right);
	else if (op->Right->is(CONTENT_NODE)) {
		for (Node* i : op->Right->Childs)
			Operate_Numbers_As_Constants(i);
		if (op->Right->Childs.size() == 1 && op->Right->Childs[0]->is(NUMBER_NODE)) {
			op->Right->Childs[0]->Coefficient *= op->Right->Coefficient;
			op->Right->Childs[0]->Context = op->Right->Context;
			*op->Right = *op->Right->Childs[0];
		}
	}

	if (!op->Left->is(NUMBER_NODE))
		return;
	if (!op->Right->is(NUMBER_NODE))
		return;

	Node* New_Num = new Node(NUMBER_NODE, op->Location);

	//set sizes
	if (op->Left->Size < op->Right->Size)
		New_Num->Size = op->Right->Size;
	else
		New_Num->Size = op->Left->Size;

	if (op->Left->Format == "decimal" || op->Right->Format == "decimal") {
		long double left = atof(op->Left->Name.c_str());
		long double right = atof(op->Right->Name.c_str());

		New_Num->Format = "decimal";

		if (op->Name == "+")
			New_Num->Name = to_string(left + right);
		else if (op->Name == "-")
			New_Num->Name = to_string(left - right);
		else if (op->Name == "*")
			New_Num->Name = to_string(left * right);
		else if (op->Name == "/")
			New_Num->Name = to_string(left / right);
		else if (op->Name == "<<")
			New_Num->Name = to_string((long long)left << (long long)right);
		else if (op->Name == ">>")
			New_Num->Name = to_string((long long)left >> (long long)right);
		else if (op->Name == "&")
			New_Num->Name = to_string((long long)left & (long long)right);
		else if (op->Name == "|")
			New_Num->Name = to_string((long long)left | (long long)right);
		else if (op->Name == "¤")
			New_Num->Name = to_string((long long)left ^ (long long)right);
		else if (op->Name == "%")
			New_Num->Name = to_string((long long)left % (long long)right);
		else if (op->Name == "^")
			New_Num->Name = to_string(pow(left, right));
	}
	else {
		long left = atol(op->Left->Name.c_str());
		long right = atol(op->Right->Name.c_str());

		if (op->Name == "+")
			New_Num->Name = to_string(left + right);
		else if (op->Name == "-")
			New_Num->Name = to_string(left - right);
		else if (op->Name == "*")
			New_Num->Name = to_string(left * right);
		else if (op->Name == "/")
			New_Num->Name = to_string(left / right);
		else if (op->Name == "<<")
			New_Num->Name = to_string(left << right);
		else if (op->Name == ">>")
			New_Num->Name = to_string(left >> right);
		else if (op->Name == "&")
			New_Num->Name = to_string(left & right);
		else if (op->Name == "|")
			New_Num->Name = to_string(left | right);
		else if (op->Name == "¤")
			New_Num->Name = to_string(left ^ right);
		else if (op->Name == "%")
			New_Num->Name = to_string(left % right);
		else if (op->Name == "^")
			New_Num->Name = to_string(pow(left, right));
	}

	New_Num->Context = op->Context;
	New_Num->Scope = op->Scope;
	*op = *New_Num;
	Optimized = true;
}

Node* Algebra::Operate_Constants(Node* l, Node* r) {

	Node* tmp;
	if (r->Context->Left == r) {
		tmp = l;
		l = r;
		r = tmp;
	}

	Node* New_Num = new Node(NUMBER_NODE, l->Location);
	New_Num->Context = l->Context;
	New_Num->Scope = l->Scope;
	//set sizes
	if (l->Size < r->Size)
		New_Num->Size = r->Size;
	else
		New_Num->Size = l->Size;

	if (l->Format == "decimal") {
		long double left = atof(l->Name.c_str());
		long double right = atof(r->Name.c_str());

		New_Num->Format = "decimal";

		if (r->Coefficient > 0)
			New_Num->Name = to_string(left + right);
		else
			New_Num->Name = to_string(left - right);
	}
	else {
		long left = atoi(l->Name.c_str());
		long right = atoi(r->Name.c_str());

		if (r->Coefficient > 0)
			New_Num->Name = to_string(left + right);
		else
			New_Num->Name = to_string(left - right);
	}

	return New_Num;
}

void Algebra::Combine_Scattered(Node* op) {
	if (!op->is(OPERATOR_NODE) && !op->is(ASSIGN_OPERATOR_NODE) && !op->is(CONDITION_OPERATOR_NODE) && !op->is(BIT_OPERATOR_NODE))
		return;

	vector<Node*> list = op->Get_all({ OPERATOR_NODE, ASSIGN_OPERATOR_NODE, CONDITION_OPERATOR_NODE, ARRAY_NODE, BIT_OPERATOR_NODE, LOGICAL_OPERATOR_NODE , OBJECT_DEFINTION_NODE, OBJECT_NODE, PARAMETER_NODE });

	vector<int> Number_Indices;

	//find and save the indices of constants.
	for (int i = 0; i < list.size(); i++)
		if (list[i]->is(NUMBER_NODE))
			Number_Indices.push_back(i);

	//now check if you can operate those two constants together.
	for (int i = 0; i < Number_Indices.size(); i++) {
		if (Number_Indices[i] - 1 > 0 && (list[(size_t)Number_Indices[i] - 1]->Name != "+" && list[(size_t)Number_Indices[i] - 1]->Name != "-")) {
			if ((size_t)Number_Indices[i] + 1 < list.size() && (list[(size_t)Number_Indices[i] + 1]->Name != "+" && list[(size_t)Number_Indices[i] + 1]->Name != "-"))
				Number_Indices.erase(Number_Indices.begin() + i--);
			else if ((size_t)Number_Indices[i] + 1 >= list.size())
				Number_Indices.erase(Number_Indices.begin() + i--);
		}
		else if ((size_t)Number_Indices[i] + 1 < list.size() && (list[(size_t)Number_Indices[i] + 1]->Name != "+" && list[(size_t)Number_Indices[i] + 1]->Name != "-"))
			Number_Indices.erase(Number_Indices.begin() + i--);
	}

	for (int i = 0; (size_t)i+1 < Number_Indices.size(); i += 2) {
		*list[Number_Indices[i]] = *Operate_Constants(list[Number_Indices[i]], list[Number_Indices[(size_t)i + 1]]);
		//now remove the other constant
		Node* other = Get_Other_Pair(op, list[Number_Indices[(size_t)i + 1]]);
		*other->Context = *list[Number_Indices[i]];
	}
}

Node* Algebra::Get_Other_Pair(Node* ast, Node* other) {
	if (ast->Left == other)
		return ast->Right;
	else if (ast->Right == other)
		return ast->Left;
	else if (ast->Left != nullptr && Get_Other_Pair(ast->Left, other) != nullptr)
		return Get_Other_Pair(ast->Left, other);
	else if (ast->Right != nullptr && Get_Other_Pair(ast->Right, other) != nullptr)
		return Get_Other_Pair(ast->Right, other);
	else if (ast->is(CONTENT_NODE)) {
		if (ast->Childs[0]->is(OPERATOR_NODE) || ast->Childs[0]->is(ASSIGN_OPERATOR_NODE) || ast->Childs[0]->is(CONDITION_OPERATOR_NODE) || ast->Childs[0]->is(BIT_OPERATOR_NODE)) {
			if (Get_Other_Pair(ast->Childs[0], other) != nullptr)
				return Get_Other_Pair(ast->Childs[0], other);
		}
		else if (ast->Childs[0] == other){
			if (ast->Context->Left == ast)
				return ast->Context->Right;
			else if (ast->Context->Right == ast)
				return ast->Context->Left;
		}
	}
	return nullptr;
}

void Algebra::Un_Wrap_Parenthesis(Node* p)
{
	if (p->is(OPERATOR_NODE) || p->is(ASSIGN_OPERATOR_NODE) || p->is(CONDITION_OPERATOR_NODE) || p->is(BIT_OPERATOR_NODE)) {
		Un_Wrap_Parenthesis(p->Left);
		Un_Wrap_Parenthesis(p->Right);
	}
	else if (p->is(CONTENT_NODE))
		Un_Wrap_Parenthesis(p->Childs[0]);
	if (!p->is(CONTENT_NODE))
		return;
	if (p->Childs.size() > 1)
		return;
	//(b * 3)
	//(3b)
	//3b
	if (!p->is(OPERATOR_NODE) && !p->is(ASSIGN_OPERATOR_NODE) && !p->is(CONDITION_OPERATOR_NODE) && !p->is(BIT_OPERATOR_NODE)) {
		p->Childs[0]->Context = p->Context;
		p->Childs[0]->Scope = p->Scope;
		p->Childs[0]->Coefficient *= p->Coefficient;
		p->Childs[0]->Order *= p->Order;
		p->Childs[0]->Cast_Type = p->Cast_Type;
		*p = *p->Childs[0];

		//Optimized = true;
	}
}

bool Algebra::Is_Untrustworthy(Node* v)
{
	if (!v->Scope->is(WHILE_NODE))
		return false;

	for (auto i : v->Scope->Parameters)
		for (auto j : i->Get_all(OBJECT_NODE)) {
			if (j->Context == nullptr)
				continue;
			else if (j->Context->Has({ POSTFIX_NODE, PREFIX_NODE }))
				return true;
		}
	return false;
}

void Algebra::Fix_Coefficient_Into_Real_Operator(Node* n)
{
	//here we will fix the coefficient into a real operator as the name yells.
	if (n->is(OPERATOR_NODE) || n->is(CONDITION_OPERATOR_NODE) || n->is(ASSIGN_OPERATOR_NODE)) {
		if (n->Left->Coefficient != 0)
			Fix_Coefficient_Into_Real_Operator(n->Left);
		else {
			//this is needed to be cleaned!!
			//and remember the ((a <-- this is no more) - 1) <-- so this is -1 after the clean!!
			n->Right->Context = n->Context;
			*n = *n->Right;
			return;
		}
		if (n->Right->Coefficient != 0)
			Fix_Coefficient_Into_Real_Operator(n->Right);
		else {
			//this is needed to be cleaned!!
			//and remember the ((a <-- this is no more) - 1) <-- so this is -1 after the clean!!
			n->Left->Context = n->Context;
			*n = *n->Left;
			return;
		}
	}
	else if (n->is(CONTENT_NODE)) {
		for (auto j : n->Childs)
			Fix_Coefficient_Into_Real_Operator(j);
	}
	//only variables are accepted
	if (!n->is(OBJECT_NODE) && !n->is(PARAMETER_NODE))
		return;
	if (n->Coefficient == 1 || n->Coefficient == -1)
		return;

	//make operator that is going to hold the new coefficient and the variable
	Node* New_Operator = new Node(OPERATOR_NODE, n->Location);
	New_Operator->Name = "*";
	New_Operator->Scope = n->Scope;
	New_Operator->Context = n->Context;

	//making the coefficient into a real number token
	Node* Coefficient = new Node(NUMBER_NODE, n->Location);
	Coefficient->Name = to_string(n->Coefficient);
	Coefficient->Scope = n->Scope;
	Coefficient->Context = n->Context;

	//now clean the coefficient
	n->Coefficient = 1;

	//transform the negative holder into positive operator
	if (n->Context != nullptr && n->Context->Name == "-")
		n->Context->Name = "+";

	//combine
	//this is because the override later
	New_Operator->Left = new Node(OBJECT_NODE, n->Location);

	*New_Operator->Left = *n;
	New_Operator->Right = Coefficient;

	Node* Parenthesis = new Node(CONTENT_NODE, n->Location);
	Parenthesis->Childs.push_back(New_Operator);
	Parenthesis->Paranthesis_Type = '(';

	Parenthesis->Context = New_Operator->Context;
	Parenthesis->Scope = New_Operator->Scope;

	New_Operator->Context = Parenthesis;
	New_Operator->Scope = Parenthesis;

	*n = *Parenthesis;

	return;
}

void Algebra::Fix_Order_Into_Real_Operator(Node* n)
{
	//here we will fix the coefficient into a real operator as the name yells.
	if (n->is(OPERATOR_NODE) || n->is(CONDITION_OPERATOR_NODE) || n->is(ASSIGN_OPERATOR_NODE)) {
		if (n->Left->Order != 0)
			Fix_Order_Into_Real_Operator(n->Left);
		else {
			//this is needed to be cleaned!!
			//and remember the ((a <-- this is no more) - 1) <-- so this is -1 after the clean!!
			*n = *n->Right;
			return;
		}
		if (n->Right->Order != 0)
			Fix_Order_Into_Real_Operator(n->Right);
		else {
			//this is needed to be cleaned!!
			//and remember the ((a <-- this is no more) - 1) <-- so this is -1 after the clean!!
			*n = *n->Left;
			return;
		}
	}
	//only variables are accepted
	if (!n->is(OBJECT_NODE) && !n->is(PARAMETER_NODE))
		return;
	if (n->Order == 1)
		return;

	int Order = n->Order;
	n->Order = 1;
	Node* L = n->Copy_Node(n, n->Scope);
	for (int i = 0; i < Order; i++) {
		//(((a * a) * a)...)
		Node* mul = new Node(OPERATOR_NODE, "*", n->Location);
		mul->Left = L;
		mul->Left->Context = mul;	//give the previus mul this as a holder.
		mul->Right = n->Copy_Node(n, n->Scope);	//multiply self by self
		mul->Scope = n->Scope;

		L = mul;
	}

	//give the last mul the n->holder
	L->Context = n->Context;
	
	*n = *L;
	return;
}
C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Cpp\Parser\Analyzer.cpp" 
#include "../../H/Parser/Analyzer.h"

Analyzer::Analyzer()
{
	Factory();
}

void Analyzer::Factory()
{
	//gather information about the AST that we have made
	Detect_Abnormal_Start_Address();
	List_All_Exported();

	for (auto* f : Start_Of_Proccesses) {
		Calling_Count_Incrementer(f);
	}
}

void Analyzer::Detect_Abnormal_Start_Address()
{
	if (sys->Info.Format == "exe") {
		Node* Main = Global_Scope->Find("main", Global_Scope, FUNCTION_NODE);

		Start_Of_Proccesses.push_back(Main);
	}
}

void Analyzer::List_All_Exported()
{
	for (auto *f : Global_Scope->Defined)
		if (f->is(FUNCTION_NODE) && f->is("export") != -1)
			Start_Of_Proccesses.push_back(f);
}


vector<Node*> Callin_Trace;
void Analyzer::Calling_Count_Incrementer(Node* f)
{
	for (auto* i : Callin_Trace)
		if (i == f)
			return;

	Callin_Trace.push_back(f);

	if (f->Is_Template_Object)
		return;

	//nevertheless we always want to increment the calling count 
	//be it by the start list, or calld for.
	f->Calling_Count++;

	for (auto* c : f->Childs) {
		for (auto* i : c->Get_all({CALL_NODE})) {
			Calling_Count_Incrementer(i->Function_Implementation);
		}
	}

	Callin_Trace.pop_back();
}

C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Cpp\Parser\Parser.cpp" 
#include "../../H/Parser/Parser.h"
#include "../../H/UI/Safe.h"
#include "../../H/Docker/Mangler.h"
#include "../../H/UI/Usr.h"
//this is for unamed parameters.
int arg_count = 0;
extern Usr* sys;

vector<int> Parser::Get_Amount_Of(int i, long Flag, bool All_in_Same_Line)
{
	//<summary>
	//check from the index to next and counts-
	//how many componets match the flag given
	//</summary>
	vector<int> Indexes;
	for (; i < Input.size(); i++) {
		if (Input[i].is(Flag))
			Indexes.push_back(i);
		else
			if (Input[i].is(Flags::END_COMPONENT) ||
				(Input[i].is(Flags::COMMENT_COMPONENT))) {
				if (All_in_Same_Line)
					break;
				continue;
			}
			else
				break;
	}
	return Indexes;
}

vector<int> Parser::Get_Amount_Of(int i, vector<int> Flags, bool All_in_Same_Line)
{
	vector<int> Indexes;
	for (; i < Input.size(); i++) {
		for (auto f : Flags) {
			if (Input[i].is(f)) {
				Indexes.push_back(i);
				goto Success;
			}
		}
		//this happends if there was no correlatoin between the flags and the input at i
		if (Input[i].is(Flags::END_COMPONENT) ||
			(Input[i].is(Flags::COMMENT_COMPONENT))) {
			if (All_in_Same_Line)
				break;
			continue;
		}
		else
			break;
	Success:;
	}
	return Indexes;
}

vector<Component> Parser::Get_Inheritting_Components(int i)
{
	//import int ptr func a
	vector<Component> Result;
	for (; i < Input.size(); i++) {
		if (Input[i].is(Flags::KEYWORD_COMPONENT) || (Scope->Find(Input[i].Value, Scope, false) != nullptr))
			Result.push_back(Input[i]);
		else 
			break;
	}
	return Result;
}

void Parser::Combine_Dot_In_Member_Functions(int& i)
{
	if (!Scope->is(CLASS_NODE) || Scope->is("static") == -1)
		return;
	if (Input[i].Value != ".")
		return;

	Math_Pattern(i, { "." }, OPERATOR_NODE, true);
}

void Parser::Template_Pattern(int& i)
{
	if (Input[i].Value != "<")
		return;
	//if (s < 1 && s > 0)
	int j = i;
	int This_Scopes_Open_Template_Operators = 1;
	while (Input[j].Value != ">" || This_Scopes_Open_Template_Operators > 0) {
		j++;
		if (Input[j].Value == "<")
			This_Scopes_Open_Template_Operators++;
		if (Input[j].Value == ">")
			This_Scopes_Open_Template_Operators--;
		//																																			
		else if (Input[j].Value != ">" && Input[j].Value != "<" && !Input[j].is(Flags::TEXT_COMPONENT) && !Input[j].is(Flags::KEYWORD_COMPONENT) )
			break;
	}

	//this is not a template holding operator.
	if (This_Scopes_Open_Template_Operators > 0)
		return;
	if (Input[j].Value != ">")
		return;

	Input[i].Flags = Flags::TEMPLATE_COMPONENT;
	Input[i].Value = "<>";
	for (int k = i + 1; k < j; k++) {
		Input[i].Components.push_back(Input[k]);
	}

	Input.erase(Input.begin() + i + 1, Input.begin() + j + 1);

	Parser p(Scope);
	p.Input = { Input[i].Components };
	p.Factory();

	Input[i].Components = p.Input;

	//for difinition pattern.
	i--;
}

void Parser::Construct_Virtual_Class_To_Represent_Multiple_Template_Inputs(Component& i)
{
	if (!i.is(Flags::TEMPLATE_COMPONENT))
		return;

	//<int ptr, char>
	vector<vector<string>> Template_Pairs;
	vector<pair<string, bool>> Output;

	//first sort template pair type by comma.
	vector<string> Current_Template_Pair;
	for (auto T : i.Components) {
		if (T.Value == ",") {
			Template_Pairs.push_back(Current_Template_Pair);
			Current_Template_Pair.clear();
		}
		else {
			if (T.is(Flags::TEMPLATE_COMPONENT)) {
				//<int ptr, List<T ptr>>
				Construct_Virtual_Class_To_Represent_Multiple_Template_Inputs(T);
			}
			Current_Template_Pair.push_back(T.Value);
		}
	}
	if (Current_Template_Pair.size() > 0) {
		Template_Pairs.push_back(Current_Template_Pair);
		Current_Template_Pair.clear();
	}

	//Now create a class for every template pair.
	for (auto& Template_Pair : Template_Pairs) {
		//ofcourse avoid same class redefinition.
		if (Template_Pair.size() == 1) {
			Output.push_back({ Template_Pair[0], false });
			continue;
		}
		string Template_Pair_Class_Name = "____";
		for (auto T : Template_Pair) {
			Template_Pair_Class_Name += T + "_";
		}
		if (Scope->Find(Template_Pair_Class_Name, Scope, CLASS_NODE) != nullptr) {
			Output.push_back({ Template_Pair_Class_Name, true });
		}
		else {
			Node* New_Template_Pair_Class = new Node(CLASS_NODE, (new Position(i.Location)));
			New_Template_Pair_Class->Inheritted = Template_Pair;
			New_Template_Pair_Class->Name = Template_Pair_Class_Name;
			New_Template_Pair_Class->Scope = Global_Scope;
			Global_Scope->Defined.push_back(New_Template_Pair_Class);
			Output.push_back({ Template_Pair_Class_Name, true });
		}
	}

	i.Components.clear();
	for (auto j : Output) {
		Component C = Component(j.first, i.Location, Flags::TEXT_COMPONENT);
		i.Components.push_back(C);
	}

	Parser p(Global_Scope);
	p.Input = i.Components;
	p.Factory();
	i.Components = p.Input;

}

void Parser::Operator_Combinator(int i)
{
	if (Input[i].Value != ">")
		return;

	string All_Combined_Operators = ">";
	for (int j = i + 1; j < Input.size() && Input[j].Value == ">"; j++)
		All_Combined_Operators += ">";

	if (All_Combined_Operators.size() == 1)
		return;

	Input.erase(Input.begin() + i + 1, Input.begin() + i + All_Combined_Operators.size() - 1);

	Input[i].Value = All_Combined_Operators;

}

void Parser::Nodize_Template_Pattern(int i)
{
	if (!Input[i].is(Flags::TEMPLATE_COMPONENT))
		return;
	if (Input[i].node != nullptr)
		return;

	Input[i].node = new Node(TEMPLATE_NODE, "<>", &Input[i].Location);

	//List<List<int>, List<int>>
	for (auto& T : Input[i].Components) {
		//check that the value is defined not as a template but as a class.
		//Or. If the current scope is a namespace (for template class definitions)

		if (Scope->Find(T.Value)) {
			Parser p(Scope);
			p.Input = { T };
			p.Factory();
			Input[i].node->Templates.push_back(p.Input.back().node);
		}
		else if (Scope->Find_Template(T.Value) || (Scope->is("static") != -1 && Scope->is(CLASS_NODE))) {
			return;
		}
		else {
			Report(Observation(ERROR, "Uknown template type '" + T.Value + "'", T.Location));
		}

	}

}

void Parser::Template_Type_Constructor(int i)
{
	if (Input[i].node == nullptr)
		return;
	if (Input[i].node->Templates.size() == 0)
		return;
	if (!Scope->Find(Input[i].Value, Scope, CLASS_NODE))
		return;

	string New_Name = Input[i].node->Construct_Template_Type_Name();
	if (Scope->Find(New_Name) != nullptr) {
		Input[i].Value = New_Name;

		Node* Constructed_Template_Class = Scope->Find(New_Name, Scope, CLASS_NODE);

		if (Constructed_Template_Class)
			Input[i].node->Inheritable_templates = Constructed_Template_Class->Inheritable_templates;
		return;
	}
	//Search the original template class
	Node* Og_Type = Input[i].node->Find(Input[i].node, Scope, CLASS_NODE);
	//copy this template class to be non template
	Node* Type = Scope->Copy_Node(Og_Type, Og_Type->Scope);
	Type->Parsed_By = 0;	//reset the parsed flags

	//copy all functions becuase the copy_node by default skips function copying
	for (auto &j : Type->Defined) {
		if (j->is(FUNCTION_NODE))
			j = Scope->Copy_Node(new Node(*j), Type);
	}

	//give the templates back to this new template class for template type refilling
	Type->Templates = Input[i].node->Templates;

	//turns List<T> into List<int>
	for (int T = 0; T < Input[i].node->Templates.size(); T++) {
		string T_Arg = Og_Type->Templates[T]->Name;
		string T_Type = Type->Templates[T]->Name;

		for (auto& Defined : Type->Template_Children) {
			for (auto n : Defined.Get_all())
				if (n->Value == T_Arg)
					n->Value = T_Type;
		}
		/*for (auto& Inheritted : Type->Un_Initialized_Template_Inheritance) {
			for (auto n : Inheritted.first.Get_all())
				if (n->Value == T_Arg)
					n->Value = T_Type;
		}*/
	}

	vector<Component> New_Constructed_Template_Class_Code;

	vector<Component> New_Constructed_Template_Code;

	//re-Construct the class
	/*for (auto j : Type->Un_Initialized_Template_Inheritance)
		New_Constructed_Template_Code.push_back(j.first);*/

	for (auto j : Type->Inheritted)
		New_Constructed_Template_Class_Code.push_back(Component(j, *Type->Location, Lexer::GetComponent(j).Flags));
	
	New_Constructed_Template_Class_Code.push_back(Component(New_Name, *Type->Location, Flags::TEXT_COMPONENT));
	Component Content = Component("{", *Type->Location, Flags::PAREHTHESIS_COMPONENT);
	Content.Components = Type->Template_Children;
	New_Constructed_Template_Class_Code.push_back(Content);
	New_Constructed_Template_Class_Code.push_back(Lexer::GetComponent("\n"));

	//now Construct all member funcitons as well.
	for (auto& Func : Type->Defined) {
		for (int T = 0; T < Func->Templates.size(); T++) {
			string T_Arg = Func->Templates[T]->Name;
			string T_Type = Type->Templates[T]->Name;

			if (Func->Templates[T]->Name == T_Arg)
				Func->Templates[T]->Name = T_Type;
		}
		if (Func->Fetcher == nullptr)
			continue;	//inside type defined functions dont need to be rewritten again.
		//if (Func->Templates.size() == 0)
			Func->Fetcher = Type;

		vector<Component> tmp = Template_Function_Constructor(Func, Og_Type->Templates, Type->Templates);
		New_Constructed_Template_Code.insert(New_Constructed_Template_Code.end(), tmp.begin(), tmp.end());
	}

	Type->Name = New_Name;
	Type->Defined.clear();
	Type->Childs.clear();

	//the constructed template class members are pushed to the old namespace altough the namespace has vbeen inlined

	Node* Closest_Namespace = Scope->Get_Scope_As(CLASS_NODE, {"static"}, Scope);

	Parser p(Closest_Namespace);
	p.Input = New_Constructed_Template_Class_Code;
	p.Factory();

	Type->Scope->Find(Type->Name)->Inheritable_templates = Input[i].node->Templates;
	Input[i].node->Inheritable_templates = Input[i].node->Templates;
	Input[i].node->Templates.clear();

	p = Parser(Closest_Namespace);
	p.Input = New_Constructed_Template_Code;
	p.Factory();
	

	//for erasing the <>
	//Input.erase(Input.begin() + i + 1);

	Input[i].Value = Type->Name;
}

vector<Component> Parser::Template_Function_Constructor(Node* Func, vector<Node*> T_Args, vector<Node*> T_Types)
{
	vector<Component> New_Constructed_Template_Code;
	string New_Name = Func->Construct_Template_Type_Name();

	if (Scope->Find(New_Name) != nullptr) {
		if (Func->Compare_Fetchers(Scope->Find(New_Name))) {
			Func->Name = New_Name;
			return New_Constructed_Template_Code;
		}
	}
	if (!Func->is(FUNCTION_NODE))
		return New_Constructed_Template_Code;

	vector<Component> Return_Type;
	for (auto& Inheritted : Func->Inheritted) {
		for (int T = 0; T < T_Args.size(); T++) {
			string T_Arg = T_Args[T]->Name;
			string T_Type = T_Types[T]->Name;

			if (Inheritted == T_Arg) {
				Inheritted = T_Type;
				Func->Is_Template_Object = true;
			}
		}
		Return_Type.push_back(Lexer::GetComponent(Inheritted));
	}

	for (auto& Inheritted : Func->Un_Initialized_Template_Inheritance) {
		for (int T = 0; T < T_Args.size(); T++) {
			string T_Arg = T_Args[T]->Name;
			string T_Type = T_Types[T]->Name;
			for (auto& j : Inheritted.first.Get_all())
				if (j->Value == T_Arg) {
					j->Value = T_Type;
					Func->Is_Template_Object = true;
				}
		}
		Return_Type.insert(Return_Type.begin() + Inheritted.second, Inheritted.first);
		Return_Type.insert(Return_Type.begin() + Inheritted.second + 1, Inheritted.first.Components[0]);
	}

	vector<Component> Fetchers;
	if (Func->Fetcher) {
		//How TF can there be more than one fetcher Gabe?
		//for (auto* Fetcher : Func->Get_All_Fetchers()) {
		Node* Fetcher = Func->Fetcher;

		Node* New_Fetcher = Fetcher->Copy_Node(Fetcher, Fetcher->Scope);

		for (int T = 0; T < T_Args.size(); T++) {
			string T_Arg = T_Args[T]->Name;
			string T_Type = T_Types[T]->Name;

			for (auto& t : New_Fetcher->Templates)
				if (t->Name == T_Arg)
					t->Name = T_Type;

		}
		Component Fetcher_Component = Lexer::GetComponent(New_Fetcher->Construct_Template_Type_Name());
		Fetchers.push_back(Fetcher_Component);
		Fetchers.push_back(Lexer::GetComponent("."));
	}

	for (int T = 0; T < T_Args.size(); T++)
		for (auto& Defined : Func->Template_Children)
			for (auto n : Defined.Get_all())
				if (n->Value == T_Args[T]->Name) {
					n->Value = T_Types[T]->Name;
				}

	Component Name = Lexer::GetComponent(New_Name);
	Name.Value = New_Name;

	New_Constructed_Template_Code.insert(New_Constructed_Template_Code.end(), Return_Type.begin(), Return_Type.end());
	New_Constructed_Template_Code.insert(New_Constructed_Template_Code.end(), Fetchers.begin(), Fetchers.end());
	New_Constructed_Template_Code.insert(New_Constructed_Template_Code.end(), Name);
	New_Constructed_Template_Code.insert(New_Constructed_Template_Code.end(), Func->Template_Children.begin(), Func->Template_Children.end());
	New_Constructed_Template_Code.push_back(Lexer::GetComponent("\n"));

	return New_Constructed_Template_Code;
}

void Parser::Inject_Template_Into_Member_Function_Fetcher(int& i)
{
	// i-1 should have the class fetcher that feches the member.
	if (i - 1 < 0)
		return;
	if (!Input[i - 1].is(Flags::TEXT_COMPONENT))
		return;
	if (Input[i - 1].node == nullptr)
		return;
	if (Scope->Find(Input[i - 1].Value, Scope, CLASS_NODE) == nullptr)
		return;

	// i should have the template <>
	if (!Input[i].is(Flags::TEMPLATE_COMPONENT))
		return;

	for (auto T : Input[i].Components) {
		Node* Template = new Node(TEMPLATE_NODE, T.Value, &T.Location);

		Template->Inheritted.push_back("type");

		Input[i - 1].node->Templates.push_back(Template);
	}

	Input.erase(Input.begin() + i--);
}

void Parser::Combine_Comment(int i)
{
	if (!Input[i].is(Flags::COMMENT_COMPONENT))
		return;
	if (i + 1 >= Input.size() || !Input[i+1].is(Flags::COMMENT_COMPONENT))
		return;

	Input[i].Value += "\n" + Input[i + 1].Value;

	Input.erase(Input.begin() + i + 1);

	Combine_Comment(i);
}

void Parser::Remove_All_Excess_Comments(int i)
{
	if (!Input[i].is(Flags::COMMENT_COMPONENT))
		return;

	Input.erase(Input.begin() + i--);

	if (i >= 0)
		Remove_All_Excess_Comments(i);
}

void Parser::Definition_Pattern(int i)
{
	//foo ptr a = ...|bool is(int f) | bool is(string f)
	//<summary>
	//list all previusly defined and find the last as an text to define a new object
	//put that result object into parents defined list and also into-
	//the INPUT[i + object index] the newly created object
	//</summary>
	vector<int> Words = Get_Amount_Of(i, { Flags::KEYWORD_COMPONENT, Flags::TEXT_COMPONENT, Flags::TEMPLATE_COMPONENT });
	//object definition needs atleast one type and one raw text
	if (Words.size() > 0 && Input[Words.back()].is(Flags::TEMPLATE_COMPONENT))
		Words.pop_back();
	if (Words.size() < 2)
		return;
	//the last word must be a raw text not a keyword to be defined as a new object
	if (Input[Words.back()].is(Flags::KEYWORD_COMPONENT))
		return;
	//this is because of the syntax of label jumping exmp: "jump somewhere" is same as a variable declaration exmp: "int somename".
	for (auto j : Words)
		//import keywords have theyre own function to parse theyre own patterns.
		if (Input[j].Value == "jump" || Input[j].Value == "return" || Input[j].Value == "use")
			return;

	//int ptr a
	Node* New_Defined_Object = new Node(OBJECT_DEFINTION_NODE, new Position(Input[Words[0]].Location));

	if (i - 1 >= 0 && Input[i - 1].is(Flags::COMMENT_COMPONENT)) {
		New_Defined_Object->Comment = Input[i - 1].Value;

		replace(New_Defined_Object->Comment.begin(), New_Defined_Object->Comment.end(), '#', ' ');
	}

	New_Defined_Object->Name = Input[Words.back()].Value;
	New_Defined_Object->Scope = Scope;

	//transform the indecies into strings, and the -1 means that we want to skip the last element in the list (the name)
	for (int j = 0; j < Words.size() - 1; j++) {
		//the define is something like tihs:
		//T a
		//then there would be no problem because the T would have been found by the Find function
		//The issue here is if there is template construction like:
		//List<T> a
		//that will construct a new List class that type is T, and that is wrong.
		if (Input[Words[j]].is(Flags::TEMPLATE_COMPONENT)) {
			//insure that this isn't a template parameter
			//<int, T, R>

			//check that all the templates are defined as a classes
			bool All_Templates_Are_Defined_As_Classes = true;
			for (auto T : Input[Words[j]].Components)
				if (Scope->Find(T.Value) == nullptr)
					All_Templates_Are_Defined_As_Classes = false;

			//insire that all of the templates are from scopes templates and not classes
			for (auto T : Input[Words[j]].Components)
				if (Scope->Find_Template(T.Value))
					//this means that the template type is not a class
					All_Templates_Are_Defined_As_Classes = false;
			
			if (All_Templates_Are_Defined_As_Classes == false) {
				//normal 'T a' will not trigger this code because the T is not wrapped into a <>
				Input[Words[j - 1]].Components.push_back(Input[Words[j]]);
				
				New_Defined_Object->Un_Initialized_Template_Inheritance.push_back({ Input[Words[j - 1]] , j - 1 });
			}
			else {
				//List<List<int>> a
				//-> .List_List_int a 
				Parser p(Scope);
				p.Input = { Input[Words[j - 1]],  Input[Words[j]] };
				p.Factory();
				
				if ((Scope->is("static") == -1 || !Scope->is(CLASS_NODE)) || All_Templates_Are_Defined_As_Classes) {
					New_Defined_Object->Inheritted.push_back(p.Input.back().Value);
					New_Defined_Object->Inheritable_templates = p.Input.back().node->Inheritable_templates;
				}
				else {
					//This is for if the function return a templated return type like:
					//List<T> a
					//because the upper scope is not same as the function that this return type belongs to the upper code will not work
					//and thats why this is here.
					New_Defined_Object->Un_Initialized_Template_Inheritance.push_back({ p.Input.back(), j});
				}
			}
		}
		else if (j + 1 < Words.size() && !Input[Words[j + 1]].is(Flags::TEMPLATE_COMPONENT))
			New_Defined_Object->Inheritted.push_back(Input[Words[j]].Value);
	}

	//Almost Namespace combination system 2000 (:
	// The rest is made in the Type_Pattern dude
	//if the current made object already exists
	Node* Namespace = Scope->Find(New_Defined_Object, Scope);
	//if the namespace is already a static class type and this one too then combine
	if (Namespace != nullptr && (Namespace->is(CLASS_NODE) || ((Get_Amount_Of(Words.back() + 1, {Flags::PAREHTHESIS_COMPONENT}, false).size() == 1) && (Input[Words.back() + 1].Value[0] == '{'))) && Namespace->is("static") != -1)
		New_Defined_Object = Namespace;
	//if the namespace is already a static class but this is not a static class or both are non static.
	else if (Namespace != nullptr && Namespace->is(CLASS_NODE) && Namespace->is("static") == -1) {
		bool Skip_Templates = false;
		if (Words.back() + 1 < Input.size() && Input[Words.back() + 1].is(Flags::TEMPLATE_COMPONENT))
			Skip_Templates = true;

		vector<int> Parenthesises = Get_Amount_Of(Words.back() + 1 + Skip_Templates, { Flags::PAREHTHESIS_COMPONENT }, false);
		if ((Parenthesises.size() == 1) && (Input[Parenthesises[0]].Value[0] == '{'))
			Report(Observation(ERROR, "Cannot combine non static classes as namespaces!", *New_Defined_Object->Location));
		else
			Scope->Defined.push_back(New_Defined_Object);
	}
	else if (Namespace != nullptr && !Namespace->Has({ IMPORT, EXPORT, FUNCTION_NODE }) && !Input[Words.back() + 1].is(CONTENT_NODE)) {
		if (!Input[Words.back() + 1].is(CONTENT_NODE))
			Report(Observation(ERROR, "'" + New_Defined_Object->Name + "' is already defined at '" + Namespace->Location->ToString() + "'", *New_Defined_Object->Location));
	}
	else
		Scope->Defined.push_back(New_Defined_Object);

	//for later AST use:int ptr a = 123
	Input[Words.back()].node = New_Defined_Object;

	Input.erase(Input.begin() + i, Input.begin() + Words.back());
}

void Parser::Constructor_Pattern(int i)
{
	vector<Component> ReturnType = Get_Inheritting_Components(i);
	if (!(ReturnType.size() > 1))
		return;
	if (ReturnType[ReturnType.size() - 1].is(Flags::KEYWORD_COMPONENT))
		return;	//the last list index is the name and thus cannot be a keyword

	if (!Scope->Find(ReturnType[ReturnType.size() - 1].Value, Scope)->is(CLASS_NODE))
		return;	//the name must be same as some class name to represent as the constructor of that class

	for (auto j : ReturnType) {
		if (j.Value == "return" || j.Value == "jump" || j.Value == "use")
			return;
	}


	Node* Constructor = new Node(OBJECT_DEFINTION_NODE, new Position(ReturnType.back().Location));
	Constructor->Name = ReturnType.back().Value;
	for (int j = 0; j < ReturnType.size() - 1; j++)
		Constructor->Inheritted.push_back(ReturnType[j].Value);

	Input[i + Constructor->Inheritted.size() - 1 + 1].node = Constructor;

	Input.erase(Input.begin() + i, Input.begin() + i + Constructor->Inheritted.size());
	return;
}

void Parser::Prototype_Pattern(int i)
{
	if (!(Scope->is(CLASS_NODE) && ((Scope->is("static") != -1) || Scope->Name == "GLOBAL_SCOPE")))
		return;
	//func banana(int, short)\n
	vector<int> Words = Get_Amount_Of(i, { Flags::TEXT_COMPONENT, Flags::KEYWORD_COMPONENT, Flags::TEMPLATE_COMPONENT });
	//Words list must be a at leat two size for the type and for the name to be inside it
	if (Words.size() < 2)
		return;

	vector<int> Paranthesis = Get_Amount_Of(Words.back() + 1, Flags::PAREHTHESIS_COMPONENT);
	if (Paranthesis.size() != 1)
		return;
	if (Input[Paranthesis[0]].Value[0] != '(')
		return;

	//this is here because the jump can have a function call
	//label get_jump(int x)
	//jump get_jump(123);
	for (auto c : Words)
		if (Input[c].Value == "jump" || Input[c].Value == "return" || Input[c].Value == "import" || Input[c].Value == "use")
			return;

	Node* New_Defined_Object = new Node(PROTOTYPE, new Position(Input[Words.back()].Location));

	if (Input[Words.back()].is(Flags::TEMPLATE_COMPONENT)) {
		if (Input[Words.back()].is(Flags::TEMPLATE_COMPONENT)) {
			for (auto T : Input[Words.back()].Components) {
				Node* Template = new Node(TEMPLATE_NODE, T.Value, &T.Location);

				Template->Inheritted.push_back("type");

				New_Defined_Object->Templates.push_back(Template);
			}
		}
		Words.pop_back();
		New_Defined_Object->Is_Template_Object = true;
	}
	//type a
	vector<string> Inheritted;

	//skip the last that is the name index.
	for (int j = 0; j < Words.size() - 1; j++) {
		Inheritted.push_back(Input[Words[j]].Value);
	}

	New_Defined_Object->Inheritted = Inheritted;
	New_Defined_Object->Name = Input[Words.back()].Value;
	New_Defined_Object->Scope = Scope;

	vector<Component> Types;
	for (auto j : Input[Paranthesis[0]].Components) {
		if (j.Value == ",") {
			Node* p = new Node(OBJECT_DEFINTION_NODE, &j.Location);

			if (Types.back().is(Flags::KEYWORD_COMPONENT)) {
				p->Name = "ARG" + to_string(arg_count++);
				p->Is_Template_Object = true;
			}
			else {
				p->Name = Types.back().Value;
				Types.pop_back();
			}
			p->Scope = New_Defined_Object;
			for (auto k : Types)
				p->Inheritted.push_back(k.Value);

			if (p->is("type") != -1)
				p->Is_Template_Object = true;

			New_Defined_Object->Parameters.push_back(p);
			Types.clear();
		}
		else {
			Types.push_back(j);
		}
	}
	if (Types.size() > 0) {
		//for the last parameter
		Node* p = new Node(OBJECT_DEFINTION_NODE, &Types.back().Location);

		if (Types.back().is(Flags::KEYWORD_COMPONENT)) {
			p->Name = "ARG" + to_string(arg_count++);
			p->Is_Template_Object = true;
		}
		else {
			p->Name = Types.back().Value;
			Types.pop_back();
		}
		p->Scope = New_Defined_Object;
		for (auto k : Types)
			p->Inheritted.push_back(k.Value);

		if (p->is("type") != -1)
			p->Is_Template_Object = true;

		New_Defined_Object->Parameters.push_back(p);
	}

	//erase inherittes as well the name as well the pearameters from the input list
	Input.erase(Input.begin() + Words[0], Input.begin() + Paranthesis[0] + 1);

	Scope->Defined.push_back(New_Defined_Object);

	if (i < Input.size())
		Prototype_Pattern(i);

	return;
}

void Parser::Combine_Import_Shattered_Return_Info(int i)
{
	//import func 4 integer banana(4 integer)
	//import func 8 decimal banana(4 integer)
	if (i + 1 >= Input.size())
		return;
	if (!Input[i].is(Flags::NUMBER_COMPONENT) || !Input[i + 1].is(Flags::TEXT_COMPONENT))
		return;

	Node* Numerical_Type = new Node(NUMBER_NODE, &Input[i].Location);
	Numerical_Type->Name = Input[i].Value;
	Numerical_Type->Format = Input[i + 1].Value;

	Input[i].Flags = Flags::NUMERICAL_TYPE_COMPONENT;
	Input[i].node = Numerical_Type;
	Input.erase(Input.begin() + i + 1);
}

void Parser::Import_Pattern(int i)
{
	//func banana(int, short)\n
	vector<int> Words = Get_Amount_Of(i, { Flags::TEXT_COMPONENT, Flags::KEYWORD_COMPONENT, Flags::TEMPLATE_COMPONENT, Flags::NUMERICAL_TYPE_COMPONENT });
	//Words list must be a at leat two size for the type and for the name to be inside it
	if (Words.size() < 2)
		return;
	vector<int> Paranthesis = Get_Amount_Of(Words.back() + 1, Flags::PAREHTHESIS_COMPONENT);
	if (Paranthesis.size() != 1)
		return;
	if (Input[Paranthesis[0]].Value[0] != '(')
		return;

	bool Has_Import_Keyword = false;
	for (auto c : Words)
		if (Input[c].Value == "import")
			Has_Import_Keyword = true;

	if (!Has_Import_Keyword)
		return;

	Node* New_Defined_Object = new Node(IMPORT, new Position(Input[Words.back()].Location));


	if (Input[Words.back()].is(Flags::TEMPLATE_COMPONENT)) {
		for (auto T : Input[Words.back()].Components) {
			Node* Template = new Node(TEMPLATE_NODE, T.Value, &T.Location);

			Template->Inheritted.push_back("type");

			New_Defined_Object->Templates.push_back(Template);
		}
		Words.pop_back();
		New_Defined_Object->Is_Template_Object = true;
	}

	//type a
	vector<string> Inheritted;

	//skip the last that is the name index.
	for (int j = 0; j < Words.size() - 1; j++) {
		if (Input[Words[j]].is(Flags::NUMERICAL_TYPE_COMPONENT)) {
			New_Defined_Object->Numerical_Return_Types.push_back(Input[Words[j]].node);
		}
		else
			Inheritted.push_back(Input[Words[j]].Value);
	}

	New_Defined_Object->Inheritted = Inheritted;
	New_Defined_Object->Name = Input[Words.back()].Value;
	New_Defined_Object->Scope = Scope;

	vector<Component> Types;
	for (auto j : Input[Paranthesis[0]].Components) {
		if (j.Value == ",") {
			string Format = "";
			for (int j = 0; j < Types.size(); j++) {
				if (Types[j].Value == "decimal" || Types[j].Value == "integer") {
					Format = Types[j].Value;
					Types.erase(Types.begin() + j);
				}
			}
			Node* p;
			if (Types.back().is(Flags::NUMBER_COMPONENT))
				p = new Node(NUMBER_NODE, &j.Location, Format);
			else
				p = new Node(OBJECT_DEFINTION_NODE, &j.Location, Format);

			if (Types.back().is(Flags::KEYWORD_COMPONENT)) {
				p->Name = "ARG" + to_string(arg_count++);
				p->Is_Template_Object = true;
			}
			else {
				p->Name = Types.back().Value;
				Types.pop_back();
			}
			p->Scope = New_Defined_Object;
			for (auto k : Types)
				p->Inheritted.push_back(k.Value);

			if (p->is("type") != -1)
				p->Is_Template_Object = true;

			New_Defined_Object->Parameters.push_back(p);
			Types.clear();
		}
		else {
			Types.push_back(j);
		}
	}
	if (Types.size() > 0) {
		//for the last parameter
		string Format = "";
		for (int j = 0; j < Types.size(); j++) {
			if (Types[j].Value == "decimal" || Types[j].Value == "integer") {
				Format = Types[j].Value;
				Types.erase(Types.begin() + j);
			}
		}
		Node* p = nullptr;
		if (Types.back().is(Flags::NUMBER_COMPONENT))
			p = new Node(NUMBER_NODE, &Types.back().Location, Format);
		else
			p = new Node(OBJECT_DEFINTION_NODE, &Types.back().Location);

		if (Types.back().is(Flags::KEYWORD_COMPONENT)) {
			p->Name = "ARG" + to_string(arg_count++);
			p->Is_Template_Object = true;
		}
		else {
			p->Name = Types.back().Value;
			Types.pop_back();
		}
		p->Scope = New_Defined_Object;
		for (auto k : Types)
			p->Inheritted.push_back(k.Value);

		if (p->is("type") != -1)
			p->Is_Template_Object = true;

		New_Defined_Object->Parameters.push_back(p);
	}

	//erase inherittes as well the name as well the pearameters from the input list
	Input.erase(Input.begin() + Words[0], Input.begin() + Paranthesis[0] + 1);

	Scope->Defined.push_back(New_Defined_Object);

	if (i < Input.size())
		Import_Pattern(i);

	return;
}

void Parser::Object_Pattern(int i)
{
	//<summary>
	//Find defined text components and implant-
	//the node repective of that component into the input[i]
	//</summary>
	if (!Input[i].is(Flags::TEXT_COMPONENT))
		return;
	if (Scope->Find(Input[i].Value, Scope, (bool)true) == nullptr)
		return;
	if (Input[i].node != nullptr)
		return;	//we dont want to rewrite the content

	Input[i].node = Scope->Copy_Node(new Node(*Scope->Find(Input[i].Value, Scope, true)), Scope);
	Input[i].node->Location = new Position(Input[i].Location);

	//List<int> a -> .List_int a
	if (Input[i].node->Templates.size() > 0) {
		//this means that the next element is a template
		if (i+1 >= Input.size() || !Input[i + 1].is(Flags::TEMPLATE_COMPONENT))
			Report(Observation(ERROR, "Inheritted type " + Input[i].Value + " needs a template argument!", Input[i].Location));

		Input[i].node->Templates = Input[i + 1].node->Templates;

		Input.erase(Input.begin() + i + 1);
	}
	else if (i + 1 < Input.size() && Input[i + 1].is(Flags::TEMPLATE_COMPONENT)) {
		//check if the current scope is a namespace or global scope
		if (Scope->is("static") == -1 || !Scope->is(CLASS_NODE)) {
			for (auto T : Input[i + 1].Components)
				Input[i].node->Templates.push_back(T.node);

			if (Scope->Find(Input[i].node, Scope) == nullptr) {
				Report(Observation(ERROR, "This object does not take template arguments '" + Input[i].Value + "'", Input[i].Location));
			}

			Input[i].node = Scope->Find(Input[i].node, Scope);
			Input[i].node->Templates = Input[i + 1].node->Templates;
			Input.erase(Input.begin() + i + 1);
		}
		else {
			//List<T> a -> List<T> a
			//this will conserve the template as source code for the template manifestation
			//Input[i] = Component("Un_initialized", Flags::UN_INITIALIZED_TEMPLATES, { Input[i], Input[i + 1] });
			Input[i].Components.push_back(Input[i + 1]);
			Input.erase(Input.begin() + i + 1);
			return;
		}
	}

	if (Input[i].node->is(OBJECT_DEFINTION_NODE))
		Input[i].node->Type = OBJECT_NODE;
	else if (Input[i].node->is(PARAMETER_NODE))
		Input[i].node->Type = PARAMETER_NODE;
	else if (Input[i].node->is(LABEL_NODE))
		Input[i].node->Type = LABEL_NODE;
	else if (Input[i].node->is(FUNCTION_NODE)) //this happends for function pointer adress geting prosess
		Input[i].node->Type = OBJECT_NODE;

	Input[i].node->Scope = Scope;
	return;
}

void Parser::Complex_Cast(int i)
{
	//this needs to be called before any paranthesis parser
	//x->(T ptr ptr)
	//this function creates a new virtual class that repesents the cast types
	if (i - 1 < 0)
		return;
	if (!Input[i].is(Flags::PAREHTHESIS_COMPONENT))
		return;
	if (Input[i - 1].Value != "->")
		return;

	Input[i] = *Construct_Virtual_Class_For_Complex_Cast(Input[i]);
}

void Parser::Parenthesis_Pattern(int i)
{
	// a = (a + b) * c
	//<summary>
	//go the content of the paranthesis and resurn an object
	//put that result object into the INPUT[i + object index] the newly created paranthesis
	//</summary>
	if (!Input[i].is(Flags::PAREHTHESIS_COMPONENT))
		return;

	//if (Input[i].Value[0] == '{')
	//	if (Scope->is(CLASS_NODE) && Scope->is("static") != -1)
	//		return;		//this is for member functions

	//create an content Node and output will be in the same input.
	Node* Paranthesis = new Node(CONTENT_NODE, new Position(Input[i].Location));
	Paranthesis->Scope = Scope;
	
	Parser TMP_Parser(Scope);
	TMP_Parser.Input = Input[i].Components;
	TMP_Parser.Factory();

	for (Component j : TMP_Parser.Input)
		if (j.node != nullptr) {
			//j.node->Context = Paranthesis;
			//j.node->Parent = Paranthesis;
			Paranthesis->Childs.push_back(j.node->Copy_Node(j.node, Scope));
		}

	Paranthesis->Paranthesis_Type = Input[i].Value[0];
	Input[i].Components = TMP_Parser.Input;
	Input[i].node = Paranthesis;

	return;
}

void Parser::Math_Pattern(int& i, vector<string> Operators, int F, bool Change_Index)
{
	//<summary>
	//This function paternises the math order.
	//Before this function the variables/functioncalls/parenthesis/ need to be-
	//already made into Nodes and saved into the Components node member.
	//</summary>
	//a = b + c * d
	if (!Input[i].is(Flags::OPERATOR_COMPONENT))
		return;
	if (i - 1 < 0)
		return;
	if (((size_t)i + 1) > Input.size())
		return;
	if (Input[i].node != nullptr)
		return;
	bool op_Pass = false;
	for (string s : Operators)
		if (Input[i].Value == s)
			op_Pass = true;
	if (!op_Pass)
		return;

	Node* Operator = new Node(F, new Position(Input[i].Location));
	Operator->Name = Input[i].Value;
	Operator->Scope = Scope;

	if (Input[(size_t)i - 1].node != nullptr)
		Operator->Left = Input[(size_t)i - 1].node;
	else {
		//Dont worry about function calls
		Node* new_member = new Node(OBJECT_DEFINTION_NODE, new Position(Input[(size_t)i + 1].Location));
		new_member->Name = Input[(size_t)i - 1].Value;
		new_member->Scope = Operator->Scope;



		Operator->Left = new_member;
	}

	if (Input[(size_t)i + 1].node != nullptr)
		Operator->Right = Input[(size_t)i + 1].node;
	else {
		//test.a.m //these a.m are in different localscope.
		//the right side does not need to be determined as well the left.
		//Dont worry about function calls
		Node* new_member = new Node(OBJECT_DEFINTION_NODE, new Position(Input[(size_t)i + 1].Location));
		new_member->Name = Input[(size_t)i + 1].Value;
		new_member->Scope = Operator->Scope;

		Operator->Right = new_member;
	}

	//this is for algebra only!!
	if (Input[i].Value == "-")
		Operator->Right->Coefficient *= -1;

	if (Operator->Name == "=")
		if (Scope->Name == "GLOBAL_SCOPE")
			Scope->Find(Operator->Left->Name)->Inheritted.push_back("const");

	//give the left and right operators the right holder information
	Operator->Left->Context = Operator;
	Operator->Right->Context = Operator;

	Input[i].node = Operator;
	Input.erase(Input.begin() + i + 1);
	if (Change_Index)
		i--;
	Input.erase(Input.begin() + i - !Change_Index);

	if ((size_t)i + 1 + Change_Index > Input.size() - 1)
		return;
	if (Input[i + Change_Index].is(Flags::OPERATOR_COMPONENT))
		Math_Pattern(i += Change_Index, Operators, F, Change_Index);
	return;
}

void Parser::Number_Pattern(int i)
{
	//<summary>
	//Make component numbers into real number_node.
	//</summary>
	if (!Input[i].is(Flags::NUMBER_COMPONENT))
		return;
	Node* Num = new Node(NUMBER_NODE, new Position(Input[i].Location));
	Num->Name = Input[i].Value;
	Num->Scope = Scope;

	for (int j = 0; j < Num->Name.size(); j++)
		if (Num->Name[j] == '.') {
			Num->Format = "decimal";
			break;
		}

	if (atoll(Num->Name.c_str()) > INT32_MAX)
		Num->Size = 8;
	else
		Num->Size = 4;

	Input[i].node = Num;
	return;
}

void Parser::String_Pattern(int i)
{
	//<summary>
	//Make component string into real string_node.
	//</summary>
	if (!Input[i].is(Flags::STRING_COMPONENT))
		return;
	Node* String = new Node(STRING_NODE, new Position(Input[i].Location));
	String->Name = Input[i].Value;
	Input[i].node = String;
	return;
}

void Parser::Operator_PreFix_Pattern(int i, vector<string> Prefixes)
{
	//<summary>
	//-123/-a/-b()
	//++a/++b()
	//Adds the Operator_Prefix into the next object
	//</summary>
	if (i + 1 > Input.size() - 1)
		return;
	if (Input[i + 1].is(Flags::END_COMPONENT))
		return;
	if (Input[i].node != nullptr)
		return;
	if (!Input[i].is(Flags::OPERATOR_COMPONENT))
		return;
	//return if the left side of the operator is a computable oject.
	if (Input[(size_t)i - 1].Has({ Flags::TEXT_COMPONENT, Flags::NUMBER_COMPONENT, Flags::PAREHTHESIS_COMPONENT }))		//a -b
		return;

	bool op_Pass = false;
	for (string s : Prefixes)
		if (Input[i].Value == s)
			op_Pass = true;
	if (!op_Pass)
		return;

	Node* PreFix = new Node(PREFIX_NODE, new Position(Input[i].Location));
	PreFix->Scope = Scope;
	//name
	PreFix->Name = Input[i].Value;
	//for more complex casting
	PreFix->Left = Input[i].node;
	PreFix->Right = Input[(size_t)i + 1].node;

	PreFix->Right->Context = PreFix;
	PreFix->Right->Scope = PreFix->Scope;
	
	//Operator_Node PreFix;	//++a/-a/--a
	//Operator_Node PostFix;	//a++/a--
	Input[i].node = PreFix;

	Input.erase(Input.begin() + i + 1);
}

void Parser::Operator_PostFix_Pattern(int i, vector<string> Postfix)
{	
	//<summary>
	//a--/b()--
	//a++/b()++
	//Adds the Operator_Postfix into the previus object
	//</summary>
	if (i -1 < 0)
		return;
	if (Input[i].node != nullptr)
		return;
	if (!Input[i].is(Flags::OPERATOR_COMPONENT))
		return;

	//check if this operator is meant to be a prefix, not postfix.
	if ((size_t)i + 1 < Input.size() - 1) {
		if (Input[(size_t)i + 1].is(Flags::TEXT_COMPONENT))
			return;		//++ abc
		if (Input[(size_t)i + 1].is(Flags::PAREHTHESIS_COMPONENT))
			return;		//++ (..)
	}

	bool op_Pass = false;
	for (string s : Postfix)
		if (Input[i].Value == s)
			op_Pass = true;
	if (!op_Pass)
		return;

	Node* post = new Node(POSTFIX_NODE, new Position(Input[i].Location));
	post->Name = Input[i].Value;
	post->Scope = Scope;
	
	//set the node to postfix as left
	post->Left = Input[(size_t)i - 1].node;
	post->Left->Context = post;
	post->Left->Scope = post->Scope;
	//for casting
	post->Right = Input[i].node;

	Input[i].node = post;

	Input.erase(Input.begin() + i - 1);

	return;
}

void Parser::Variable_Negate_Pattern(int i)
{
	if (Input[i].Value != "-")
		return;
	if (i - 1 >= 0) {
		if (Input[(size_t)i - 1].Has({ Flags::PAREHTHESIS_COMPONENT, Flags::NUMBER_COMPONENT, Flags::TEXT_COMPONENT, Flags::OPERATOR_COMPONENT}))
			return;
	}
	if (((size_t)i + 1) > Input.size())
		return;


	Input[(size_t)i+1].node->Coefficient *= -1;

	//remove the negettor operator
	Input.erase(Input.begin() + i);

	return;
}

void Parser::Callation_Pattern(int i)
{
	//<summary>
	//Notice!!! the Parameter Paranthesis must be before this defined!!!
	//Also the callation as an object should be already be in the node member
	//</summary>
	if (!Input[i].is(Flags::TEXT_COMPONENT))
		return;

	int Paranthesis_Offset = 1;
	if (i + 1 < Input.size() && Input[i + 1].is(Flags::TEMPLATE_COMPONENT))
		Paranthesis_Offset = 2;

	if (Get_Amount_Of(i + Paranthesis_Offset, Flags::PAREHTHESIS_COMPONENT).size() != 1)
		return;
	if (Input[(size_t)i + Paranthesis_Offset].Value[0] != '(')
		return;

	Node* call = new Node(CALL_NODE, new Position(Input[i].Location));
	call->Name = Input[i].Value;

	if (Input[i + 1].is(Flags::TEMPLATE_COMPONENT)) {
		//Nodize the template type 'int' for example.
		Parser p(Scope);
		p.Input = {Input[i + 1]};
		p.Factory();

		//save all the template types into the call node, for postprosessor to handle this.
		for (auto T : p.Input.back().node->Templates)
			call->Templates.push_back(T);

		Input.erase(Input.begin() + i + 1);
	}
	//give the normal call the inheritance for future operator type determining


	call->Scope = Scope;

	if (Scope->is(CALL_NODE))
		call->Context = Scope;

	//initialize the parenthesis that contains the parameters
	Parser p(Scope);
	p.Input = {Input[(size_t)i + 1]};
	p.Factory();

	call->Parameters = p.Input.back().node->Childs;

	for (auto P : call->Parameters) {
		P->Context = call;
	}

	Input[i].node = call;
	Input[i].Value = call->Name;

	Input.erase(Input.begin() + i + 1);
	return;
}

void Parser::Array_Pattern(int i)
{
	//<summary>
	//find paranthesis with signature of '[' and put it into Input[i]
	//Notice!!! The paranthesis must be initialized before this unition of array operation!!!
	//</summary>
	if (!Input[i].is(Flags::TEXT_COMPONENT))
		return;
	if ((size_t)i + 1 > Input.size() - 1)
		return;
	if (!Input[(size_t)i + 1].is(Flags::PAREHTHESIS_COMPONENT))
		return;
	if (Input[(size_t)i + 1].node->Paranthesis_Type != '[')
		return;

	Node* arr = new Node(ARRAY_NODE, new Position(Input[i].Location));
	arr->Scope = Scope;

	if (Input[(size_t)i].node != nullptr)
		arr->Left = Input[(size_t)i].node;
	else {
		//Dont worry about function calls
		Node* new_member = new Node(OBJECT_DEFINTION_NODE, new Position(Input[i].Location));
		new_member->Name = Input[(size_t)i].Value;

		arr->Left = new_member;
		arr->Left->Scope = Scope;
	}

	if (Input[(size_t)i + 1].node->Childs.size() > 1) {
		arr->Right = new Node(CONTENT_NODE, new Position(Input[(size_t)i+1].Location));
		arr->Right->Childs = Input[(size_t)i + 1].node->Childs;
	}
	else if (Input[(size_t)i + 1].node->Childs[0] != nullptr)
		arr->Right = Input[(size_t)i + 1].node->Childs[0];
	else {
		//test.a.m //these a.m are in different localscope.
		//the right side does not need to be determined as well the left.
		//Dont worry about function calls
		Node* new_member = new Node(OBJECT_DEFINTION_NODE, new Position(Input[(size_t)i+1].Location));
		new_member->Name = Input[(size_t)i + 1].Components[0].Value;

		arr->Right = new_member;
		arr->Right->Scope = Scope;
	}

	//TODO:
	//Needs more testing with more complex array usage like: a[x][y][z]
	arr->Name = "[]";

	Input[i].node = arr;

	Input.erase(Input.begin() + i + 1);
	Array_Pattern(i);
	return;
}

void Parser::Function_Pattern(int i)
{
	//import int func main() [\n] {..}
	//<summary>
	//Notice!!! The parameter parenthesis & Childs parenthesis must be already initialized!!!
	//Notice!!! The construction of function must be done before this!!!
	//Notice!!! The Including must be done before this!!!
	//Notice!!! This must be done before Object_Pattern & after Defintitin_Pattern!!!
	//Build the function as 
	//</summary>
	if (Input[i].node == nullptr)
		return;
	if (Input[i].is(Flags::KEYWORD_COMPONENT))
		return;

	int Paranthesis_Offset = 1;
	if (i + 1 < Input.size() && Input[i + 1].is(Flags::TEMPLATE_COMPONENT))
		Paranthesis_Offset = 2;

	vector<int> Parenthesis_Indexes = Get_Amount_Of(i + Paranthesis_Offset, Flags::PAREHTHESIS_COMPONENT, false);
	if (Parenthesis_Indexes.size() != 2)
		return;
	if (Input[Parenthesis_Indexes[0]].Value[0] != '(')
		return;

	//first try to get the behaviour
	Node* func = nullptr;
	if (Input[i].node->Type == OBJECT_DEFINTION_NODE)
		func = Input[i].node;
	else if (Input[i].node->Name == ".") {
		Member_Function_Pattern(i);
		return;
	}
	else
		func = Scope->Find(Input[i].Value, Scope, true);
	if (func == nullptr) {
		Report(Observation(ERROR, "Parser didnt find " + Input[i].node->Name + " constructor!", Input[i].Location));
	}
	//override the object definition node flag
	func->Type = FUNCTION_NODE;
	//set the other values
	func->Name = Input[i].Value;
	func->Scope = Scope;


	func->Template_Children = { Input[Parenthesis_Indexes[0]], Input[Parenthesis_Indexes[1]] };

	//Template Fucntions.
	for (auto T : func->Inheritted)
		if (func->Find_Template(T)) {
			func->Is_Template_Object = true;
			break;
		}
	//construct nodes from the component templates.
	if (Paranthesis_Offset == 2) {
		for (auto T : Input[i + 1].Components) {
			Node* Template = new Node(TEMPLATE_NODE, T.Value, &T.Location);

			Template->Inheritted.push_back("type");

			func->Templates.push_back(Template);
		}
		func->Is_Template_Object = true;
	}

	//if the functoin is a template typed, then we must be carefull with the parameters that use the template too
	Parser p(func);
	p.Input.push_back(Input[Parenthesis_Indexes[0]]);
	p.Factory();

	for (auto& j : func->Defined) {
		j->Type = PARAMETER_NODE;
	}

	func->Parameters = func->Defined;
	if (!func->Is_Template_Object) {
		p.Input.clear();

		p.Input.push_back(Input[Parenthesis_Indexes[1]]);
		p.Factory();
		func->Childs = p.Input[0].node->Childs;
		p.Input.clear();

		for (auto j : func->Defined) {
			Safe s;
			s.Check_For_Undefined_Inheritance(j);
		}

		func->Mangled_Name = MANGLER::Mangle(func, "");
	}

	Input[i].node = func;

	Input.erase(Input.begin() + Parenthesis_Indexes[1]);
	Input.erase(Input.begin() + Parenthesis_Indexes[0]);

	if (func->Templates.size() > 0) {
		Input.erase(Input.begin() + i + 1);
	}

	return;
}

void Parser::Type_Pattern(int i)
{
	//type int{ size 4}
	//<summary>
	//Notice!!! The Parenthesis that contains the members needs to be initialized before this!!!
	//Does same as the Function_Pattern but just one less parenthesis to worrie about.
	//</summary>
	if (!Input[i].is(Flags::TEXT_COMPONENT))
		return;
	if (Scope->Find(Input[i].Value, Scope, false) == nullptr)
		return;

	int Paranthesis_Offset = 1;
	if (i+1 < Input.size() && Input[i + 1].is(Flags::TEMPLATE_COMPONENT))
		Paranthesis_Offset = 2;

	vector<int> Parenthesis_Indexes = Get_Amount_Of(i + Paranthesis_Offset, Flags::PAREHTHESIS_COMPONENT, false);
	
	if (Parenthesis_Indexes.size() != 1)
		return;
	if (Input[Parenthesis_Indexes[0]].Value[0] != '{')
		return;

	Node* Type = nullptr;
	if (Input[i].node != nullptr)
		//dont worry this has same pointter as the one that is in the Defined list, so this point to it
		Type = Input[i].node;
	else
		Type = Scope->Find(Input[i].Value, Scope, OBJECT_DEFINTION_NODE);
	if (Type == nullptr) {
		Report(Observation(ERROR, "Type definition was not found!", Input[i].Location));
		throw::runtime_error("ERROR!");
	}
	//reset the value
	Type->Type = CLASS_NODE;

	//combine inheritted memebrs
	Type->Get_Inheritted_Class_Members();

	if (Input[i + 1].is(Flags::TEMPLATE_COMPONENT)) {
		for (auto T : Input[i + 1].Components) {
			Node* Template = new Node(TEMPLATE_NODE, T.Value, &T.Location);

			Template->Inheritted.push_back("type");

			Type->Templates.push_back(Template);
		}
		Type->Template_Children = Input[Parenthesis_Indexes[0]].Components;
		Type->Is_Template_Object = true;
	}

	Parser p(Type);
	p.Input.push_back(Input[Parenthesis_Indexes[0]]);
	p.Factory();

	for (auto j : Type->Defined) {
		Safe s;
		s.Check_For_Undefined_Inheritance(j);
	}

	//This means that the class is a namespace
	//Namespace Combination system 5000
	if (Type->is("static") != -1) {

		for (auto& j : Type->Defined) {
			if (j->is("static") != -1)
				continue;
			if (j->Has({ FUNCTION_NODE, CLASS_NODE }))
				continue;

			j->Inheritted.insert(j->Inheritted.begin(), "static");
		}
	}

	Type->Append(Type->Childs, p.Input[0].node->Childs);

	p.Input.clear();

	//infiltrate the class type and inject this behemoth
	/*if (MANGLER::Is_Base_Type(Type) == false && sys->Info.Reference_Count_Size > 0) {
		Node* Reference_Count = new Node(OBJECT_DEFINTION_NODE, Type->Location);
		Reference_Count->Name = "Reference_Count";
		Reference_Count->Scope = Type;

		Node* Size_Representer = Type->Find(sys->Info.Reference_Count_Size, Type, CLASS_NODE, "integer");

		if (Size_Representer == nullptr) {
			Report(Observation(WARNING, "Cannot find suitable size type for the reference countter", *Type->Location));
			//we can still save this!
			Node* Size = new Node(OBJECT_DEFINTION_NODE, Type->Location);
			Size->Name = "size";
			Size->Size = sys->Info.Reference_Count_Size;
			Size->Inheritted.push_back("const");

			Reference_Count->Defined.push_back(Size);
			Reference_Count->Inheritted.push_back("type");
		}
		else
			Reference_Count->Inheritted.push_back(Size_Representer->Name);
	}*/

	Input.erase(Input.begin() + Parenthesis_Indexes[0]);

	if (i+1 < Input.size() && Input[i + 1].is(Flags::TEMPLATE_COMPONENT))
		Input.erase(Input.begin() + i + 1);

	Input.erase(Input.begin() + i);

	if (i < Input.size())
		Type_Pattern(i);

	return;
}

void Parser::Member_Pattern(int i)
{
	//foo.a = 1
	//IF LEXER ALREADY USES DOT COMPONENT AS OPERATOR THEN WE DONT NEED TO DO ENYTHING HERE :D.
}

void Parser::If_Pattern(int i)
{
	//<summary>
	//make the AST of condition as IF
	//if <condition/(condition)> <code-single-line/(multiline-code)>
	//Notice!!! The two next components need to be initialized before this!!!
	//</summary>
	if (!Input[i].is(Flags::KEYWORD_COMPONENT))
		return;
	vector<int> Parenthesis_Indexes = Get_Amount_Of(i + 1, Flags::PAREHTHESIS_COMPONENT, false);
	if (Parenthesis_Indexes.size() != 2)
		return;				

	//if (){..}
	//else (){..}		//this works as 'else if'
	//else {..}			//and this as normal 'else'
	//while (..){..}	//loop
	Node* con; 
	if (Input[i].Value == "if")
		con = new Node(IF_NODE, new Position(Input[i].Location)); 
	else if (Input[i].Value == "else")
		con = new Node(ELSE_IF_NODE, new Position(Input[i].Location));		//this works for only else if because it requers 2 paranthesis
	else if (Input[i].Value == "while")
		con = new Node(WHILE_NODE, new Position(Input[i].Location));
	else
		return;

	Parser p(con);
	con->Name = Input[i].Value;
	con->Scope = Scope;

	p.Input.push_back(Input[Parenthesis_Indexes[0]]);
	p.Factory();

	con->Parameters = p.Input[0].node->Childs;

	p.Input.clear();

	p.Input.push_back(Input[Parenthesis_Indexes[1]]);
	p.Factory();

	con->Childs = p.Input[0].node->Childs;

	Input[i].node = con;

	Input.erase(Input.begin() + Parenthesis_Indexes[0]);
	Input.erase(Input.begin() + Parenthesis_Indexes[1] - 1);

	return;
}

void Parser::Else_Pattern(int i)
{
	//here we patternise the else without a condition
	if (!Input[i].is(Flags::KEYWORD_COMPONENT))
		return;
	vector<int> Parenthesis_Indexes = Get_Amount_Of(i + 1, Flags::PAREHTHESIS_COMPONENT, false);
	if (Parenthesis_Indexes.size() != 1)
		return;

	if (Input[i].Value != "else")
		return;

	Node* Else = new Node(ELSE_NODE, new Position(Input[i].Location));

	Parser p(Else);
	Else->Name = Input[i].Value;
	Else->Scope = Scope;

	p.Input.push_back(Input[Parenthesis_Indexes[0]]);
	p.Factory();

	Else->Childs = p.Input[0].node->Childs;

	Input[i].node = Else;

	Input.erase(Input.begin() + Parenthesis_Indexes[0]);

	return;
}

void Parser::Operator_Order()
{
	if (Input.size() < 2)
		return;
	for (int i = 0; i < Input.size(); i++)
		Math_Pattern(i, { "->" }, NODE_CASTER);
	for (int i = 0; i < Input.size(); i++)
		Array_Pattern(i);
	for (int i = 0; i < Input.size(); i++)
		Math_Pattern(i, { "." }, OPERATOR_NODE);
	for (int i = 0; i < Input.size(); i++)
		Variable_Negate_Pattern(i);
	for (int i = 0; i < Input.size(); i++)
		Operator_PreFix_Pattern(i, { "++", "--" });
	for (int i = 0; i < Input.size(); i++)
		Operator_PostFix_Pattern(i, { "++", "--" });
	//the combination and multilayering of operations.
	for (int i = 0; i < Input.size(); i++)
		Math_Pattern(i, { ":" }, OPERATOR_NODE);
	for (int i = 0; i < Input.size(); i++)
		Math_Pattern(i, { "^" }, OPERATOR_NODE);
	for (int i = 0; i < Input.size(); i++)
		Math_Pattern(i, { "*", "/" , "%" }, OPERATOR_NODE);
	for (int i = 0; i < Input.size(); i++)
		Math_Pattern(i, { "+", "-" }, OPERATOR_NODE);
	for (int i = 0; i < Input.size(); i++)
		Math_Pattern(i, { "<<", ">>" }, BIT_OPERATOR_NODE);
	for (int i = 0; i < Input.size(); i++)
		Math_Pattern(i, { "==", "!=", "<=", ">=", "!<", "!>" , "|=", "&=" }, CONDITION_OPERATOR_NODE);
	for (int i = 0; i < Input.size(); i++)
		Math_Pattern(i, { "&", "!&" }, BIT_OPERATOR_NODE);
	//for (int i = 0; i < Input.size(); i++)
	//	Math_Pattern(i, { "?" }, BIT_OPERATOR_NODE);	
	for (int i = 0; i < Input.size(); i++)
		Math_Pattern(i, { "¤" }, BIT_OPERATOR_NODE);
	for (int i = 0; i < Input.size(); i++)
		Math_Pattern(i, { "|", "!|" }, BIT_OPERATOR_NODE);
	for (int i = 0; i < Input.size(); i++)
		Math_Pattern(i, { "<", ">" }, CONDITION_OPERATOR_NODE);

	for (int i = 0; i < Input.size(); i++)
		Math_Pattern(i, { "&&", "||" }, LOGICAL_OPERATOR_NODE);

	for (int i = 0; i < Input.size(); i++)
		Math_Pattern(i, { "=", "+=", "-=", "*=", "/=" }, ASSIGN_OPERATOR_NODE);
}

void Parser::Return_Pattern(int i)
{
	if (Input[i].Value != "return")
		return;
	if (Input[i].node != nullptr)
		return;
	bool No_Return_Value = (((size_t)i + 1 > Input.size() - 1) || (Input[i+1].node == nullptr));

	//return a + b
	//return;
	Node* ret = new Node(FLOW_NODE, new Position(Input[i].Location));
	ret->Name = "return";
	ret->Scope = Scope;
	if (!No_Return_Value) {
		ret->Right = Input[(size_t)i + 1].node;
		ret->Right->Context = ret;
		Input.erase(Input.begin() + i + 1);
	}
	Input[i].node = ret;
	return;
}

void Parser::Jump_Pattern(int i)
{
	//jump banana
	if (Input[i].Value != "jump")
		return;
	if (Input.size() < (size_t)i + 1)
		return;

	Node* jmp = new Node(FLOW_NODE, new Position(Input[i].Location));
	jmp->Name = "jump";
	
	Node* label = new Node(LABEL_NODE, new Position(Input[i].Location));
	label->Name = Input[(size_t)i + 1].Value;

	jmp->Right = label;

	Input[i].node = jmp;
	Input.erase(Input.begin() + i + 1);
}

void Parser::Label_Pattern(int i)
{
	if (Input[i].node != nullptr)
		return;
	//test
	//..
	//labels are tricy because they are just one word
	//so check that it isnt connectd to enythign
	Node* l = Scope->Find(Input[i].Value, Scope);
	if (l == nullptr)
		return;
	if (!l->is(LABEL_NODE))
		return;
	Node* L = new Node(LABEL_NODE, new Position(Input[i].Location));
	L->Name = Input[i].Value;
	L->Scope = Scope;
	
	Input[i].node = L;
}

void Parser::Label_Definition(int i)
{
	if (i - 1 <= 0)
		return;
	if ((size_t)i + 1 > Input.size()-1)
		return;
	if (Input[(size_t)i - 1].is(Flags::KEYWORD_COMPONENT))
		return;	//return label_name
	if (Input[(size_t)i + 1].is(Flags::TEXT_COMPONENT))
		return;	//label_name obj_name(int)
	if (Scope->Find(Input[i].Value, Scope) != nullptr)
		return;	//label_name(int), label_name = ..
	if (!Input[i].is(Flags::TEXT_COMPONENT))
		return;	//only text name allowed
	if (Input[i].Value == "\n")
		return;
	if (Input[(size_t)i - 1].is(Flags::OPERATOR_COMPONENT))
		return;
	if (Input[(size_t)i + 1].is(Flags::OPERATOR_COMPONENT))
		return;
	if (Input[i].Value == "size" || Input[i].Value == "format")
		return;
	//passes: label_name if (..)..
	//passes: label_name (..)
	//passes: label_name {..}
	Node* label = new Node(LABEL_NODE, new Position(Input[i].Location));
	label->Name = Input[i].Value;
	label->Scope = Scope;

	Input[i].node = label;

	Scope->Defined.push_back(label);
}

void Parser::Size_Pattern(int i)
{
	//size = 4
	if (Input[i].Value != "size")
		return;
	if (!Scope->is(CLASS_NODE))
		return;
	if (Input[i].node != nullptr)
		return;
	if (i - 1 >= 0)
		if (Input[(size_t)i - 1].is(Flags::OPERATOR_COMPONENT) || Input[(size_t)i - 1].is(Flags::TEXT_COMPONENT))
			return;
	if (Input[(size_t)i + 1].Value != "=")
		return;
	if (!Input[(size_t)i + 2].is(Flags::NUMBER_COMPONENT))
		return;
	Node* size = new Node(OBJECT_DEFINTION_NODE, new Position(Input[i].Location));

	size->Size = atoi((Input[(size_t)i + 2].node)->Name.c_str());

	size->Name = "size";
	size->Inheritted.push_back("const");	//NOTICE:!!! this might be wrong type!!!
	size->Scope = Scope;

	Scope->Defined.push_back(size);

	Input[i].node = size;

	Input.erase(Input.begin() + i + 1);
	Input.erase(Input.begin() + i + 1);
	return;
}

void Parser::Format_Pattern(int i)
{
	//format = decimal
	if (Input[i].Value != "format")
		return;
	if (!Scope->is(CLASS_NODE))
		return;
	if (i - 1 >= 0)
		if (Input[(size_t)i - 1].is(Flags::OPERATOR_COMPONENT) || Input[(size_t)i - 1].is(Flags::TEXT_COMPONENT) || Input[(size_t)i-1].is(Flags::KEYWORD_COMPONENT))
			return;
	if (Input[(size_t)i + 1].Value != "=")
		return;
	if (!Input[(size_t)i + 2].is(Flags::TEXT_COMPONENT))
		return;
	Node* format = new Node(OBJECT_DEFINTION_NODE, new Position(Input[i].Location));

	format->Format = Input[(size_t)i + 2].Value;

	format->Name = "format";
	format->Inheritted.push_back("const");	//NOTICE:!!! this might be wrong type!!!
	format->Scope = Scope;

	Scope->Defined.push_back(format);

	Input[i].node = format;

	Input.erase(Input.begin() + i + 1);
	Input.erase(Input.begin() + i + 1);
	return;
}

void Parser::Member_Function_Pattern(int i)
{
	//return_type class_name.funcname(){}
	if (Scope->is(FUNCTION_NODE))
		return;
	if (Input[i].Value != ".")
		return;

	//the name must be connected with the fethcer already by the dot operator.

	int Paranthesis_Offset = 1;
	if (i + Paranthesis_Offset < Input.size() && Input[i + Paranthesis_Offset].is(Flags::TEMPLATE_COMPONENT))
		Paranthesis_Offset = 2;

	vector<int> Parenthesis_Indexes = Get_Amount_Of(i + Paranthesis_Offset, Flags::PAREHTHESIS_COMPONENT, false);
	if (Parenthesis_Indexes.size() != 2)
		return;
	if (Input[Parenthesis_Indexes[1]].Value[0] != '{')
		return;
	if (Input[Parenthesis_Indexes[0]].Value[0] != '(')
		return;
	//set all the left sided of operators as the fetchers
	Input[i].node->Left->Transform_Dot_To_Fechering(Input[i].node->Right);

	//Find the scope that this function is set to as a member to.
	Node* Class = Scope->Find(Input[i].node->Right->Fetcher, Scope, CLASS_NODE);
	if (Class == nullptr)
		Report(Observation(ERROR, Input[i].node->Right->Fetcher->Name + " was not found when creating " + Input[i].node->Right->Name, Input[i].Location));

	//delete the tmp fecher defined in the parent scope.
	Node* Ghost_Definition = Input[i].node->Left;

	for (int j = 0; j < Scope->Defined.size(); j++)
		if (Ghost_Definition == Scope->Defined[j])
			Scope->Defined.erase(Scope->Defined.begin() + j);

	//unwrap the . operator
	Input[i].node->Right->Context = Input[i].node->Context;
	Input[i].node->Right->Scope = Input[i].node->Scope;
	Input[i].node = Input[i].node->Right;
	Input[i].Value = Input[i].node->Name;

	//port foward the fetcher magnetized inheritance to this function
	Input[i].node->Inheritted = Input[i].node->Fetcher->Inheritted;
	Input[i].node->Un_Initialized_Template_Inheritance = Input[i].node->Fetcher->Un_Initialized_Template_Inheritance;
	//clear exess stuff
	Input[i].node->Fetcher->Inheritted.clear();
	Input[i].node->Fetcher->Un_Initialized_Template_Inheritance.clear();

	//replace all the class named fetchers by the Class node for future referencing.
	//this code break c++ XD
	/*vector<Node*> Fethcers = Input[i].node->Get_All_Fetchers();

	for (auto& Fetcher : Fethcers) {
		if (Fetcher->Name == Class->Name)
			*Fetcher = *Class;
	}*/

	Function_Pattern(i);

	Class->Defined.push_back(Input[i].node);

	Node* Fethcer = Input[i].node->Fetcher;
	Input[i].node->Fetcher = nullptr;

	if (Class->Scope->Find(Input[i].node, Class->Scope, FUNCTION_NODE) == nullptr) {
		Class->Scope->Defined.push_back(Input[i].node);
		Input[i].node->Fetcher = Fethcer;
	}
	//Input[i].node->Fetcher = Fethcer;
	else if (Input[i].node->Fetcher = Fethcer; !Input[i].node->Compare_Fetchers(Class->Scope->Find(Input[i].node, Class->Scope, FUNCTION_NODE)))
		Class->Scope->Defined.push_back(Input[i].node);

}

void Parser::Use_Pattern(int i)
{
	//use foo
	if ((size_t)i + 1 >= Input.size())
		return;
	if (Input[i].Value != "use")
		return;
	if (!Input[(size_t)i + 1].is(Flags::TEXT_COMPONENT))
		return;

	Node* Namespace = Scope->Find(Input[(size_t)i + 1].Value);

	if (Namespace == nullptr)
		return;

	if (Namespace->is("static") == -1 || !Namespace->is(CLASS_NODE))
		return;

	vector<Node*> Inlined = Namespace->Defined;

	Scope->Append(Inlined, Namespace->Inlined_Items);

	Node* Closest_Namespace = Scope->Get_Scope_As(CLASS_NODE, Scope);

	for (auto &j : Inlined) {
		Node* n = j;
		if (j->is(FUNCTION_NODE))
			n = new Node(*n);

		j = j->Copy_Node(n, Closest_Namespace);
	}

	for (auto &j : Inlined) {
		if (j->Fetcher)
			continue;

		j->Fetcher = Namespace;
	}

	for (auto &j : Inlined) {
		if (j->Is_Template_Object)
			continue;
		if (j->Has({ FUNCTION_NODE, CLASS_NODE })) 
			continue;

		j->Update_Size();
	}

	Closest_Namespace->Append(Closest_Namespace->Inlined_Items, Inlined);

	Input.erase(Input.begin() + i, Input.begin() + i + 2);
}

Component* Parser::Construct_Virtual_Class_For_Complex_Cast(Component Parenthesis)
{
	Node* Virtual_Class = new Node(CLASS_NODE, new Position(Parenthesis.Location));

	for (auto i : Parenthesis.Components) {
		Virtual_Class->Inheritted.push_back(i.Value);
	}

	string Virtual_Class_Name = "____VIRTUAL_CLASS";

	for (auto i : Virtual_Class->Get_Inheritted())
		Virtual_Class_Name += "_" + i;

	Component *Cast = new Component(Virtual_Class_Name, Flags::TEXT_COMPONENT);

	if (Scope->Find(Virtual_Class_Name)) {
		Cast->node = Scope->Copy_Node(Scope->Find(Virtual_Class_Name), Scope->Find(Virtual_Class_Name)->Scope);
		return Cast;
	}

	Virtual_Class->Name = Virtual_Class_Name;
	Virtual_Class->Scope = Scope->Get_Scope_As(CLASS_NODE, {"static"}, Scope);

	Virtual_Class->Update_Size();

	Virtual_Class->Scope->Defined.push_back(Scope->Copy_Node(Virtual_Class, Virtual_Class->Scope));

	Cast->node = Virtual_Class;

	return Cast;
}

void Parser::Factory() {
	for (int i = 0; i < Input.size(); i++)
		Combine_Comment(i);
	for (int i = 0; i < Input.size(); i++)
		Combine_Import_Shattered_Return_Info(i);
	for (int i = 0; i < Input.size(); i++)
		Template_Pattern(i);
	for (auto& i : Input)
		Construct_Virtual_Class_To_Represent_Multiple_Template_Inputs(i);
	for (int i = 0; i < Input.size(); i++) {
		//variable/objects definator.		
		Prototype_Pattern(i);	//Definition_pattern stoles this import functions, so this goes first
		Import_Pattern(i);
		//Template_Pattern(i);
		Definition_Pattern(i);
		Label_Definition(i);
	}
	for (int i = 0; i < Input.size(); i++)
		Remove_All_Excess_Comments(i);
	for (int i = 0; i < Input.size(); i++) {
		//multiline AST stuff
		Combine_Dot_In_Member_Functions(i);
		Type_Pattern(i);		//class constructor
		Use_Pattern(i);
		Inject_Template_Into_Member_Function_Fetcher(i);
		if (Input.size() == 0 || i >= Input.size())
			break;
		Nodize_Template_Pattern(i);
		Constructor_Pattern(i);	//constructor needs the type to be defined as a class 
		Member_Function_Pattern(i);
		Function_Pattern(i);
		If_Pattern(i);
		Else_Pattern(i);
		Callation_Pattern(i);
		Jump_Pattern(i);
	}
	for (int i = 0; i < Input.size(); i++) {
		//prepreattor for math operator AST combinator.
		Object_Pattern(i);
		Template_Type_Constructor(i);
		Complex_Cast(i);
		Parenthesis_Pattern(i);
		String_Pattern(i);
		Number_Pattern(i);
		Label_Pattern(i);
	}
	for (int i = 0; i < Input.size(); i++) {
		Size_Pattern(i);
		Format_Pattern(i);
	}
	for (int i = 0; i < Input.size(); i++) {
		Operator_Combinator(i);
	}
	//AST operator combinator.
	Operator_Order();
	for (int i = 0; i < Input.size(); i++) {
		Return_Pattern(i);
	}

}


C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Cpp\Parser\PostProsessor.cpp" 
#include "../../H/Parser/PostProsessor.h"
#include "../../H/Docker/Mangler.h"
#include "../../H/Parser/Parser.h"
#include "../../H/Lexer/Lexer.h"
#include "../../H/UI/Safe.h"
#include "../../H/UI/Usr.h"

extern Node* Global_Scope;
extern bool Optimized;
extern Usr* sys;

void PostProsessor::Factory() {
	Transform_Component_Into_Node(); 
	for (int i = 0; i < Scope->Defined.size(); i++) {
		//the prototypes needs the types to have sizes to determine the number parameters assosiative type.
		Type_Size_Definer(i);
	}
	for (int i = 0; i < Scope->Defined.size(); i++) {
		//the prototypes needs the types to have sizes to determine the number parameters assosiative type.
		Handle_Imports(i);
	}
	for (int i = 0; i < Scope->Defined.size(); i++) {
		Type_Definer(Scope->Defined[i]);
	}
	for (auto& i : Scope->Defined) {
		//the prototypes needs the types to have sizes to determine the number parameters assosiative type.
		Member_Function_Defined_Outside(i);
		Member_Function_Defined_Inside(i);
		Open_Function_For_Prosessing(i);
	}

	if (sys->Info.Is_Service && sys->Service_Info != Document_Request_Type::ASM)
		return;

	//Define_Sizes(Parent);
	for (int i = 0; i < Input.size(); i++) {
		//Handle_Namespace_Inlining(i);
		Cast(Input[i]);
		Open_Paranthesis(i);
		Operator_Overload(i);
		Open_Condition_For_Prosessing(i);
		Open_Loop_For_Prosessing(i);
		//Combine_Conditions(i);
		Combine_Member_Fetching(Input[i]);
		Determine_Return_Type(i);
		Determine_Array_Type(i);
		Open_Call_Parameters_For_Prosessing(i);
		Find_Call_Owner(Input[i]);
		Analyze_Global_Variable_Changes(i);
		Change_Local_Strings_To_Global_Pointters(i);
		Update_Operator_Inheritance(Input[i]);
		Analyze_Return_Value(Input[i]);
		Increase_Calling_Number_For_Function_Address_Givers(Input[i]);
		Open_PreFix_Operator(i);
		Open_PostFix_Operator(i);
	}
	//Open_Safe(Input);
	for (int i = 0; i < Input.size(); i++)
		Combine_Condition(i);
	for (int i = 0; i < Input.size(); i++)
		Move_Global_Varibles_To_Header(i);
}

void PostProsessor::Transform_Component_Into_Node()
{
	//<summary>
	//Extracts the Node ptr's from the component tokens
	//</summary>
	for (auto i : Components) {
		if (i.node == nullptr)
			continue;
		Node* n = i.node;
		Input.push_back(n);
	}
	return;
}

void PostProsessor::Type_Definer(Node* type)
{
	//<summary>
	//stack type info
	//</summary>
	if (type->Type != CLASS_NODE)
		return;
	if (type->Templates.size() > 0)	//template types are constructed elsewhere.
		return;
	if (type->is(PARSED_BY::TYPE_DEFINER))
		return;
	type->Parsed_By |= PARSED_BY::TYPE_DEFINER;

	//If this is a namespace skip the default constructor builder
	if (type->is("static") != -1) {
		return;
	}

	/*for (auto& j : Scope->Defined[i]->Defined)
		if (j->is(FUNCTION_NODE) && (j->Parameters.size() == 0 || j->Parameters[0]->Inheritted[0] != Scope->Defined[i]->Name)) {
			
p(Scope->Defined[i], { j });
			//p.Input = { j };
			//p.Member_Function_Defined_Inside(0);
			//j = p.Output[0];
		}*/

	//check for static members and move them into Header section to be labelazed
	for (auto& j : type->Childs)
		if (j->Has({ OPERATOR_NODE, ASSIGN_OPERATOR_NODE, CONDITION_OPERATOR_NODE, BIT_OPERATOR_NODE })) {
			if (j->Left->is("static") != -1 && Node::Has(type->Header, j->Left) == false)
				type->Header.push_back(j);
		}
		else if (j->is("static") != -1 && Node::Has(type->Header, j) == false)
			type->Header.push_back(j);

	//infiltrate the class type and inject this behemoth
	Node* Type = type;
	if ((MANGLER::Is_Base_Type(Type) == false) && (!MANGLER::Is_Based_On_Base_Type(Type) || Type->Defined.size() > 0) && sys->Info.Reference_Count_Size > 0) {
		Node* Reference_Count = new Node(OBJECT_DEFINTION_NODE, Type->Location);
		Reference_Count->Name = "Reference_Count";
		Reference_Count->Scope = Type;

		Node* Size_Representer = Type->Find(sys->Info.Reference_Count_Size, Type->Get_Scope_As(CLASS_NODE, {"static"}, Type), CLASS_NODE, "integer");

		if (Size_Representer == nullptr) {
			Report(Observation(WARNING, "Cannot find suitable size type for the reference countter", *Type->Location));
			//we can still save this!
			Node* Size = new Node(OBJECT_DEFINTION_NODE, Type->Location);
			Size->Name = "size";
			Size->Size = sys->Info.Reference_Count_Size;
			Size->Inheritted.push_back("const");

			Reference_Count->Defined.push_back(Size);
			Reference_Count->Inheritted.push_back("type");
		}
		else
			Reference_Count->Inheritted.push_back(Size_Representer->Name);

		Type->Defined.insert(Type->Defined.begin(), Reference_Count);
	}

	//constructed template classes are defined later on in the scope, so theyre memebrs are not defined properly
	for (auto& i : type->Defined) {
		Update_Template_Member_Members(i);
	}

	Destructor_Generator(type);

	//DISABLE default constructor if user has already defined one.
	for (auto j : Scope->Defined) {
		if (!j->is(FUNCTION_NODE))
			continue;
		if (j->Name != type->Name)
			continue;

		if (j->is("ptr") == -1)
			continue;	//constructor must return a ptr
		if (j->is(type->Name) == -1)
			continue;	//constructor must return its self typed class type ptr.

		if (j->Parameters.size() != 1)
			continue;
		if (j->Parameters[0]->is(type->Name) == -1)
			continue;
		if (j->Parameters[0]->is("ptr") == -1)
			continue;	//constructor must take itself as a ptr.
		return;	//the user has already defined the default constructor for us.
	}

	//make a default constructor.
	//insert the constructor into global scopes funciton list.
	Node* Function = new Node(FUNCTION_NODE, type->Location);
	Function->Name = type->Name;
	Function->Inheritted = { type->Name, "ptr" };
	Function->Scope = Global_Scope;

	Node* This = new Node(PARAMETER_NODE, type->Location);
	This->Inheritted = { type->Name, "ptr"};
	This->Name = "this";
	This->Defined = type->Defined;
	This->Scope = Function;
	This->Update_Size();

	Function->Parameters.push_back(This);
	Function->Defined.push_back(This);

	Function->Update_Size();

	Node* p = type;
	if (p->Has({ "cpp", "evie", "vivid" }) != -1)
		Function->Inheritted.push_back(p->Inheritted[p->Has({ "cpp", "evie", "vivid" })]);

	Function->Childs = Insert_Dot(type->Childs, Function, This);

	//call all the inheritted default or overrided constructor calls.
	vector<Node*> tmp = Dottize_Inheritanse(type, This, Function);

	Function->Childs.insert(Function->Childs.begin(), tmp.begin(), tmp.end());

	//make the return of this pointter
	Node* ret = new Node(FLOW_NODE, type->Location);
	ret->Name = "return";
	ret->Right = new Node(*This);
	ret->Scope = Function;
	Function->Childs.push_back(ret);

	PostProsessor P(Function, Function->Childs);

	Function->Childs = P.Input;

	Scope->Append(Function->Childs, P.Output);

	Global_Scope->Defined.push_back(Function);
	Global_Scope->Childs.push_back(Function);


	for (auto& j : type->Defined)
		if (j->is(FUNCTION_NODE) /* && (j->Parameters.size() == 0 || j->Parameters[0]->Inheritted[0] == Scope->Defined[i]->Name) */ ) {
			PostProsessor p(type);
			p.Member_Function_Defined_Inside(j);
			p.Member_Function_Defined_Outside(j);
		}

	for (auto& j : type->Defined)
		if (j->is(FUNCTION_NODE)) {
			PostProsessor p(type);
			p.Open_Function_For_Prosessing(j);
		}


	return;
}

void PostProsessor::Destructor_Generator(Node* Type)
{
	if (sys->Info.Reference_Count_Size < 1)
		return;

	if (MANGLER::Is_Base_Type(Type) || (MANGLER::Is_Based_On_Base_Type(Type) && Type->Defined.size() == 0))
		return;
	//[type].Destructor(){
	//	if ([member] != 0->address && --[member].Reference_Count < 1){
	//		[member].Destructor()
	//		Deallocate<[member type]>([member])
	// 	}
	//}

	string Ifs = "";
	//if (Type->is("ptr") != -1) {
		Ifs +=
			"if (this != 0->address && --Reference_Count < 1){\n";
	//}

	for (auto Member : Type->Defined) {
		if (Member->is(FUNCTION_NODE))
			continue;
		if ((Member->is("ptr") == -1) || MANGLER::Is_Base_Type(Member) || MANGLER::Is_Based_On_Base_Type(Member))
			continue;

		string Member_Types = "";
		for (auto I : Member->Inheritted) {
			Member_Types += " " + I;
		}

		Ifs += 
			"if (" + Member->Name + " != 0->address && --" + Member->Name + ".Reference_Count < 1){\n" +
				Member->Name + ".Destructor()\n" +
				"Deallocate<" + Member_Types + ">(" + Member->Name + ")\n" +
			"}\n";
	}

	Ifs += "Deallocate<" + Type->Name + ">(this)\n}";
	//}
	//The function itself needs to be constructed with a this pointter.
	Node* Func = new Node(FUNCTION_NODE, Type->Location);
	Func->Name = "Destructor";
	Func->Inheritted.push_back("func");
	Func->Scope = Type;

	Node* This = new Node(PARAMETER_NODE, Type->Location);
	This->Name = "this";
	This->Inheritted = { Type->Name, "ptr" };
	This->Scope = Func;

	Func->Parameters.push_back(This);
	Func->Defined.push_back(This);

	Parser p(Func);
	p.Input = Lexer::GetComponents(Ifs);
	p.Factory();
	Func->Childs.push_back(p.Input[0].node);

	Func->Childs = Insert_Dot(Func->Childs, Func, This);

	/*for (int i = 0; i < Func->Parameters.size(); i++)
		if (Func->Parameters[i] == This)
			Func->Parameters.erase(Func->Parameters.begin() + i);

	for (int i = 0; i < Func->Defined.size(); i++)
		if (Func->Defined[i] == This)
			Func->Defined.erase(Func->Defined.begin() + i);*/

	Func->Parsed_By |= PARSED_BY::MEMBER_FUNCTION_DEFINED_INSIDE;

	Type->Defined.push_back(Func);
}

void PostProsessor::Destructor_Caller(Node* v, vector<Node*> &childs)
{
	if (!v->is(OBJECT_DEFINTION_NODE))
		return;
	if (MANGLER::Is_Based_On_Base_Type(v))
		return;
	if (v->is("ptr") == -1)
		return;
	if (v->is(PARSED_BY::DESTRUCTOR_CALLER))
		return;

	Parser p(v->Scope);
	p.Input = Lexer::GetComponents(v->Name + ".Destructor()");
	p.Factory();

	v->Parsed_By |= PARSED_BY::DESTRUCTOR_CALLER;

	PostProsessor P(v->Scope, p.Input);
	//v->Append(Output, P.Input);

	bool There_Is_No_User_Defined_Return = true;
	for (int i = childs.size()-1; i >= 0; i--) {
		if (childs[i]->Name == "return") {
			childs.insert(childs.begin() + i, P.Input.begin(), P.Input.end());
			There_Is_No_User_Defined_Return = false;
		}
	}

	if (There_Is_No_User_Defined_Return) {
		childs.insert(childs.end(), P.Input.begin(), P.Input.end());
	}
}

vector<Node*> PostProsessor::Insert_Dot(vector<Node*> Childs, Node* Function, Node* This)
{
	vector<Node*> Result;
	for (auto Child : Childs) {
		Update_Operator_Inheritance(Child);
		//this is for the size and format to not be included in the default constructor.
		if (Child->is("const") != -1)
			continue;
		/*if (Child->is("static") != -1)
			continue;*/

		//this is for the class constructor to not include functions as a dottize operation.
		if (Child->is(FUNCTION_NODE))
			continue;

		//Because the child in question is the highest in the ast towards tyhe function as a child.
		Node* Child_Copy = Child->Copy_Node(Child, Function);

		//insert this. infront of every member
			for (auto& Object : Child_Copy->Get_all({ OBJECT_DEFINTION_NODE, OBJECT_NODE, CALL_NODE })) {
				if (Object->is(NUMBER_NODE) || Object->is(FUNCTION_NODE) || (Object->is("const") != -1) || MANGLER::Is_Base_Type(Object))
					continue;
				if ((Object->is(OBJECT_DEFINTION_NODE) || Object->is(OBJECT_NODE)) && This->Find(Object, This) != nullptr && !Object->is(PARSED_BY::THIS_AND_DOT_INSERTER)) {
					//Node* define = c->Find(linear_n, Function);

					Node* Dot = new Node(OPERATOR_NODE, Function->Location);
					Dot->Name = ".";
					Dot->Scope = Object->Scope;

					Dot->Left = This->Copy_Node(This, This->Scope);

					Dot->Right = new Node(*Object);
					Dot->Right->Parsed_By |= PARSED_BY::THIS_AND_DOT_INSERTER;

					Dot->Context = Object->Context;

					*Object = *Dot;
				}
				else if (Object->is(CALL_NODE)) {
					//because this insert_dot is called upon a non hight AST member it needs to use the dynamic scope above.
					Object->Parameters = Insert_Dot(Object->Parameters, Object->Scope, This);
				}
			}
		Result.push_back(Child_Copy);
	}
	return Result;
}

vector<Node*> PostProsessor::Dottize_Inheritanse(Node* Class, Node* This, Node* Funciton)
{
	vector<Node*> Result;
	for (auto i : Class->Inheritted) {
		if (Lexer::GetComponents(i)[0].is(Flags::KEYWORD_COMPONENT))
			continue;

		Node* Call = new Node(CALL_NODE, Class->Location);
		Call->Parameters.push_back(This->Copy_Node(This, Funciton));

		Call->Parameters.back()->Context = Call;

		Call->Name = i;
		Call->Scope = Funciton;

		Result.push_back(Call);
	}
	return Result;
}

void PostProsessor::Cast(Node* n)
{
	if (!n->is(NODE_CASTER))
		return;

	n->Left->Cast_Type = n->Right;
	n->Left->Cast_Type->Type = OBJECT_NODE;
	n->Left->Context = n->Context;

	*n = *n->Left;
}

void PostProsessor::Increase_Calling_Number_For_Function_Address_Givers(Node* n)
{
	if (!n->is(OBJECT_NODE))
		return;

	Node* f;
	if (!n->Find(n->Name, n->Scope, FUNCTION_NODE)) {
		if (!n->Find(n->Name, n->Scope, IMPORT)) {
			if (!n->Find(n->Name, n->Scope, PROTOTYPE))
				return;
			else
				f = n->Find(n->Name, n->Scope, PROTOTYPE);
		}
		else
			f = n->Find(n->Name, n->Scope, IMPORT);
	}
	else
		f = n->Find(n->Name, n->Scope, FUNCTION_NODE);

	f->Calling_Count++;

	n->Function_Address_Giver = true;
}

void PostProsessor::Process_Function_Pointters(Node* scope)
{
	//first we need to identify all function pointters
	//the identification of a function pointter is:
	//func ptr X
	for (auto& Defined : scope->Defined) {
		if (!Defined->is(vector<string>{"func", "ptr"}))
			return;

			Defined->Function_Ptr = true;	
			
			//letus find the function adress giver
			for (int Line = 0; Line < scope->Childs.size(); Line++) {
				for (auto& Operator : scope->Childs[Line]->Get_all()) {//we dont want to filter the get all beacuse the get all will sort the returned items
					if (Operator->is(ASSIGN_OPERATOR_NODE) && Operator->Left->Name == Defined->Name && Operator->Right->is(OBJECT_NODE)) {
						if (Operator->Find(Operator->Right, Operator->Right)->Has({ IMPORT, FUNCTION_NODE })) {
							string Function_Name = Operator->Right->Name;
							Node* First_Call_Type = nullptr;
							//Now that we know the function name we need to know what function 
							//overload we want to call.
							for (int i = Line + 1; i < scope->Childs.size(); i++) {
								for (auto& j : scope->Childs[i]->Get_all()) {
									if (j->is(ASSIGN_OPERATOR_NODE) && j->Left->Name == Defined->Name)
										goto quit;

									if (j->is(CALL_NODE)) {
										Node* Call = new Node(CALL_NODE, j->Location);
										Call->Name = Function_Name;
										Call->Parameters = j->Parameters;
										Call->Scope = j->Scope;

										Update_Inheritance(j);
										Call->Inheritted = j->Inheritted;

										Find_Call_Owner(Call);

										j->Function_Implementation = Call->Function_Implementation;
										 
										if (First_Call_Type == nullptr)
											First_Call_Type = Call;
										else if (First_Call_Type->Function_Implementation != Call->Function_Implementation) {
											Node* Assing = new Node(ASSIGN_OPERATOR_NODE, j->Location);
											Assing->Name = "=";
											Assing->Scope = j->Scope;

											Assing->Left = new Node(*Defined);
											Assing->Right = new Node(OBJECT_NODE, j->Location);
											Assing->Right->Name = Function_Name;

											Assing->Left->Context = Assing;
											Assing->Right->Context = Assing;

											j->Header.push_back(Assing);
											goto quit;
										}

									}
								}
							}
						quit:;

							if (First_Call_Type) {
								Operator->Right->Function_Implementation = First_Call_Type->Function_Implementation;
							}
						}
						else {
							//this happends when a function pointter is passed to another one
							Report(Observation(ERROR, "YEET"));
						}
					}

				}
			}
	}


}

void PostProsessor::Member_Function_Defined_Outside(Node* f)
{
	//<summary>
	//	The function is in global scope's childs list-
	//	but it can be found in the respective scope that the fetchers describe.
	//	The Find function in Node.cpp can handle complex AST search to find the respective function.
	//	
	//	If the function in question is not a static type then we need to apply this pointters and other cool stuf.
	//</summary>
	if (f->Type != FUNCTION_NODE)
		return;
	if (f->Fetcher == nullptr)
		return;
	if (f->is("static") != -1)
		return;
	if (f->Parameters.size() > 0 && f->Parameters[0]->Name == "this")
		return;

	Node* func = f;

	Node* Class = func->Find(func->Fetcher->Name, func, CLASS_NODE);

	Node* This = new Node(PARAMETER_NODE, "this", func->Location);
	This->Inheritted = { func->Fetcher->Name, "ptr" };
	This->Scope = func;
	This->Size = _SYSTEM_BIT_SIZE_;
	This->Defined = Class->Defined;
	This->Inheritable_templates = Class->Inheritable_templates;

	func->Defined.push_back(This);

	func->Parameters.insert(func->Parameters.begin(), This);

	func->Childs = Insert_Dot(func->Childs, func, This);

	Node* Fetcher = func->Find_Scope(func);

	func->Fetcher = Fetcher;

	func->Parsed_By |= PARSED_BY::POSTPROSESSOR;

	return;
}

void PostProsessor::Member_Function_Defined_Inside(Node* f)
{
	if (!f->is(FUNCTION_NODE))
		return;
	if (f->is("static") != -1)
		return;
	if (Scope->Name == "GLOBAL_SCOPE")
		return;
	if (f->Fetcher != nullptr)
		return;
	if (f->is(PARSED_BY::MEMBER_FUNCTION_DEFINED_INSIDE))
		return;

	Node* func = f;

	Node* Class = func->Find(Scope->Name, func, CLASS_NODE);

	Node* This = new Node(PARAMETER_NODE, "this", func->Location);
	This->Inheritted = { Scope->Name, "ptr" };
	This->Scope = func;
	This->Size = _SYSTEM_BIT_SIZE_;
	This->Defined = Class->Defined;
	This->Inheritable_templates = Class->Inheritable_templates;


	func->Defined.push_back(This);

	func->Parameters.insert(func->Parameters.begin(), This);

	func->Childs = Insert_Dot(func->Childs, func, This);

	Node* scope = Scope->Find(Scope->Name, Scope, CLASS_NODE);

	func->Parsed_By |= PARSED_BY::POSTPROSESSOR;
	func->Parsed_By |= PARSED_BY::MEMBER_FUNCTION_DEFINED_INSIDE;

	return;
}

void PostProsessor::Update_Template_Member_Members(Node* n)
{
	//this n represents a member in a class that inherits a template type
	PostProsessor p(Scope);

	//no need to trace this, because the type_definer marks it's procecced
	for (auto inheritted : n->Inheritted) {
		if (Lexer::GetComponent(inheritted).is(Flags::KEYWORD_COMPONENT))
			continue;

		Node* Inheritted_Type = n->Find(inheritted, n, CLASS_NODE);

		p.Type_Definer(Inheritted_Type);
	}
}

void PostProsessor::Open_Function_For_Prosessing(Node* f)
{
	//here we just go trugh the insides of the function
	//for optimization and other cool stuff :D
	if (!f->is(FUNCTION_NODE))
		return;
	if (f->Is_Template_Object)
		return;
	if (f->is(PARSED_BY::FUNCTION_PROSESSOR))
		return;
	for (auto j : f->Get_All_Fetchers())
		if (j->Is_Template_Object)
			return;

	f->Parsed_By |= PARSED_BY::FUNCTION_PROSESSOR;
	/*for (auto j : Input[i]->Parameters)
		if (j->is("type") != -1)
			return;
	*/
	
	PostProsessor p(f);
	p.Input = f->Childs;

	//prepare the local variables
	p.Define_Sizes(f);

	f->Update_Format();

	f->Update_Size();

	Open_Safe({ f });

	Process_Function_Pointters(f);

	p.Factory();

	f->Childs = p.Input;

	//clear from nested scopes current value.
	for (auto &i : f->Childs)
		for (auto &j : i->Get_all({IF_NODE, ELSE_IF_NODE, ELSE_NODE, WHILE_NODE}))
			for (auto& k : j->Defined)
				k->Current_Value = nullptr;

	//NOTE: This might not be able to detect nested scope members that might return
	//this implies that the nested scope needs to also deduce the destructors of the main scope defined
	for (auto& v : f->Defined)
		p.Destructor_Caller(v, f->Childs);

	while (true) {
		Algebra a(f, &f->Childs);
		if (!Optimized)
			break;
		Optimized = false;
	}

	if (!sys->Info.Is_Service || sys->Service_Info == Document_Request_Type::ASM)
		for (auto& v : f->Defined) {
			for (auto j : f->Childs) {
				Analyze_Variable_Address_Pointing(v, j);
				if (v->Requires_Address)
					break;
			}
		}

	Define_Sizes(f);

	//Parent->Defined[i]->Update_Defined_Stack_Offsets();
	Scope->Append(f->Childs, p.Output);

	f->Parsed_By |= PARSED_BY::POSTPROSESSOR;
	return;
}

void PostProsessor::Open_Condition_For_Prosessing(int i)
{
	if (!Input[i]->is(IF_NODE) && !Input[i]->is(ELSE_IF_NODE) && !Input[i]->is(ELSE_NODE))
		return;
	//this add the L number to it
	//Input[i]->Name += to_string(LNumber++);

	//preprare the local variables
	Define_Sizes(Input[i]);

	if (!Input[i]->is(ELSE_NODE)) {
		PostProsessor p(Input[i], Input[i]->Parameters);

		Input[i]->Parameters = p.Input;
	}

	Process_Function_Pointters(Input[i]);

	//here we now postprosess also the insides of the condition
	PostProsessor p(Input[i], Input[i]->Childs);

	Input[i]->Childs = p.Input;

	Algebra_Laucher(Input[i], Input[i]->Childs);

	for (auto& v : Input[i]->Defined)
		p.Destructor_Caller(v, Input[i]->Childs);

	Scope->Append(Input[i]->Childs, p.Output);

	return;
}

void PostProsessor::Open_Paranthesis(int i)
{
	if (!Input[i]->is(CONTENT_NODE))
		return;

	PostProsessor p(Input[i], Input[i]->Childs);

	Input[i]->Childs = p.Input;

	for (auto& v : Input[i]->Defined)
		p.Destructor_Caller(v, Input[i]->Childs);

	Scope->Append(Input[i]->Childs, p.Output);

	if (Input[i]->Childs.back()->Cast_Type)
		Input[i]->Inheritted.push_back(Input[i]->Childs.back()->Cast_Type->Name);

	if (Input[i]->Inheritted.size() == 0)
		Input[i]->Inheritted = Input[i]->Childs.back()->Inheritted;
}

void PostProsessor::Find_Call_Owner(Node* n)
{
	if (!n->is(CALL_NODE))
		return;
	if (n->Function_Implementation != nullptr)
		return;

	//stuff that this function chekcs
	// 
	// Differential parametric count analyzation
	// Differential return type analyzation
	// Differential template inserion analysis
	// Differential template class insertion analysis
	// 

	vector<pair<Node*, Node*>> Candidates;
	bool It_Is_A_Function_Pointter = false;
	while (n->Function_Implementation == nullptr) {
		Candidates = Find_Suitable_Function_Candidates(n, It_Is_A_Function_Pointter);
		int Note = Choose_Most_Suited_Function_Candidate(Order_By_Accuracy(Candidates, n), n, It_Is_A_Function_Pointter);

		// returns 0 if found caller's function implemitation.
		if (Note == 0) {
			break;
		}
		// returns 1 if constructed a new function implemitation based on the template types
		else if (Note == 1) {
			continue;
		}
		// returns -1 if nothing found
		else if (Note == -1) {
			if (It_Is_A_Function_Pointter == false)
				It_Is_A_Function_Pointter = true;
			else
				Report(Observation(ERROR, "Cannot find function to call!", *n->Location));
		}
		// returns 2 if there is more than one suitable functions to call.
		else if (Note == 2) {
			Report(Observation(ERROR, "Cannot decide which function overload to call!", *n->Location));
		}
	}
	//the incerement of all func ptr candidates calling count happends at Choose_Most_Suited_Function_Candidate()
	if (It_Is_A_Function_Pointter == false) {
		//n->Function_Implementation->Calling_Count++;
		n->Inheritted = n->Function_Implementation->Inheritted;
	}
	else {
		if (n->Find(n, n) == nullptr) {
			Report(Observation(ERROR, "Usage of un-defined caller '" + n->Name + "'.", *n->Location));
		}
		n->Size = n->Find(n, n)->Size;
		n->Inheritted = n->Find(n, n)->Inheritted;
	}
}

vector<pair<Node*, Node*>> PostProsessor::Find_Suitable_Function_Candidates(Node* caller, bool Skip_Name_Comparison)
{
	vector<pair<Node*, Node*>> Result;

	//first try to find the scope, by checking fetchers
	vector<Node*> Scopes;

	if (caller->Fetcher) {
		/*if (caller->Fetcher->Defined.size() == 0) {
			caller->Fetcher->Defined = caller->Find(caller->Fetcher, caller->Scope)->Defined;
		}*/
		Scopes.push_back(caller->Find(caller->Fetcher, caller->Scope));
	}
	else if (caller->Get_Scope_As(CLASS_NODE, caller) != Global_Scope) {
		Scopes.push_back(caller->Get_Scope_As(CLASS_NODE, caller));
	}
	//Get_Scope_Path() doesnt give us Global_Scope, so lets add it manually.
	Scopes.push_back(Global_Scope);

	string New_Name = "";
	bool Inherit_Templates = false;
	if (caller->Templates.size() > 0) {
		New_Name = caller->Construct_Template_Type_Name();
	}
	else {
		Inherit_Templates = true;
	}

	bool Can_Remove_Templates = false;

	//now that our scopes are ready to go, we can loop through them and find suitable candidates.
	for (auto Scope : Scopes) {
		if (Inherit_Templates && Scope->Inheritable_templates.size() > 0) {
			caller->Templates = Scope->Inheritable_templates;
			New_Name = caller->Construct_Template_Type_Name();
			Can_Remove_Templates = true;
		}

		for (auto Func : Scope->Defined) {
			bool Is_Similiar_To_Existing_Template_Func_That_Has_Been_Constructed = false;
			if (!Func->Has({ FUNCTION_NODE, PROTOTYPE, IMPORT, EXPORT }))
				continue;

			if (Scope == caller->Fetcher) {
				if (Func->Fetcher != nullptr) {
					//this function has been declared at global scope
					continue;
				}
			}

			//this part is skipped if the function is a fuinction pointer.
			if (!Skip_Name_Comparison) {
				//check if the names are smae
				if (Func->Name != caller->Name)
					//if there is a mangled template name
					if (New_Name != "") {
						//check the mangled template name
						if (New_Name != Func->Name)
							continue;
						else
							Is_Similiar_To_Existing_Template_Func_That_Has_Been_Constructed = true;
					}
					else
						continue;
				//Check if the templates are temporarly made for just this instance.
				else if (Func->Templates.size() == 0 && Can_Remove_Templates) {
					caller->Templates.clear();
				}
			}
			if (Func->Parameters.size() != caller->Parameters.size())
				continue;
			if (Func->Templates.size() != caller->Templates.size() && !Is_Similiar_To_Existing_Template_Func_That_Has_Been_Constructed)
				continue;

			Result.push_back({ Func, Scope });
		}
	}
	return Result;
}

map<int, vector<pair<pair<Node*, Node*>, Node*>>> PostProsessor::Order_By_Accuracy(vector<pair<Node*, Node*>> Candidates, Node* Caller)
{
	//save the candidatea by int accuracity
	map<int, vector<pair<pair<Node*, Node*>, Node*>>> Result;

	for (auto Candidate : Candidates) {
		//for every point the accuracity increases.
		int Accuracity = 0;

		Node* Func = Candidate.first;

		//banana<int>(...)
		//make the template ready for comparison.
		if (Candidate.first->Is_Template_Object) {
			Func = Candidate.first->Copy_Node(new Node(*Candidate.first), Candidate.second);

			for (int T = 0; T < Caller->Templates.size(); T++) {

				//T ptr banana<T>() -> int ptr banana<int>()
				for (auto& Return_Type : Func->Inheritted) {
					if (Return_Type == Func->Templates[T]->Name)
						Return_Type = Caller->Templates[T]->Name;
				}

				//List<T> banana<T>() -> List<int> banana<int>()
				for (auto& Return_Type : Func->Un_Initialized_Template_Inheritance) {
					for (auto& Template : Return_Type.first.Components[0].Get_all()) {
						if (Template->Value == Func->Templates[T]->Name)
							Template->Value = Caller->Templates[T]->Name;
					}
				}

				//func banana<T>(T a)
				for (auto& Parameter : Func->Parameters) {
					for (auto& Inherit : Parameter->Inheritted) {
						if (Inherit == Func->Templates[T]->Name)
							Inherit = Caller->Templates[T]->Name;
					}
				}

				//func banana<T>(List<T> a)
				for (auto& Parameter : Func->Parameters) {
					for (auto& Template : Parameter->Un_Initialized_Template_Inheritance) {
						for (auto& Nested_Template : Template.first.Get_all()) {
							if (Nested_Template->Value == Func->Templates[T]->Name)
								Nested_Template->Value = Caller->Templates[T]->Name;
						}
					}
				}
			}

			//Now flatten the Un_initialized_Templates list into Inheritances
			for (auto Return_Type : Func->Un_Initialized_Template_Inheritance) {
				//construct a plain string from the component.
				string Flatten = Return_Type.first.To_String();

				//insert the flatten text into parser that there is a class to reference to.
				Parser p(Scope);
				p.Input = Lexer::GetComponents(Flatten);
				p.Factory();

				Func->Inheritted.insert(Func->Inheritted.begin() + Return_Type.second, Flatten);
			}

			

			//Now flatten the Un_Initialized_Templates from Parameters
			for (auto Parameter : Func->Parameters) {
				for (auto Return_Type : Parameter->Un_Initialized_Template_Inheritance) {
					//construct a plain string from the component.
					string Flatten = Return_Type.first.To_String();

					//insert the flatten text into parser that there is a class to reference to.
					Parser p(Scope);
					p.Input = Lexer::GetComponents(Flatten);
					p.Factory();

					Parameter->Inheritted.insert(Parameter->Inheritted.begin() + Return_Type.second, Flatten);
				}
			}
		}

		//dont worry about pointter amount, we will check them in another function-
		//that is to run after this function.
		if (Func->Get_Inheritted("_", true, false, true) == Caller->Get_Inheritted("_", true, false, true))
			Accuracity++;

		//checks basetype casting in parameters.
		bool All_Parameters_Match = true;
		for (int i = 0; i < Func->Parameters.size(); i++) {
			if (Func->Parameters[i]->Get_Inheritted("_", true, false, true) != Caller->Parameters[i]->Get_Inheritted("_", true, false, true))
				for (int j = 0; j < Func->Parameters[i]->Inheritted.size(); j++)
					if (!Lexer::GetComponent(Func->Parameters[i]->Inheritted[j]).is(Flags::KEYWORD_COMPONENT))
						//banana --> fruit
						if (!Find_Castable_Inheritance(Caller->Parameters[i]->Get_Inheritted(true, false), Func->Parameters[i]->Inheritted[j]))
							//fruit --> banana
							for (int Caller_i = 0; Caller_i < Caller->Parameters[i]->Get_Inheritted(true, false).size(); Caller_i++)
								if (!Lexer::GetComponent(Caller->Parameters[i]->Get_Inheritted(true, false)[Caller_i]).is(Flags::KEYWORD_COMPONENT))
									if (!Find_Castable_Inheritance(Func->Parameters[i]->Get_Inheritted(true, false), Caller->Parameters[i]->Get_Inheritted(true, false)[Caller_i]))
										All_Parameters_Match = false;
		}

		if (All_Parameters_Match)
			Accuracity++;

		//check if the function is already constructed for this caller.
		if (Caller->Templates.size() > 0) {
			string New_Name = Caller->Construct_Template_Type_Name();
			if (New_Name == Func->Name)
				Accuracity++;
		}

		Result[Accuracity].push_back({ {Candidate.first, Func}, Candidate.second });

	}
	return Result;
}

// returns 0 if found caller's function implemitation.
// returns 1 if constructed a new function implemitation based on the template types
// returns -1 if nothing found
// returns 2 if there is more than one suitable functions to call.
int PostProsessor::Choose_Most_Suited_Function_Candidate(map<int, vector<pair<pair<Node*, Node*>, Node*>>> Candidates, Node* Caller, bool Is_Func_Ptr)
{
	//Max accuracity is currently capped out at 3
	int Max_Accuracity = 3;

	Node* Best_Candidate = nullptr;
	Node* Best_Candidate_Copy;
	Node* Scope = Caller->Scope;

	string New_Name = Caller->Construct_Template_Type_Name();

	//	  Candidate, Distance
	vector<pair<pair<pair<Node*, Node*>, Node*>, int>> Candidate_Distance;
	for (int Current_Accuracy = Max_Accuracity; Current_Accuracy >= 0; Current_Accuracy--) {
		for (auto Func : Candidates[Current_Accuracy]) {
			//Check whoose closer if the return type or parameters need to be casted
			int Current_Candidate_Distance = 0;
			//the more casting is made the further the candidate is from the caller
			vector<string> Callers_Return_Types = Caller->Get_Inheritted(true, false, true);
			vector<string> Func_Return_Types = Func.first.second->Get_Inheritted(true, false, true);

			for (int P = 0; P < Func.first.second->Parameters.size(); P++) {
				//calculate the casting distance
				Current_Candidate_Distance += Get_Casting_Distance(Caller->Parameters[P], Func.first.second->Parameters[P]);
				//calculate the ptr distance
				Current_Candidate_Distance += Caller->Parameters[P]->Calculate_Inheritted_Distance(Func.first.second->Parameters[P], "ptr");
			}

			if (Callers_Return_Types.size() == Func_Return_Types.size())
				for (int P = 0; P < Callers_Return_Types.size(); P++)
					Current_Candidate_Distance += Get_Casting_Distance(Scope->Find(Callers_Return_Types[P]), Scope->Find(Func_Return_Types[P]));
			else {
				//if the caller has return type but is not same as the func the distance grows.
				if (Callers_Return_Types.size() > 0)
					Current_Candidate_Distance += Caller->Calculate_Inheritted_Distance(Func.first.second, "ptr");
				//but if the call's return type is empty it means that the context is hard to read.
				//so the distance won be affected.
			}

			//if the function is already defined for this caller the distance should be smaller.
			if (Caller->Templates.size() > 0) {
				if (New_Name == Func.first.first->Name) {
					Current_Candidate_Distance--;
				}
			}

			Candidate_Distance.push_back({ {{Func.first.first, Func.first.second}, Func.second}, Current_Candidate_Distance });
		}
	}

	if (Is_Func_Ptr) {
		for (auto& I : Candidate_Distance) {
			I.first.first.first->Calling_Count++;
		}
		Caller->Function_Ptr = true;
		return 0;
	}

	//now determine the best candidate
	pair<pair<pair<Node*, Node*>, Node*>, int>* Closest = nullptr;
	for (auto& I : Candidate_Distance) {
		if (Closest == nullptr || Closest->second > I.second)
			Closest = &I;
	}

	int Identical_Function_Candidate_Count = 0;
	for (auto& I : Candidate_Distance) {
		if (I.second == Closest->second)
			if (Closest != &I)
				if (Closest->first.first != I.first.first)
					Identical_Function_Candidate_Count++;
	}

	if (Identical_Function_Candidate_Count > 0)
		return 2;

	if (Closest == nullptr) {
		return -1;
	}

	Best_Candidate = Closest->first.first.first;
	Best_Candidate_Copy = Closest->first.first.second;
	Scope = Closest->first.second;

	if (Best_Candidate->Is_Template_Object) {
		//check if the template function is already generated for this caller.
		Best_Candidate_Copy->Name = New_Name;

		Node* Function = Scope->Find(New_Name, Scope, { FUNCTION_NODE, PROTOTYPE, IMPORT, EXPORT });
		if (Function != nullptr && Best_Candidate_Copy->Compare_Fetchers(Function) && (Function->Template_Children[1].Components.size() > 0 && Function->Childs.size() > 0)) {
			
			/*if (Function->Template_Children[1].Components.size() > 0 && Function->Childs.size() == 0) {
				Parser parser(Function);
				parser.Input = Function->Template_Children[1].Components;

				for (auto component : parser.Input) {

				}

				parser.Factory();

				for (auto I : parser.Input)
					if (I.node)
						Function->Childs.push_back(I.node);

				Function->Is_Template_Object = false;

				PostProsessor postprosessor(Function);
				postprosessor.Open_Function_For_Prosessing(Function);
			}*/
			
			Caller->Function_Implementation = Function;
			Caller->Name = New_Name;
			Caller->Templates.clear();
			//Function->Calling_Count++;
			return 0;
		}

		//reset the name to normal
		Best_Candidate_Copy->Name = Best_Candidate->Name;
		Best_Candidate_Copy->Templates = Caller->Templates;

		//here we generate the template function from the template types
		Parser P(Scope);
		P.Input = P.Template_Function_Constructor(Best_Candidate_Copy, Best_Candidate->Templates, Caller->Templates);
		P.Factory();

		for (int i = Scope->Defined.size() - 1; i >= 0; i--) {
			if (Scope->Defined[i]->is(FUNCTION_NODE) && Scope->Defined[i]->Name == New_Name){
				Caller->Function_Implementation = Scope->Defined[i];
				break;
			}
		}

		Caller->Name = New_Name;
		Caller->Templates.clear();

		if (!Caller->Function_Implementation->is(PARSED_BY::POSTPROSESSOR)) {
			if (Caller->Function_Implementation->Fetcher != nullptr || Caller->Function_Implementation->Get_Scope_As(CLASS_NODE, Caller->Function_Implementation) != Global_Scope) {
				Member_Function_Defined_Inside(Caller->Function_Implementation);
				Member_Function_Defined_Outside(Caller->Function_Implementation);
			}
			Open_Function_For_Prosessing(Caller->Function_Implementation);
		}

		return 1;
	}
	else {
		Caller->Function_Implementation = Best_Candidate;
		Caller->Name = Caller->Function_Implementation->Name;
		Caller->Templates.clear();
		return 0;
	}
}

int PostProsessor::Get_Casting_Distance(Node* a, Node* b, bool Layer)
{
	int Result = 0;
	//banana -> fruit
	Node* Current = a;
	Node* Goal = b;

	if (Current->Get_Inheritted("_", true, false, true) == Goal->Get_Inheritted("_", true, false, true))
		return Result + Layer;

	if (!MANGLER::Is_Base_Type(Current))
		for (auto I : Current->Get_Inheritted(true, false, true)) {
			//try to chack if this inheritted is connected to the goal type.
			int Distance = Get_Casting_Distance(Current->Find(I), Goal, true);
			if (Distance > 0)
				Result += Distance;
		}

	if (Result == 0) {
		//fruit -> banana
		if (!MANGLER::Is_Base_Type(Goal))
			for (auto I : Goal->Get_Inheritted(true, false, true)) {
				//try to chack if this inheritted is connected to the goal type.
				int Distance = Get_Casting_Distance(Goal->Find(I), Current, true);
				if (Distance > 0)
					Result += Distance;
			}
	}
	return Result + Layer;
}

bool PostProsessor::Find_Castable_Inheritance(vector<string> types, string target)
{
	for (auto type : types) {
		if (Lexer::GetComponents(type)[0].is(Flags::KEYWORD_COMPONENT))
			continue;
		if (type == target)
			return true;
		if (!MANGLER::Is_Base_Type(Scope->Find(type, Scope, CLASS_NODE)))
			if (Find_Castable_Inheritance(Scope->Find(type, Scope, CLASS_NODE)->Get_Inheritted(true), target))
				return true;
	}
	return false;
}

void PostProsessor::Open_Call_Parameters_For_Prosessing(int i)
{
	if (!Input[i]->is(CALL_NODE))
		return;

	vector<Node*> Own_Defined = Input[i]->Defined;

	//give the post prosessor a way to reach the parameters that might have member fetching/ math
	PostProsessor p(Scope, Input[i]->Parameters);

	Input[i]->Parameters = p.Input;

	Algebra_Laucher(Input[i], Input[i]->Parameters);

	//see what outside defined has been injected to this call.
	for (int j = 0; j < Input[i]->Defined.size(); j++) {
		bool Is_Own_Defined = false;
		for (auto k : Own_Defined) {
			if (Input[i]->Defined[j] == k) {
				Is_Own_Defined = true;
			}
		}
		if (!Is_Own_Defined) {
			Input[i]->Scope->Defined.push_back(Input[i]->Defined[j]);
			Input[i]->Defined[j]->Scope = Input[i]->Scope;
			Input[i]->Defined.erase(Input[i]->Defined.begin() + j);
		}
	}

	//for (auto& v : Input[i]->Defined)
	//	p.Destructor_Caller(v, Input);

	Scope->Append(Output, p.Output);

	for (auto j : Input[i]->Parameters) {
		if (j->Header.size() > 0) {
			Input[i]->Header.insert(Input[i]->Header.end(), j->Header.begin(), j->Header.end());
			j->Header.clear();
		}
	}

	if (Input[i]->Context == nullptr || !Input[i]->Context->Has({ CALL_NODE, OPERATOR_NODE, ASSIGN_OPERATOR_NODE, CONDITION_OPERATOR_NODE, BIT_OPERATOR_NODE, LOGICAL_OPERATOR_NODE, ARRAY_NODE, FLOW_NODE })) {
		Node* Header_Giver = Input[i];
		
		Input.insert(Input.begin() + i, Input[i]->Header.begin(), Input[i]->Header.end());
		
		Header_Giver->Header.clear();
	}
	else if (Input[i]->Context) {
		Node* Header_Giver = Input[i];

		Input[i]->Context->Header.insert(Input[i]->Context->Header.end(), Input[i]->Header.begin(), Input[i]->Header.end());

		Header_Giver->Header.clear();
	}
	//use optimization into the parameters.
	//Algebra a(Input[i], &Input[i]->Parameters);	//Algebra has already optimized this!

	for (auto j : Input[i]->Parameters)
		if (j->is(OPERATOR_NODE)) {
			Update_Operator_Inheritance(j);
			j->Update_Size();
		}
}

void PostProsessor::Algebra_Laucher(Node* Scope, vector<Node*> &List)
{
	while (true) {
		Algebra a(Scope, &List);
		if (!Optimized)
			break;
		Optimized = false;
	}
}

void PostProsessor::Combine_Member_Fetching(Node*& n)
{
	if (n->Name != ".")
		return;

	Cast(n->Left);
	Cast(n->Right);
	Combine_Member_Fetching(n->Left);

	//this is for the manual writation usage of this.X
	for (auto* i : n->Get_all()) {
		if (i->is(CALL_NODE))
			continue;

		if (i->Has({ OBJECT_DEFINTION_NODE, OBJECT_NODE, PARAMETER_NODE })) {
			Node* Definition = nullptr;

			for (auto j : { OBJECT_DEFINTION_NODE, OBJECT_NODE, PARAMETER_NODE }) {
				Definition = i->Find(i, i, j);

				//if the current flag isin't it then try another one
				if (Definition)
					break;
			}

			//if all flags dont match, then break process
			if (Definition == nullptr)
				continue;	//this can occur if the definition points to the rght side of the dot

			if (Definition->Is_Template_Object)
				continue;

			i->Inheritted = Definition->Inheritted;
			i->Defined = Definition->Defined;
		}
	}

	if (n->Right->is(CALL_NODE)) {
		n->Right->Parameters.insert(n->Right->Parameters.begin(), n->Left);
		n->Right->Context = n->Context;
		n->Right->Fetcher = n->Left;
		n = n->Copy_Node(n->Right, n->Scope);
	}
	else {
		//Remember: Dot is constructed as any normal operator.
		//((((a.b).c[..]).d()).e) = 123
		//We have to go first to the most left sided operator.
		/*Cast(n->Left);
		Cast(n->Right);
		Combine_Member_Fetching(n->Left);*/
		//set the left side
		Node* Left = Scope->Find(Get_From_AST(n->Left), Scope);
		//we must also update the current left side to inherit the members from the inherit list

		//get the left side of the dot operator, this is getted from most left because it can be also an AST.
		Node* Right = n->Get_Most_Left(n->Right);

		if (Right->Name == "size") {
			Node* num = Right->Find("size", Left);
			if (num == nullptr || (num->is("const") != -1)) {
				//this means it is definetly a size get request
				Right->Name = to_string(Left->Get_Size());
				Right->Type = NUMBER_NODE;	
				if (atoll(Right->Name.c_str()) > INT32_MAX)
					Right->Size = 8;
				else
					Right->Size = 4;
			}
			else
				//load the needed information from the parent
				Right = n->Copy_Node(n->Find(Right, Left), Scope);
		}
		else
			//load the needed information from the parent
			Right = n->Copy_Node(n->Find(Right, Left), Scope);

		//set the parent as a fechable
		Right->Fetcher = Left;

		//now remove the current dot operator and replace it with the new fetched member
		Right->Context = n->Context;
		Right->Scope = n->Scope;

		//a.Array[1]
		//put the a.Array as the left side of the array operator
		if (n->Right->is(ARRAY_NODE)) {
			//first move to the right nodes
			//and then make copy_node to re-adjust the memebr variable touchings
			n->Right->Left = Right->Copy_Node(Right, Right->Scope);

			n = n->Copy_Node(n->Right, n->Scope);
		}
		else
			n = Right->Copy_Node(Right, Right->Scope);
	}
}

Node* PostProsessor::Get_From_AST(Node* n)
{
	//((((a.b).c[..]).d()).e) = 123
	if (n->is(CONTENT_NODE)) {
		//childs can have only one start node for the AST because that is how math just works :/
		//(a.b + a.c) 
		//				n is parent because of the local scope
		PostProsessor p(n, n->Childs);

		n->Childs = p.Input;

		return Get_From_AST(n->Childs[0]);
	}
	else if (n->is(OPERATOR_NODE)) {
		vector<Node**> Change = { &n };
		PostProsessor p(Scope, Change);

		if (Change.size() > 1)
			Report(Observation(ERROR, "Un handled situation!", *n->Location));

		return Get_From_AST(n);	//this call the same funciton again because the structure of the AST might have been changed.
	}
	else if (n->is(ARRAY_NODE)) {

		vector<Node**> Change = { &n };

		PostProsessor p(Scope, Change);

		if (Change.size() > 1)
			Report(Observation(ERROR, "Un handled situation!", *n->Location));

		return n->Get_Most_Left();
	}
	else if (n->is(CALL_NODE)) {
		PostProsessor p(Scope, n->Parameters);

		n->Parameters = p.Input;

		Find_Call_Owner(n);
		return n;
	}
	else  {
		return n;
	}
}

//this is not called upon type initializations because this is called on function memebers
//so that unused classe's members size wont need to be calculated.
void PostProsessor::Define_Sizes(Node* p)
{
	//here we set the defined size of the variable
	for (Node* d : p->Defined) {
		d->Get_Inheritted_Class_Members();
		d->Update_Size();
		d->Update_Format();
	}

	p->Update_Local_Variable_Mem_Offsets();
	p->Update_Member_Variable_Offsets(p);

}

void PostProsessor::Combine_Condition(int i)
{
	if (!Input[i]->is(IF_NODE))
		return;

	Node* current_condition = Input[i];
	int j;
	//loop through the next nodes if theyre else ifs
	for (j = i + 1; j < Input.size(); j++) {
		if (Input[j]->is(ELSE_IF_NODE) || Input[j]->is(ELSE_NODE)) {
			//give the else if the parent as the if
			Input[j]->Predecessor = current_condition;
			//give the if the child as successor else if
			current_condition->Succsessor = Input[j];
			//give the successor as the current pointter
			current_condition = Input[j];
		}
		else {
			break;
		}
	}

	//now remove the elses
	Input.erase(Input.begin() + i + 1, Input.begin() + j);
}

void PostProsessor::Determine_Return_Type(int i)
{
	if (!Input[i]->Has({ ASSIGN_OPERATOR_NODE, OPERATOR_NODE, BIT_OPERATOR_NODE, CONDITION_OPERATOR_NODE, LOGICAL_OPERATOR_NODE, PREFIX_NODE, POSTFIX_NODE }))
		return;

	if (Input[i]->is(PREFIX_NODE)) {
		PostProsessor r(Scope, vector<Node**>{ &Input[i]->Right});
	}
	else if (Input[i]->is(POSTFIX_NODE)) {
		PostProsessor r(Scope, vector<Node**>{ &Input[i]->Left});
	}
	else if (Input[i]->Right->is(CALL_NODE) && MANGLER::Is_Based_On_Base_Type(Input[i]->Right)) {
		PostProsessor l(Scope, vector<Node**>{ &Input[i]->Left });
		Input[i]->Right->Inheritted = Input[i]->Left->Inheritted;
		PostProsessor r(Scope, vector<Node**>{ &Input[i]->Right});
	}
	else if (Input[i]->Left->is(CALL_NODE) && MANGLER::Is_Based_On_Base_Type(Input[i]->Left)) {
		PostProsessor r(Scope, vector<Node**>{ &Input[i]->Right});
		Input[i]->Left->Inheritted = Input[i]->Right->Inheritted;
		PostProsessor l(Scope, vector<Node**>{ &Input[i]->Left });
	}
	else {
		PostProsessor r(Scope, vector<Node**>{ &Input[i]->Right, &Input[i]->Left });
	}

	vector<Node*> Tmp;

	if (!Input[i]->is(PREFIX_NODE))
		Tmp.push_back(Input[i]->Left);
	if (!Input[i]->is(POSTFIX_NODE))
		Tmp.push_back(Input[i]->Right);

	Algebra_Laucher(Input[i], Tmp);

	if (!Input[i]->Has({ PREFIX_NODE, POSTFIX_NODE })) {
		//try to find a suitable operator overload if there is one
		for (auto& overload : Input[i]->Left->Operator_Overloads) {
			//the syntax still needs to be done!

			//the operator overloads return type is the same as the operator type for this.
			Input[i]->Inheritted = overload->Inheritted;
			return;
		}

		if (Input[i]->Left->is(NUMBER_NODE)) {
			//Some operators cannot be swapped, like - and /
			if (Input[i]->Name == "+" || Input[i]->Name == "*" || Input[i]->Name == "==" || Input[i]->Name == "!=") {
				//these can be switched whitout any consequenses.
				Node* tmp = Input[i]->Left;
				Input[i]->Left = Input[i]->Right;
				Input[i]->Right = tmp;
			}
			else {
				//make a tmp variable and set the number constant into it
				string Constant_Name = Input[i]->Left->Name + "_TMP";

				Node* Constant_Tmp;

				if (Input[i]->Find(Constant_Name)) {
					Constant_Tmp = Input[i]->Find(Constant_Name);
				}
				else {
					Constant_Tmp = new Node(OBJECT_DEFINTION_NODE, Input[i]->Left->Location);
					Constant_Tmp->Name = Constant_Name;
					Constant_Tmp->Scope = Input[i]->Scope;

					Scope->Defined.push_back(Constant_Tmp);
				}

				//move the constant here.
				Node* Move = new Node(ASSIGN_OPERATOR_NODE, new Position());
				Move->Name = "=";
				Move->Scope = Input[i]->Scope;

				Move->Left = new Node(*Constant_Tmp);
				Move->Left->Context = Move;

				Move->Right = new Node(*Input[i]->Left);
				Move->Right->Context = Move;

				Input[i]->Header.insert(Input[i]->Header.begin(), Move);
				*Input[i]->Left = *Constant_Tmp;
			}
		}
	}

	int Left_Size = 0;
	int Right_Size = 0;

	if (!Input[i]->is(PREFIX_NODE)) {
		for (auto j : Input[i]->Left->Get_Inheritted(false, false)) {
			if (Lexer::GetComponents(j)[0].is(Flags::KEYWORD_COMPONENT))
				continue;
			Left_Size += Scope->Find(j, Scope)->Get_Size();
		}
		if (Input[i]->Left->Cast_Type != nullptr && Input[i]->Left->Cast_Type->Name != "address")
			Left_Size = Scope->Find(Input[i]->Left->Cast_Type, Scope)->Get_Size();
		if (Input[i]->Left->is("ptr") != -1)
			Left_Size = _SYSTEM_BIT_SIZE_;
	}

	if (!Input[i]->is(POSTFIX_NODE)) {
		for (auto j : Input[i]->Right->Get_Inheritted(false, false)) {
			if (Lexer::GetComponents(j)[0].is(Flags::KEYWORD_COMPONENT))
				continue;
			Right_Size += Scope->Find(j, Scope)->Get_Size();
		}
		if (Input[i]->Right->Cast_Type != nullptr && Input[i]->Right->Cast_Type->Name != "address")
			Right_Size = Scope->Find(Input[i]->Right->Cast_Type, Scope)->Get_Size();
		if (Input[i]->Right->is("ptr") != -1)
			Right_Size = _SYSTEM_BIT_SIZE_;
	}


	if (Left_Size >= Right_Size)
		Input[i]->Inheritted = Input[i]->Left->Get_Inheritted(false, false);
	else
		Input[i]->Inheritted = Input[i]->Right->Get_Inheritted(false, false);

	if (!Input[i]->is(PREFIX_NODE)) {
		if (Input[i]->Left->Function_Address_Giver)
			Input[i]->Left->Size = Left_Size;
		if (Input[i]->Left->Header.size() > 0) {
			Node* Header_Giver = Input[i]->Left;

			if (Input[i]->Context == nullptr)
				Input.insert(Input.begin() + i, Input[i]->Left->Header.begin(), Input[i]->Left->Header.end());
			else
				Input[i]->Context->Header.insert(Input[i]->Context->Header.end(), Input[i]->Left->Header.begin(), Input[i]->Left->Header.end());

			Header_Giver->Header.clear();
		}
	}
	if (!Input[i]->is(POSTFIX_NODE)) {
		if (Input[i]->Right->Header.size() > 0) {
			Node* Header_Giver = Input[i]->Right;

			if (Input[i]->Context == nullptr)
				Input.insert(Input.begin() + i, Input[i]->Right->Header.begin(), Input[i]->Right->Header.end());
			else
				Input[i]->Context->Header.insert(Input[i]->Context->Header.end(), Input[i]->Right->Header.begin(), Input[i]->Right->Header.end());

			Header_Giver->Header.clear();
		}
		if (Input[i]->Right->Function_Address_Giver)
			Input[i]->Right->Size = Right_Size;
	}

	if ((Input[i]->Header.size() > 0) && (Input[i]->Context == nullptr)) {
		Node* Header_Giver = Input[i];

		Input.insert(Input.begin() + i, Input[i]->Header.begin(), Input[i]->Header.end());

		Header_Giver->Header.clear();
	}
}

void PostProsessor::Determine_Array_Type(int i)
{
	if (!Input[i]->is(ARRAY_NODE))
		return;

	PostProsessor r(Scope, vector<Node**>{ &Input[i]->Right, &Input[i]->Left });

	//Who is gay and does not pay taxes also farts in public 
	for (auto& overload : Input[i]->Left->Operator_Overloads) {
		//the syntax still needs to be done!

		//the operator overloads return type is the same as the operator type for this.
		Input[i]->Inheritted = overload->Inheritted;
		return;
	}

	//give the type inheritance to this array operator so that the upper function can check the do-ability
	Input[i]->Inheritted = Input[i]->Left->Inheritted;
}

void PostProsessor::Open_PreFix_Operator(int i)
{
	if (!Input[i]->is(PREFIX_NODE))
		return;

	PostProsessor p(Scope, vector<Node**>{ &Input[i]->Right });
}

void PostProsessor::Open_PostFix_Operator(int i)
{
	if (!Input[i]->is(POSTFIX_NODE))
		return;


	PostProsessor p(Scope, vector<Node**>{ &Input[i]->Left });
}

void PostProsessor::Type_Size_Definer(int i)
{
	if (Scope->Defined[i]->Type != CLASS_NODE)
		return;
	if (Scope->Defined[i]->Templates.size() > 0)	//template types are constructed elsewhere.
		return;
	//update members sizes
	Scope->Defined[i]->Update_Size();

	//update the member stack offsets
	Scope->Defined[i]->Update_Local_Variable_Mem_Offsets();

	//update format
	Scope->Defined[i]->Update_Format();

	//update all member formats as well
	for (auto& i : Scope->Defined[i]->Defined)
		i->Update_Format();
}

void PostProsessor::Handle_Imports(int i)
{
	if (!Scope->Defined[i]->is(IMPORT))
		return;
	//import func new (4, ABC)
	//all numbers need to be redefined by type size.
	//and all other text is already classes.
	//pointters are inside the parameter as inheritance.
	bool Parse_Returning_Numerical_Types = false;
	vector<Node*> Numerical_Types = Scope->Defined[i]->Parameters;
Again:;
	for (int j = 0; j < Numerical_Types.size(); j++) {
		vector<string> Inheritted = Numerical_Types[j]->Inheritted;
		if (Numerical_Types[j]->is(NUMBER_NODE)) {
			*Numerical_Types[j] = *Global_Scope->Find(atoi(Numerical_Types[j]->Name.c_str()), Global_Scope, CLASS_NODE, Numerical_Types[j]->Format);
			Numerical_Types[j]->Inheritted.insert(Numerical_Types[j]->Inheritted.end(), Inheritted.begin(), Inheritted.end());
		}
		else if (!MANGLER::Is_Base_Type(Numerical_Types[j]))
			continue;
		else if (Numerical_Types[j]->is(OBJECT_DEFINTION_NODE)) {
			if ((Numerical_Types[j]->Name == "type") || Numerical_Types[j]->is("type") != -1)
				continue;
			*Numerical_Types[j] = *Global_Scope->Find(Numerical_Types[j]->Name, Global_Scope, CLASS_NODE);
			Numerical_Types[j]->Inheritted.insert(Numerical_Types[j]->Inheritted.end(), Inheritted.begin(), Inheritted.end());
		}
	}
	if (Parse_Returning_Numerical_Types == false && Scope->Defined[i]->Numerical_Return_Types.size() > 0) {
		Parse_Returning_Numerical_Types = true;
		Numerical_Types = Scope->Defined[i]->Numerical_Return_Types;
		goto Again;
	}
	else if (Parse_Returning_Numerical_Types) {
		for (auto j : Numerical_Types) {
			Scope->Defined[i]->Inheritted.push_back(j->Name);
		}
		Scope->Defined[i]->Numerical_Return_Types.clear();
	}
	//TODO: Re-order all return types and parameter types into a logical order.
	//now all types are good to go.
	//although function calling might get tricky with just types as the parameters.
}

void PostProsessor::Open_Loop_For_Prosessing(int i)
{
	if (!Input[i]->is(WHILE_NODE))
		return;

	//while (a + 1 < a * 2){..}
	//while (int i = 0, a + i < a * i*2, i++){..}
	//we dont necessarily need to seperate the condition operator.
	Algebra Alg(Input[i], &Input[i]->Parameters);

	//now just prosess the child tokens of while node as well.
	PostProsessor post(Input[i]);
	post.Input = Input[i]->Childs;

	Algebra_Laucher(Input[i], Input[i]->Childs);

	//NOTE: this defined sizes might be reduntant!
	post.Define_Sizes(Input[i]);

	Process_Function_Pointters(Input[i]);

	//haha brain go brr
	post.Factory();

	Input[i]->Childs = post.Input;

	for (auto& v : Input[i]->Defined)
		post.Destructor_Caller(v, Input[i]->Childs);

	Scope->Append(Input[i]->Childs, post.Output);
}

void PostProsessor::Update_Used_Object_Info(Node* n)
{
	if (!n->is(FUNCTION_NODE))
		return;
	for (auto i : n->Get_all(OBJECT_NODE)) {
		i->Inheritted = n->Find(i->Name, i->Scope)->Inheritted;
		i->Update_Size();
	}
	//do the same for parameters
	for (auto i : n->Get_all(PARAMETER_NODE)) {
		i->Inheritted = n->Find(i->Name, i->Scope)->Inheritted;
		i->Update_Size();
	}
}

void PostProsessor::Operator_Overload(int i)
{
	//todo: make the override syntax
}

void PostProsessor::Analyze_Variable_Address_Pointing(Node* v, Node* n)
{
	if (!v->Has({ OBJECT_DEFINTION_NODE, OBJECT_NODE, PARAMETER_NODE }))
		return;

	//if a variable is pointed to via a pointter or a function parameter address loader, use stack.
	//Other than that use registers.
	if (n->Has({ASSIGN_OPERATOR_NODE, OPERATOR_NODE, CONDITION_OPERATOR_NODE, BIT_OPERATOR_NODE, LOGICAL_OPERATOR_NODE})) {
		Analyze_Variable_Address_Pointing(v, n->Left);
		if (v->Requires_Address)
			return;
		Analyze_Variable_Address_Pointing(v, n->Right);
		if (v->Requires_Address)
			return;

		int Right_ptr = Get_Amount("ptr", n->Right);
		int Left_ptr = Get_Amount("ptr", n->Left);
		//TODO!! need better contex idea for what is the result be as ptr amount?!!
		if (Right_ptr > Left_ptr && n->Left->Name == v->Name) {
			v->Requires_Address = true;
		}
		if (Left_ptr > Right_ptr && n->Right->Name == v->Name) {
			v->Requires_Address = true;
		}
	}
	else if (n->is(CONTENT_NODE))
		for (auto i : n->Childs) {
			Analyze_Variable_Address_Pointing(v, i);
			if (v->Requires_Address)
				return;
		}
	else if (n->is(CALL_NODE)) {
		vector<int> v_index;
		for (int i = 0; i < n->Parameters.size(); i++)
			for (auto j : n->Parameters[i]->Get_all({ OBJECT_NODE, PARAMETER_NODE, OBJECT_DEFINTION_NODE }))
				if (j->Name == v->Name)
					v_index.push_back(i);
		for (auto i : v_index) {
			int Template_ptr = Get_Amount("ptr", n->Function_Implementation->Parameters[i]);
			int V_ptr = Get_Amount("ptr", v);
			if (Template_ptr > V_ptr)
				v->Requires_Address = true;
		}
	}
	else if (n->Name == "return" && n->Right != nullptr) {
		Analyze_Variable_Address_Pointing(v, n->Right);
		if (v->Requires_Address)
			return;

		//check if the return returs this v node
		for (auto i : n->Get_all({ OBJECT_DEFINTION_NODE, OBJECT_NODE, PARAMETER_NODE })) {
			if (i->Name == v->Name)
				if (i->Context == n) {
					Node* func = n->Get_Scope_As(FUNCTION_NODE, n);
					int Func_ptr = Get_Amount("ptr", func);
					int V_ptr = Get_Amount("ptr", i);
					if (Func_ptr > V_ptr)
						v->Requires_Address = true;
				}
		}

	}
	
	
	if (v->is(PARAMETER_NODE) && sys->Info.Debug)
		v->Requires_Address = true;

	/*if (v->Requires_Address) {
		v->Memory_Offset = v->Scope->Local_Allocation_Space;
		v->Scope->Local_Allocation_Space += v->Get_Size();
	}*/
}

int PostProsessor::Get_Amount(string t, Node* n)
{
	int result = 0;
	for (string s : n->Inheritted)
		if (s == t)
			result++;

	if (n->Cast_Type != nullptr && n->Cast_Type->Name != "address")
		for (auto i : n->Find(n->Cast_Type, n)->Inheritted)
			if (i == t)
				result++;

	return result;
}

void PostProsessor::Analyze_Global_Variable_Changes(int i)
{
	if (!Input[i]->is(ASSIGN_OPERATOR_NODE))
		return;

	//check if the parent is global scope.
	if (Input[i]->Left->Scope->Name != "GLOBAL_SCOPE")
		return;

	Node* og = Scope->Find(Input[i]->Left->Name);

	if (Scope->Name == "GLOBAL_SCOPE") {
		//We are in global scope area.
		if (!Input[i]->Right->Get_Most_Left()->is(NUMBER_NODE) && !Input[i]->Right->Get_Most_Left()->is(STRING_NODE)) {
			Node* Right = Scope->Find(Input[i]->Right->Get_Most_Left()->Name);
			if (Right->is("const") == -1)
				if (og->is("const") != -1) {
					og->Inheritted.erase(og->Inheritted.begin() + og->is("const"));
				}
		}
	}
	else {
		//we are in a fucntion of some sort.
		//if this is the case the global variable cannot be a constant anymore.
		if (og->is("const") != -1) {
			og->Inheritted.erase(og->Inheritted.begin() + og->is("const"));
		}
	}
}

void PostProsessor::Change_Local_Strings_To_Global_Pointters(int i)
{
	if (!Input[i]->is(STRING_NODE))
		return;
	if (Scope->Name == "GLOBAL_SCOPE")
		return;
	//a = "123" to a = S0
	int Current_S_Count = 0;
	for (auto c : Global_Scope->Defined) {
		if (!c->is(LABEL_NODE))
			continue;
		Current_S_Count++;
		if (c->String == Input[i]->Name) {
			*Input[i] = *c;
			if (Input[i]->is("ptr") == -1)
				Input[i]->Inheritted.push_back("ptr");
			return;
		}
	}
	//if there is no string Sx make a new one.
	Node* s = new Node(LABEL_NODE, Input[i]->Location);
	s->String = Input[i]->Name;
	s->Name = "S" + to_string(Current_S_Count);
	s->Inheritted = { Global_Scope->Find(1, Global_Scope, CLASS_NODE, "integer")->Name };
	if (s->is("ptr") == -1)
		s->Inheritted.push_back("ptr");
	s->Scope = Global_Scope;

	Node* init = new Node(ASSIGN_OPERATOR_NODE, Input[i]->Location);
	init->Name = "=";
	init->Scope = Global_Scope;

	Node* value = new Node(STRING_NODE, Input[i]->Location);
	value->Name = s->String;
	value->Scope = Global_Scope;
	value->Size = 1;	//byte

	init->Left = s;
	init->Right = value;

	Global_Scope->Header.push_back(init);
	Global_Scope->Defined.push_back(s);

	Change_Local_Strings_To_Global_Pointters(i);
}

void PostProsessor::Move_Global_Varibles_To_Header(int i)
{
	if (!Input[i]->is(ASSIGN_OPERATOR_NODE))
		return;
	if (Scope->Name != "GLOBAL_SCOPE" && Scope->is("static") == -1)
		return;

	Node* Globl_Var = Scope->Find(Input[i]->Left->Name);
	Globl_Var->Type = OBJECT_NODE;

	Globl_Var->Update_Size();

	Scope->Header.push_back(Input[i]);

	Input.erase(Input.begin() + i);

	Move_Global_Varibles_To_Header(i);
}

bool PostProsessor::Check_If_Template_Function_Is_Right_One(Node* t, Node* c)
{
	//t = template
	//c = call
	int Type_Amount = 0;
	if (t->Templates.size() > 0) {
		for (auto T : t->Templates)
			for (auto i : t->Inheritted)
				if (i == T->Name)
					Type_Amount++;
	}
	else {
		//how many times we can skip a type
		int Type_Amount = Get_Amount("type", t);

	}

	if (c->is("type") != -1) {
		//this means this funciton call is in template usage or this is a void calling convension.
		return true;
	}

	for (auto i : c->Inheritted) {
		if (Lexer::GetComponents(i)[0].is(Flags::KEYWORD_COMPONENT)) {
			if (t->is(i) == -1) {
				return false;	//teplate function must contain same keywords.
			}
		}
		else if (t->is(i) == -1) {
			if (Type_Amount > 0) {
				Type_Amount--;
				continue;
			}
			else
				return false;
		}
	}
	return true;
}

void PostProsessor::Open_Safe(vector<Node*> n)
{
	Safe s(n);
}

void PostProsessor::Update_Operator_Inheritance(Node* n)
{
	if (n->is(CONTENT_NODE))
		Update_Operator_Inheritance(n->Childs[0]);
	if (!n->is(ASSIGN_OPERATOR_NODE) && !n->is(CONDITION_OPERATOR_NODE) && !n->is(OPERATOR_NODE) && !n->is(BIT_OPERATOR_NODE) && !n->is(ARRAY_NODE))
		return;

	Update_Operator_Inheritance(n->Left);
	Update_Operator_Inheritance(n->Right);

	//check for operator overrides.
	n->Inheritted.clear();

	if (n->is(ARRAY_NODE)) {
		int Pointter_UnWrapping_Count = 1;	//default
		if (n->Right->Childs.size() > 1)
			Pointter_UnWrapping_Count = (int)n->Right->Childs.size();

		for (auto i : n->Find(n->Left, n->Scope)->Inheritted) {
			if (i == "ptr") {
				if (Pointter_UnWrapping_Count < 1) {
					n->Inheritted.push_back(i);
					continue;
				}
				else
					Pointter_UnWrapping_Count--;
			}
			else
				n->Inheritted.push_back(i);
		}
	}
	else {
		if (n->Left->Has({OPERATOR_NODE, CONDITION_OPERATOR_NODE, BIT_OPERATOR_NODE, ARRAY_NODE, LOGICAL_OPERATOR_NODE, PREFIX_NODE, POSTFIX_NODE}))
			n->Inheritted = n->Left->Inheritted;
		else if (!n->Left->is(NUMBER_NODE) && !n->Left->is(CONTENT_NODE))
			n->Inheritted = n->Left->Scope->Find(n->Left, n->Left->Scope)->Inheritted;
		else if (n->Left->is(NUMBER_NODE))
			n->Inheritted = n->Left->Get_Inheritted(false, false);
		else {
			if (n->Right->Has({ OPERATOR_NODE, CONDITION_OPERATOR_NODE, BIT_OPERATOR_NODE, ARRAY_NODE, LOGICAL_OPERATOR_NODE, PREFIX_NODE, POSTFIX_NODE }))
				n->Inheritted = n->Right->Inheritted;
			else
				//both cannot be numbers, because otherwise algebra would have optimized it away.
				n->Inheritted = n->Right->Scope->Find(n->Right, n->Right->Scope)->Inheritted;
		}
	}
}

void PostProsessor::Update_Inheritance(Node* n)
{
	if (n->Context->Name == "return") {
		n->Inheritted = n->Get_Scope_As(FUNCTION_NODE, n)->Inheritted;
	}
	else {
		Update_Operator_Inheritance(n->Context);
		n->Inheritted = n->Context->Inheritted;
	}
}

void PostProsessor::Analyze_Return_Value(Node* n)
{
	if (n->Name != "return")
		return;
	if (n->Right == nullptr)
		return;

	PostProsessor p(n, vector<Node**>{ &n->Right });

	for (auto& v : n->Right->Defined)
		p.Destructor_Caller(v, Input);
		
	Scope->Append(Output, p.Output);

	Update_Operator_Inheritance(n->Right);
}
C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Cpp\PreProsessor\PreProsessor.cpp" 
#include "../../H/PreProsessor/PreProsessor.h"
#include "../../H/UI/Safe.h"

extern Usr* sys;
extern string* FileName;

void PreProsessor::Factory() {
	Replace_Const_Name_With_Value(Input);
	for (int i = 0; i < Input.size(); i++) {
		If(i);
		Include(i);
		Detect_Directory_Usage_End(i);
		Detect_String_Macros(i);
	}

	//Re_Arrnage_Components();
	return;
}

void PreProsessor::Include(int i)
{
	//use "file.x"
	//<summary>
	//Give it to Docker. it can handle many files
	//</summary>
	if (Input[i].Value != "use")
		return;
	if (!Input[(size_t)i+1].is(Flags::STRING_COMPONENT))
		return;

	string File_Name = Input[(size_t)i + 1].Value.substr(1, Input[(size_t)i + 1].Value.size() - 2);

	Docker D(File_Name);

	Input.erase(Input.begin() + i + 1);
	Input.erase(Input.begin() + i);

	for (auto j : DOCKER::Output) {
		Syntax_Correcter(j.second, j.first, i);
	}
	DOCKER::Output.clear();

	DOCKER::Append(sys->Info.Libs, DOCKER::Libs);
	DOCKER::Append(sys->Info.Source_Files, DOCKER::Assembly_Source_File);
	DOCKER::Libs.clear();
	DOCKER::Assembly_Source_File.clear();

	Factory();
	return;
}

void PreProsessor::Include(string File_Name) {
	Docker D(File_Name);

	for (auto j : DOCKER::Output) {
		Syntax_Correcter(j.second, j.first, 0);
	}
	DOCKER::Output.clear();

	DOCKER::Append(sys->Info.Libs, DOCKER::Libs);
	DOCKER::Append(sys->Info.Source_Files, DOCKER::Assembly_Source_File);
	return;
}

void PreProsessor::Syntax_Correcter(vector<string> symbols, string filename, int i)
{
	//import loyal func [name]()()
	//import generic func [name]()()
	vector<Component> content;
	//FileName = new string(DOCKER::Working_Dir.back().second + filename);
	FileName = new string(DOCKER::Included_Files.back());
	vector<Component> tmp;
	if (filename == DOCKER::Get_File_Extension(filename)) {
		//if the filenmae doesnt have a file extension this happends.
	}
	else if (DOCKER::Get_File_Extension(filename) != "e") {
		for (auto j : symbols)
			if (j != "\n" && j != "")
				DOCKER::Append(tmp, Lexer::GetComponents( "import " + MANGLER::Un_Mangle(j) + "\n"));
	}
	else {
		for (auto j : symbols)
			if (j != "\n" && j != "")
				DOCKER::Append(tmp, Lexer::GetComponents(j));
	}
	DOCKER::Append(tmp, { Component(string(*FileName), Flags::END_OF_DIRECTIVE_CHANGING_FILE) });
	DOCKER::Append(Input, tmp, i);
}

void PreProsessor::Detect_Directory_Usage_End(int i)
{
	if (!Input[i].is(Flags::END_OF_DIRECTIVE_CHANGING_FILE))
		return;
	for (auto j : DOCKER::Working_Dir) {
		if (j.first == Input[i].Value)
			DOCKER::Working_Dir.pop_back();
	}
}

void PreProsessor::Detect_String_Macros(int i)
{
	if (!Input[i].is(Flags::STRING_COMPONENT))
		return;
	if (Input[i].is(Flags::PROCESSED_STRING))
		return;

	//loop through all the characters
	//'\n' == 10
	//		  start, end
	vector<pair<int, int>> Prosessed_Indecies;

	for (int i = 0; i < Input[i].Value.size(); i++) {
		for (auto j : Prosessed_Indecies)
			// i == [start, end]
			if (i <= j.first && i >= j.second)
				goto Skip;

		// \n
		if (i + 1 < Input[i].Value.size() && Input[i].Value[i] == '\\' && Input[i].Value[i + 1] == 'n') {
			Input[i].Value.erase(Input[i].Value.begin() + i);
			Input[i].Value[i] = 10;

			//add the edited area to the Prosessed indecees.
			Prosessed_Indecies.push_back({ i, i });
		}
		// \\ 
		else if (i + 1 < Input[i].Value.size() && Input[i].Value[i] == '\\' && Input[i].Value[i + 1] == '\\') {
			Input[i].Value.erase(Input[i].Value.begin() + i);

			//add the edited area to the Prosessed indecees.
			Prosessed_Indecies.push_back({ i, i });
		}
		// \t
		else if (i + 1 < Input[i].Value.size() && Input[i].Value[i] == '\\' && Input[i].Value[i + 1] == 't') {
			Input[i].Value.erase(Input[i].Value.begin() + i);
			Input[i].Value[i] = 9;

			//add the edited area to the Prosessed indecees.
			Prosessed_Indecies.push_back({ i, i });
		}
		//	\x123
		else if (i + 1 < Input[i].Value.size() && Input[i].Value[i] == '\\' && Input[i].Value[i + 1] == 'x') {
			string Raw = "";

			char Hex[16] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'A', 'B', 'C', 'D', 'E', 'F'};
			
			//calculate the number lenght
			for (int j = i+2; j < Input[i].Value.size(); j++) {
				if ((Input[i].Value[j] >= 48 && Input[i].Value[j] <= 57) || (Input[i].Value[j] >= 65 && Input[i].Value[j] <= 70)) {
					 Raw += Input[i].Value[j];
				}
				else if (Input[i].Value[j] >= 97 && Input[i].Value[j] <= 102) {
					Report(Observation(ERROR, "Non upper case letter at index '" + to_string(j) + "'.", Input[i].Location));
				}
				else if (j == i) {
					//it is the start of the index right after the x character but there is no number
					// \xSXy
					Report(Observation(ERROR, "Incorrect Hexdecimal usage at index '" + to_string(j) + "'.", Input[i].Location));
				}
				else {
					break;
				}
			}

			char Value = 0;

			for (auto Char : Raw) {
				for (int j = 0; j < 16; j++) {
					if (Char == Hex[j]) {
						Value = Value * 16 + j;
					}
				}
			}
			//											\x     ,					    \x
			Input[i].Value.erase(Input[i].Value.begin() + i + 1, Input[i].Value.begin() + i + 1 + Raw.size() - 1);

			Input[i].Value[i] = Value;

			//add the edited area to the Prosessed indecees.
			Prosessed_Indecies.push_back({ i, i });
		}
	Skip:;
	}

	Input[i].Flags |= Flags::PROCESSED_STRING;
}

vector<Component*> PreProsessor::Linearise(vector<Component>& Tree)
{
	vector<Component*> Result;

	for (auto& i : Tree) {
		if (i.is(Flags::PAREHTHESIS_COMPONENT)) {
			vector<Component*> Tmp = Linearise(i.Components);
			Result.insert(Result.end(), Tmp.begin(), Tmp.end());
		}
		else {
			Result.push_back(&i);
		}
	}

	return Result;
}

void PreProsessor::If(int i)
{
	if (Input[i].Value != "if")
		return;
	if (!Input[(size_t)i + 1].is(Flags::PAREHTHESIS_COMPONENT))
		return;

	if (Calculate(Input[(size_t)i + 1].Components)) {
		vector<Component> tmp = Input[(size_t)i + 2].Components;
		Input.erase(Input.begin() + i);		//erase the if
		Input.erase(Input.begin() + i);		//erase the condition
		Input.erase(Input.begin() + i);		//erase the duplicated cholds of this pre if
		Input.insert(Input.begin() + i, tmp.begin(), tmp.end());
	}
	else {
		Input.erase(Input.begin() + i);		//erase the if
		Input.erase(Input.begin() + i);		//erase the condition
		Input.erase(Input.begin() + i);		//erase the duplicated cholds of this pre if
	}
	
	Factory();
	return;
}

bool PreProsessor::Calculate(vector<Component> condition)
{
	//0	, 1	, 2
	//OS == "win"
	//"win" == OS
	//OS = macro that has value "win" inside
	//first determine the side the SYS info is
	//Notice!!! this cannot happen after parser because if the preprosessed if has-
	//an include inside it, it wont work post parser!!!
	bool same = condition[0].Value == condition[2].Value;

	if (condition[1].Value == "==")
		return same;
	else if (condition[1].Value == "!=")
		return !same;

	return false;
}

void PreProsessor::Define_Const_Value(int i)
{
	//do this when you know gab, how to make const values in source files.
}

void PreProsessor::Replace_Const_Name_With_Value(vector<Component> &in)
{
	//<summary>
	//finds the defined const names and replaces-
	//them with the const value the names represents.
	//</summary>
	for (auto& c : in) {
		if (c.is(Flags::PAREHTHESIS_COMPONENT))
			Replace_Const_Name_With_Value(c.Components);
		else if (c.is(Flags::KEYWORD_COMPONENT))
			continue;
		else
			for (auto constant : Defined_Constants)
				if (c.Value == constant.first)
					c = constant.second;
	}
	return;
}


C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Cpp\UI\Producer.cpp" 
//WHAT EVER YOU THINK, WHAT EVER YOU WANT
//DONT!! FUCKING CHANGE THE ORDER OF THESE FUCKING HEADER DECLARATIONS YOU NOBNOB.
#include "../../H/UI/Producer.h"
#define CURL_STATICLIB  
#include "../../Dependencies/Curl/curl.h"
#include <regex>
#include "../../H/Docker/HTTPS.h"
#include "../../H/UI/Safe.h"
#include "../../H/Docker/Docker.h"


string Produce_Working_Dir = "";

void Producer::Assembly_Other_Source_Files()
{
    stringstream output;
    output << " ";
    for (int i = 0; i < Source_Files.size()-1; i++)
        output << Get_Assembler() << Get_Debug() << Get_Type() << " -o " + Source_Files[i] + ".obj " << Source_Files[i] << " " << Seperator << " ";
    if (Source_Files.size() > 0)
        output << Get_Assembler() << Get_Debug() << Get_Type() << " -o " + Source_Files[Source_Files.size()-1] + ".obj " << Source_Files[Source_Files.size() - 1] << " ";
    for (string i : Source_Files)
        Libs.push_back(i + ".obj");
    system(output.str().c_str());
    return ;
}

string Producer::Get_Linker_Type()
{
    if (OS == "win")
    {
        if (arch == "x86")
            return sys->Info.Linker_Location + "/x86_ld.exe ";
        else if (arch == "arm")
            return sys->Info.Linker_Location + "/arm_ld.exe ";
    }
    else if (OS == "unix")
    {
        return "ld ";
    }
    return "";
}

string Producer::Get_Assembler()
{
    if (OS == "win")
    {
        if (arch == "x86")
            return sys->Info.Assembler_Location + "/x86_as.exe --no-warn ";
        else if (arch == "arm")
            return sys->Info.Assembler_Location + "/arm_as.exe --no-warn ";
    }
    else if (OS == "unix")
    {
        return "as --no-warn ";
    }
    return "";
}

string Producer::Get_Debug()
{
    if (Debug)
    {
        return " -gdwarf3";
    }
    return "";
}

string Producer::Get_Type()
{
    return "";//" --" + Size + " ";
}

string Producer::Get_File_Name()
{
    if (Output_File != "")
    {
        return "-o " + Output_File;
    }
    return "";
}

string Producer::Get_Assembly_Dest_Marker()
{
    return ".obj ";
}

string Producer::Get_Linker_Debug_Type()
{
    return "";
}

string Producer::Get_Linker_aarch()
{
    if (Size == "32")
    {
        return " -m elf32-i386 ";
    }
    return "";
}

string Producer::Get_Assembler_Output()
{
    return " -o " + Output_File + Get_Assembly_Dest_Marker();
}

string Producer::Get_Linker_Input()
{
   return  Output_File + Get_Assembly_Dest_Marker();
}

string Producer::Get_Added_Libs()
{
    if (HOST_OS == "win")
    {
        string r = "";
        for (auto i : Libs)
        {
            r += i + " ";
        }
        return r + " -l kernel32";
    }
    else if (HOST_OS == "unix")
    {
        string r = " ";
        for (auto i : Libs)
        {
            if (i[i.size()-3] == 'o' && i[i.size()-2] == 'b' && i[i.size()-1] == 'j' || i[i.size()-1] == 'o')
                r += i + " ";
            else
                r += "-l " + i + " ";
        }
        return r;
    }
    return "";
}

string Producer::Get_Entry()
{
    return " -e _Z4mainv ";
}

string Producer::Get_System_Paths()
{
    string Result = "";

    for (auto i : DOCKER::Get_System_Paths())
        Result += " -L \"" + i + "\"";

    return Result;
}

string Producer::Link()
{
    return string();
}

string Producer::Get_Template()
{
    if (Find(Libs, "OpenGL32.lib") || Find(Libs, "OpenGL32.Lib"))
    {
        if (OS == "win")
        {
            return "ld -l \"glfw3\" \"OpenGL32\" \"kernel32\" \"user32\" \"gdi32\" \"shell32\" " + Output_File + ".obj -L \"C:\\Program Files (x86)\\Windows Kits\\10\\Lib\\10.0.18362.0\\um\\x86\" -e main -o \"" + Output_File +".exe\" -L \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.25.28610\\lib\\x86\" -l vcruntime -L \"C:\\Program Files (x86)\\Windows Kits\\10\\Lib\\10.0.18362.0\\ucrt\\x86\" -L \"" + Produce_Working_Dir + "\" -l ucrt";
        }
        else
        {
            cout << "Warning: Linker cannot find suitable template for:" << Get_All(Libs) << endl;
            cout << "Warning: Using fallback method for linking, might go wrong!" << endl;
            return "";
        }
    }
    return "";
}

string Producer::Update_Dir(string File_Name)
{
    int i = (int)File_Name.find_last_of('/');
    if (i != -1)
    {
        Produce_Working_Dir += File_Name.substr(0, (size_t)i + 1);
        return File_Name.substr((size_t)i + 1);
    }
    return "";
}

string Producer::Change_Dir()
{
    Update_Dir(Output_File);
    if (Produce_Working_Dir == "")
    {
        return "";
    }
    else
    {
       return (((string)"cd " + Produce_Working_Dir).c_str());
    }
}

bool Producer::Find(vector<string> in, string f)
{
    for (string s : in)
        if (s == f)
            return true;
    return false;
}

string Producer::Get_All(vector<string> in)
{
    string r = "";
    for (string s: in)
        r += s;
    return r;
}

string Producer::Get_Linker_Output(){
    if (OS == "win"){
        if (Type == "exe")
            return " -o " + Output_File + ".exe ";
        else if (Type == "dll")
            return "--shared -o" + Output_File + ".dll ";
    }
    else if (OS == "unix"){
        if (Type == "exe")
            return "-o" + Output_File + ".out ";
        else if (Type == "dll")
            return "--shared -o" + Output_File + ".so ";
    }
    return "";
}

void Producer::Assemble_Command()
{
    Assembly_Other_Source_Files();
    stringstream output;
    output << Get_Assembler() << Get_Debug() << Get_Type() << Get_Assembler_Output() << Output_File;
    system(output.str().c_str());
    output = stringstream();
    if (Get_Template() == "")
    {
        output << Get_Linker_Type() << Get_Linker_aarch() << Get_Linker_Debug_Type() << Get_Entry() << Get_Linker_Input() << Get_Linker_Output() << Get_Added_Libs() << Get_System_Paths();// << " /mix";
    }
    else
    {
        Update_Dir(Output_File);
        output << Get_Template();
    }
    system(output.str().c_str());

    if (sys->Info.VT_API != "") {
        CURL* curl;
        CURLcode res;

        std::string contents;
        std::ifstream f("file.txt", std::ios::in | std::ios::binary);

        if (f)
        {
            f.seekg(0, std::ios::end);
            contents.resize(f.tellg());
            f.seekg(0, std::ios::beg);
            f.read(&contents[0], contents.size());
            f.close();
        }

        struct curl_httppost* formpost = NULL;
        struct curl_httppost* lastptr = NULL;
        struct curl_slist* headerlist = NULL;
        static const char buf[] = "Expect:";

        curl_global_init(CURL_GLOBAL_ALL);

        // set up the header
        curl_formadd(&formpost,
            &lastptr,
            CURLFORM_COPYNAME, "cache-control:",
            CURLFORM_COPYCONTENTS, "no-cache",
            CURLFORM_END);

        curl_formadd(&formpost,
            &lastptr,
            CURLFORM_COPYNAME, "content-type:",
            CURLFORM_COPYCONTENTS, "multipart/form-data",
            CURLFORM_END);

        curl_formadd(&formpost, &lastptr,
            CURLFORM_COPYNAME, "file",  // <--- the (in this case) wanted file-Tag!
            CURLFORM_BUFFER, "data",
            CURLFORM_BUFFERPTR, contents.data(),
            CURLFORM_BUFFERLENGTH, contents.size(),
            CURLFORM_END);

        curl_formadd(&formpost, &lastptr,
            CURLFORM_COPYNAME, "apikey",  // <--- the (in this case) wanted file-Tag!
            CURLFORM_BUFFER, "data",
            CURLFORM_BUFFERPTR, sys->Info.VT_API.data(),
            CURLFORM_BUFFERLENGTH, sys->Info.VT_API.size(),
            CURLFORM_END);

        curl = curl_easy_init();

        headerlist = curl_slist_append(headerlist, buf);
        CURL* curl_handle;
        res;

        MemoryStruct chunk;
        string Resource = "";
        if (curl) {

            curl_easy_setopt(curl, CURLOPT_URL, "https://www.virustotal.com/vtapi/v2/file/scan");

            curl_easy_setopt(curl, CURLOPT_HTTPPOST, formpost);
            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &chunk);
            //curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);

            res = curl_easy_perform(curl);
            /* Check for errors */
            if (res != CURLE_OK)
                Report(Observation(ERROR, curl_easy_strerror(res), Position()));

            regex expression("\"resource\": \"[a-f0-9]+\"");
            smatch matches;
            string Buffer = chunk.memory;
            if (!regex_search(Buffer, matches, expression)) {
                Report(Observation(MSG_Type::WARNING, "Could not get VT report.", Position()));
            }

            Resource = matches.str().substr(13, matches.str().size() - 1 - 13);

            curl_easy_cleanup(curl);


            curl_formfree(formpost);

            curl_slist_free_all(headerlist);
        }
        curl = curl_easy_init();
        free(chunk.memory);
        chunk = MemoryStruct();

        curl_easy_setopt(curl, CURLOPT_URL, "https://www.virustotal.com/vtapi/v2/file/report");
        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void*)&chunk);
        curl_easy_setopt(curl, CURLOPT_USERAGENT, "libcurl-agent/1.0");
        string Data = "apikey=" + sys->Info.VT_API + "&resource=" + Resource;
        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, Data.c_str());

        res = curl_easy_perform(curl);
        if (res != CURLE_OK)
            Report(Observation(ERROR, curl_easy_strerror(res), Position()));

        regex expression("\"positives\": [0-9]+");
        smatch matches;
        string Buffer = chunk.memory;
        if (!regex_search(Buffer, matches, expression)) {
            Report(Observation(MSG_Type::WARNING, "VT is in cooldown, please wait moment, then re-try.", Position()));
        }
        else {
            int Positives = atoi(matches.str().substr(12).c_str());
            if (Positives > 0) {
                Report(Observation(ERROR, "Dangereous binary detected " + Output_File, Position()));
            }
        }
    }
}

C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Cpp\UI\Safe.cpp" 
#include "../../H/UI/Safe.h"
#include "../../H/UI/Usr.h"
#include "../../H/BackEnd/Selector.h"
#include "../../H/Docker/Mangler.h"
#include "../../Tests/H/Test_Lexer.h"
#include "../../Tests/H/Test_Back_End.h"
#include "../../H/Parser/Algebra.h"
#include "../../H/Nodes/Node.h"

extern Selector* selector;
extern Usr* sys;
extern Node* Global_Scope;

const string Red = "\x1B[1;31m";
const string Green = "\x1b[1;32m";
const string Yellow = "\x1b[1;33m";
const string Blue = "\x1b[1;34m";
const string Magenta = "\x1b[1;35m";
const string Cyan = "\x1b[1;36m";
const string White = "\x1b[1;37m";
const string Reset = "\x1b[1;0m";

vector<Observation> Notices;

void Safe::PostProsessor_Factory()
{
	for (auto i : Input) {
		Check_Return_Validity(i);
		Disable_Non_Ptr_Class_Return(i);
		Check_For_Unitialized_Objects(i);
		Warn_Usage_Of_Depricated(i);
		Prefer_Class_Cast_Rather_Object_Cast(i);
		Warn_Usage_Before_Definition(i);
		Check_For_Undefined_Inheritance(i);
	}
}

void Stop() {
	throw::runtime_error("ERROR!");
}

void Observation::Report()
{
	string Head;
	if (Type == ERROR)
		Head = Red + "Error" + Reset + ": ";
	else if (Type == WARNING)
		Head = Yellow + "Warning" + Reset + ": ";
	else if (Type == SOLUTION)
		Head = Green + "Solution" + Reset + ": {\n  ";
	else if (Type == INFO)
		Head = Green + "Notice" + Reset + ": ";

	if (Pos.GetLine() != -1)
		if (Pos.GetFilePath() != nullptr)
			cout << Pos.GetFilePath() << ":" << Pos.GetFriendlyLine() << ":" << Pos.GetFriendlyCharacter() << ": " << Head << Msg << endl;
		else
			cout << Head << Msg << endl;
	else 
		cout << Head << Msg << endl;

	if (Type == SOLUTION)
		cout << "}" << endl;
	if ((Type == FAIL || Type == ERROR) && !Dont_Stop)
		//if (!sys->Info.Is_Service)
			throw::runtime_error("ERROR");
}

void Report(Observation o)
{
	o.Report();
}

void Report(vector<Observation> o)
{
	bool Needs_Stoppping = false;

	for (int i = 0; i < o.size(); i++) {
		if (o[i].Type == ERROR || o[i].Type == FAIL) {
			o[i] = Observation(o[i], true);
			Needs_Stoppping = true;
		}
	}

	for (auto i : o)
		i.Report();

	if (Needs_Stoppping) {
		throw::runtime_error("ERROR");
	}
}

void Report(long type, Lexer_Expectation_Set expectation, string source, vector<Component> result) {
	if (type == SUCCESS) {
		cout << source << Green << " OK " << Reset << endl;
	}
	else if (type == FAIL) {
		cout << source << Red << " FAILED!" << Reset << "\n";
		int s = (int)expectation.Expecations.size();
		if (result.size() < expectation.Expecations.size())
			s = (int)result.size();
		for (int i = 0; i < s; i++) {
			if (expectation.Get_Name(i) != expectation.Get_Name(result[i]))
				cout << "Expected " << expectation.Get_Name(i) << " got " << expectation.Get_Name(result[i]) << "\n";
		}
		cout << endl;
	}
	if (type == FAIL)
		throw::runtime_error("ERROR");
}

void Report(long type, Back_Expectation_Set expectation, string source, vector<Base*> result) {
	if (type == SUCCESS) {
		cout << source << Green << " OK " << Reset << endl;
	}
	else if (type == FAIL) {
		cout << source << Red << " FAILED!" << Reset << "\n";
		int s = (int)expectation.Expecations.size();
		if (result.size() < expectation.Expecations.size())
			s = (int)result.size();
		for (int i = 0; i < s; i++) {
			if (expectation.Get_Name(i) != expectation.Get_Name(result[i]))
				cout << "Expected " << expectation.Get_Name(i) << " got " << expectation.Get_Name(result[i]) << "\n";
		}
		cout << endl;
	}
	if (type == FAIL)
		throw::runtime_error("ERROR");
}

void Safe::Check_Return_Validity(Node* n)
{
	if (n->Name != "return")
		return;
	Node* func = n->Get_Scope_As(FUNCTION_NODE, n->Scope);

	if (n->Right != nullptr) {
		if (!n->Right->Has({ OPERATOR_NODE, ARRAY_NODE, CONDITION_OPERATOR_NODE, BIT_OPERATOR_NODE, CONTENT_NODE})) {
			
			if (n->Right->is(CALL_NODE))
				if (!n->Right->Function_Ptr)
					goto Skip_Size_And_Inheritance;
			n->Right->Size = n->Find(n->Right, n->Scope)->Size;
			n->Right->Inheritted = n->Find(n->Right, n->Scope)->Inheritted;

		Skip_Size_And_Inheritance:;
		}
		if (n->Right->Get_Inheritted("_", false, false, true) == func->Get_Inheritted("_", false, false, true))
			return;
		else if (n->Right->Get_Inheritted("_", true, false, true) == func->Get_Inheritted("_", false, false, true))
			return;
		else if (n->Right->Cast_Type != nullptr && n->Find(n->Right->Cast_Type, n)->Get_Size() == func->Get_Size() && n->Find(n->Right->Cast_Type, n)->Get_Inheritted("_", false, false, true) == func->Get_Inheritted("_", false, false, true))
			return;
		else if (func->Get_Size() == 0) {
			Report(Observation(ERROR, "Cant return value in non-returning funciton.", *n->Location));
			Stop();
		}
		else {
			Report({
				Observation(ERROR, "Incorrect return type!", *n->Location),
				Observation(WARNING, "Return type '" + n->Right->Get_Inheritted(" ", false, false, true) + " ' does not mach with '" + func->Get_Inheritted(" ", false, false, true) + " '.", *n->Right->Location),
				Observation(SOLUTION, "Try casting '" + n->Right->Get_Inheritted(" ", false, false, true) + " ' to '" + func->Get_Inheritted(" ", false, false, true) + " '." , *n->Right->Location)
				});
			Stop();
		}
	}
	else if (func->Get_Size() != 0 && func->is("func") == -1){
		Report(Observation(ERROR, "Non-void function needs returning value.", *n->Location));
		Stop();
	}
}

void Safe::Disable_Non_Ptr_Class_Return(Node* n)
{
	if (!n->is(FUNCTION_NODE) && !n->is(IMPORT))
		return;
	if (n->is("ptr") != -1)
		return;
	if (n->Is_Template_Object)
		return;
	if (MANGLER::Is_Based_On_Base_Type(n))
		return;

	if (n->Find(n, n->Scope)->Size > selector->Get_Largest_Register_Size()) {
		Report({
			Observation(ERROR, "Return object is bigger than: " + to_string(_SYSTEM_BIT_SIZE_ * 8), *n->Location),
			Observation(SOLUTION, "Please return the object as a pointter", *n->Location)
			});
		throw::runtime_error("ERROR!");
	}
}

void Safe::Check_For_Unitialized_Objects(Node* func)
{
	//go through the code inside this function and try to find '=' operators-
	//that set the object in question an initial value.
	if (!func->is(FUNCTION_NODE))
		return;

	for (auto v : func->Defined) {
		if (v->is(PARAMETER_NODE))
			continue;
		for (auto c : func->Childs) {
			for (auto n : c->Get_all(ASSIGN_OPERATOR_NODE)) {
				if (n->Left->Name == v->Name)
					goto Next_Variable;
			}
			//constructor callation
			for (auto n : c->Get_all(CALL_NODE)) {
				if (n->Parameters.size() > 0 && n->Parameters[0]->Name == v->Name)
					if (n->Name == v->Inheritted[0])
						goto Next_Variable;
			}
		}

		
		Report({
			Observation(WARNING, "Usage of uninitialized object is dangerous!", *v->Location),
			Observation(SOLUTION, "Call constructor of '" + v->Name + "' to initialize it.", *v->Location),
		});

	Next_Variable:;
	}
}

void Safe::Warn_Usage_Of_Depricated(Node* n)
{
	if (n->Has({ FUNCTION_NODE, IMPORT, EXPORT, PROTOTYPE, CLASS_NODE }))
		return;

	string Comment;

	if (n->is(CALL_NODE) && !n->Function_Ptr)
		Comment = n->Function_Implementation->Comment;
	else if (n->Has({OBJECT_NODE, OBJECT_DEFINTION_NODE}))
		Comment = n->Find(n, n)->Comment;

	if (Comment == "")
		return;

	regex expression("Depricated:.+");
	smatch matches;
	string Buffer = Comment;
	if (regex_search(Buffer, matches, expression)) {
		for (auto i : matches) {
			Report(Observation(WARNING, i.str(), *n->Location));
		}
	}
}

void Safe::Prefer_Class_Cast_Rather_Object_Cast(Node* n)
{
	if (n->Cast_Type == nullptr || n->Cast_Type->Name == "address")
		return;
	//check here if the cast type is a class or a object
	Node* Cast = n->Find(n->Cast_Type, n);
	if (!Cast->is(CLASS_NODE)) {
		Report({
			Observation(WARNING, "Usage of non-class definition as a cast type is not recomended!", *n->Location),
			Observation(SOLUTION, "Prefer class typed cast 'type " + Cast->Get_Inheritted(" ", false, false, false) + " " + Cast->Name + "{}'", *Cast->Location)
			});
	}
}

void Safe::Warn_Usage_Before_Definition(Node* n)
{
	if (!n->is(OBJECT_NODE))
		return;
	Node* Definition = n->Find(n, n->Scope);

	if (Definition == nullptr)
		return;

	if (Definition->Location->GetAbsolute() > n->Location->GetFriendlyAbsolute() && Definition->Location->GetFilePath() == n->Location->GetFilePath()) {
		Report(Observation(ERROR, "Usage of local variable '" + n->Name + "' before definition at line '" + to_string(Definition->Location->GetFriendlyLine()) + "'.", *n->Location));
	}
}

void Safe::Parser_Factory()
{
	Reference_Count_Type_Un_Availability();
}

void Safe::Reference_Count_Type_Un_Availability()
{
	Node* Reference_Count_Type = Global_Scope->Find(sys->Info.Reference_Count_Size, Global_Scope, CLASS_NODE, "integer", true);

	if (Reference_Count_Type == nullptr) {
		Report({
			Observation(ERROR, "Not found an integer at size '" + to_string(sys->Info.Reference_Count_Size) + "'.", Position()),
			Observation(SOLUTION, "type [name]{\n    size = " + to_string(sys->Info.Reference_Count_Size) + "\n  }", Position())
		});
	}
}

void Safe::Check_For_Undefined_Inheritance(Node* n)
{
	for (auto i : n->Inheritted) {
		//ignore keywords
		for (auto j : Lexer::Keywords)
			if (i == j)
				goto Next;
		//ignore template inheritances
		for (auto j : n->Templates)
			if (i == j->Name)
				goto Next;
		for (auto j : n->Inheritable_templates)
			if (i == j->Name)
				goto Next;
		//
		if (n->Find(i, n) == nullptr) {
			Report(Observation(ERROR, "Usage of un-declared type '" + i + "'.", *n->Location));
		}
	Next:;
	}
}

C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Cpp\UI\Satellite.cpp" 
#include "../../H/UI/Satellite.h"
#include "../../H/UI/Usr.h"
#include "../../H/UI/Safe.h"
#include "../../H/Docker/Docker.h"
#include <filesystem>

extern Usr* sys;

void Satellite::Init_Wanted_Dependencies()
{
	if (Installation_Type == INSTALL::DEFAULT) {
		Dependecies = {
			{OS::UNIX, INTRODUCE::CONSOLE, nullptr, "git"},
			{OS::UNIX, INTRODUCE::CONSOLE, nullptr, "libcurl4-openssl-dev"},
			{OS::UNIX, INTRODUCE::CONSOLE, &sys->Info.Assembler_Location, "as"},
			{OS::UNIX, INTRODUCE::CONSOLE, &sys->Info.Linker_Location, "ld"},

			{OS::WIN, INTRODUCE::CONSOLE, nullptr, "git"},
			{OS::WIN, INTRODUCE::LOCAL,   nullptr, "libcurl.lib"},
		};

		if (sys->Info.Architecture == ARCHITECTURE::X86) {
			Dependecies.push_back({ OS::WIN, INTRODUCE::LOCAL, &sys->Info.Linker_Location, "x86_ld.exe" });
			Dependecies.push_back({ OS::WIN, INTRODUCE::LOCAL, &sys->Info.Assembler_Location, "x86_as.exe" });
		}
		if (sys->Info.Architecture == ARCHITECTURE::ARM) {
			Dependecies.push_back({ OS::WIN, INTRODUCE::LOCAL, &sys->Info.Linker_Location, "arm_ld.exe" });
			Dependecies.push_back({ OS::WIN, INTRODUCE::LOCAL, &sys->Info.Assembler_Location, "arm_as.exe" });
		}
	}
}

void Satellite::Factory()
{
	for (auto Medium : Dependecies) {
		//HOST_OS because in host we need to compile the source
		if (Medium.Platform == sys->Info.HOST_OS) {
			Process_Local_Dependencies(Medium);
			Process_Console_Dependencies(Medium);
		}
	}
}

void Satellite::Process_Local_Dependencies(Medium Medium)
{
	if (Medium.Introducer != INTRODUCE::LOCAL)
		return;

	//start the search for the dependency from Evie eecutable and downwards.
	string Path_To_Medium = DOCKER::Find(Medium.Product_ID);
	if (Path_To_Medium != "") {
		if (Medium.Dependency_Location != nullptr) {
			*Medium.Dependency_Location = Path_To_Medium;
		}
		return;	//the dependecy is there
	}

	Report(Observation(ERROR, "Dependency '" + Medium.Product_ID + "' is missing or unreachable to Evie!"));
}

void Satellite::Process_Console_Dependencies(Medium Medium)
{
	if (Medium.Introducer != INTRODUCE::CONSOLE)
		return;

	string Command;

	if (Medium.Platform == OS::WIN) {
		Command = Medium.Product_ID + " --version > $null";
	}
	else if (Medium.Platform == OS::UNIX) {
		Command = "which " + Medium.Product_ID + " > /dev/null";
	}

	int Success = system(Command.c_str());

	if (Success == 0)
		return;

	Report(Observation(ERROR, "Dependency '" + Medium.Product_ID + "' is missing or unreachable to Evie!"));
}

C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Cpp\UI\Service.cpp" 
#include "../../H/UI/Service.h"
#include "../../H/Parser/Parser.h"
#include "../../H/Docker/Docker.h"
#include "../../H/PreProsessor/PreProsessor.h"
#include "../../H/Parser/PostProsessor.h"
#include "../../H/BackEnd/IRGenerator.h"
#include "../../H/BackEnd/IRPostProsessor.h"
#include "../../H/BackEnd/BackEnd.h"

#include <math.h>

double Sensitivity = 50.0 / 100.0; //the higher the value is the lower the sens is.

extern vector<Observation> Notices;
extern string* FileName;
extern vector<Node*> Find_Trace;
extern string Output;
extern unsigned long long Reg_Random_ID_Addon;
extern unsigned long long Label_Differential_ID;
extern long long Inlined_Function_Count;
extern long long Unique_ID_Count;

Proxy::Proxy(string raw) {
	Notices.clear();

	Clean(raw);

	//this function transforms the raw string data into a Proxy data class.
	vector<Component> Tmp = Lexer::GetComponents(raw);

	Input = Tmp[0].Components;

	//construct the source code
	for (int i = 1; i < Tmp.size(); i++)
		Word += Tmp[i].Value.substr(1, Tmp[i].Value.size() - 2);

	Factory();
}

void Proxy::Factory() {
	for (int i = 0; i < Input.size(); i++) {
		Parse_Num(i);
		Parse_String(i);
		Parse_Position(i);
	}
}

void Proxy::Parse_Num(int i) {
	//"Label name": 123
	if (i + 2 >= Input.size())
		return;

	if (!Input[i + 2].is(Flags::NUMBER_COMPONENT))
		return;

	Type = (Document_Request_Type)atoi(Input[i + 2].Value.c_str());
}

void Proxy::Parse_String(int& i) {
	//"Label name": "ABC"
	if (i + 2 >= Input.size())
		return;

	if (!Input[i].is(Flags::STRING_COMPONENT))
		return;

	if (Input[i].Value != "\"Uri\"")
		return;

	if (!Input[i + 2].is(Flags::STRING_COMPONENT))
		return;

	if (Uri == "") {
		Uri = Input[i + 2].Value;
		Uri = Uri.substr(1, Uri.size() - 2);
		Uri = Find_Location_Of_Uri();
	}

	Input.erase(Input.begin() + i);
	Input.erase(Input.begin() + i);
	Input.erase(Input.begin() + i);

	i -= 3;
}

void Proxy::Parse_Position(int i) {
	//"Label Name": {
	//	"Member1": Value,
	//	"Member2": Value2,
	//	"member3": Value3,
	//}
	if (i + 2 >= Input.size())
		return;

	if (!Input[i + 2].is(Flags::PAREHTHESIS_COMPONENT))
		return;

	for (int j = 0; j < Input[i + 2].Components.size(); j++) {
		if (!Input[i + 2].Components[j].is(Flags::NUMBER_COMPONENT))
			continue;

		if (j - 1 < 1)
			continue;

		if (Input[i + 2].Components[j - 1].Value != "-")
			continue;

		Input[i + 2].Components.erase(Input[i + 2].Components.begin() + j - 1);
		Input[i + 2].Components[j - 1].Value = to_string(atoi(Input[i + 2].Components[j - 1].Value.c_str()) * -1);
	}

	//here we get from the paranthesis that resides in index i + 2
	//the components, every component is same as the ValueX above
	//"Member name": ValueX,
	Location = Position(
		atoi(Input[i + 2].Components[2].Value.c_str()),
		atoi(Input[i + 2].Components[6].Value.c_str()),
		atoi(Input[i + 2].Components[10].Value.c_str()),
		atoi(Input[i + 2].Components[14].Value.c_str())
	);
}

string Proxy::Find_Location_Of_Uri()
{
	vector<string> Exess_Headers = {
		"file://",
		"untitled:",
	};
	
	//we dont like vsc file headers.
	for (auto i : Exess_Headers) {
		if (Uri._Starts_with(i))
			Uri = Uri.substr(i.size());
	}

	Uri.erase(Uri.begin());
	Uri[0] = toupper(Uri[0]);

	//letus makus newus replaSUS.
	for (int i = 0; i < Uri.size(); i++) {
		if (strncmp(&Uri[i], "%3A", 3) == 0) {
			Uri.erase(Uri.begin() + i);
			Uri.erase(Uri.begin() + i);

			Uri[i] = ':';
			break;
		}
	}

	return Uri;
}

void Proxy::Clean(string& raw)
{
	for (int i = raw.size() - 1; i > 0; i--) {
		if (raw[i] != 'n' && raw[i] != 'r' && raw[i] != 't' && raw[i] != '\'' && raw[i] != '\"')
			continue;

		if (raw[i - 1] != '\\')
			continue;

		if (i - 2 < 1 || raw[i - 2] == '\\')
			continue;


		switch (raw[i])
		{
		case 'n':
			raw[i - 1] = '\n';
			break;
		case 'r':
			raw[i - 1] = '\r';
			break;
		case 't':
			raw[i - 1] = '\t';
			break;
		case '\'':
			raw[i - 1] = '\'';
			break;
		case '\"':
			raw[i - 1] = '\"';
			break;
		}

		raw.erase(raw.begin() + i);
	}
}

#ifdef _WIN32
#include <WinSock2.h>
#include <WS2tcpip.h>
#define ERROR (MSG_Type)1

Proxy* UDP_Server::Receive() {
	int Error = 0;
	unsigned int Size = 0;
	int Mega_Byte = 1000000;

	//recieve the upcoming file size
	Error = recv(Socket, (char*)&Size, sizeof(Size), 0);

	if (Size < 1 || Size > Mega_Byte * 100)
		Report(Observation(ERROR, "Received message size is incorrect: '" + to_string(Size) + "B'."));

	vector<char> Buffer = vector<char>(Size);

	//this recieves the file content
	Error = recv(Socket, Buffer.data(), Buffer.size(), 0);

	Proxy* Result = new Proxy(string(Buffer.data(), Size));

	if (Error <= 0)
		return nullptr;
	else
		return Result;
}

void UDP_Server::Send(char* Data, int Length) {
	int Error = 0;

	//send the upcoming file size
	//Error = send(Socket, (char*)&Length, sizeof(Length), 0);

	//this sends the file content
	Error = send(Socket, Data, Length, 0);

	if (Error <= 0) {
		//we could stop the service here
	}
}

void UDP_Server::Send(MSG_Type Wellfare, vector<Node*> MSG)
{
	string Result = "{\"Status\": " + to_string(Wellfare) + ",\"Elements\": \"[";

	for (auto i : MSG) {
		string Purified_Name = i->Name;

		for (int i = 0; i < Purified_Name.size(); i++) {
			if (Purified_Name[i] == '\n') {
				Purified_Name[i] = 'n';
				Purified_Name.insert(Purified_Name.begin() + i, '\\');
			}
			if (Purified_Name[i] == '\t') {
				Purified_Name[i] = 't';
				Purified_Name.insert(Purified_Name.begin() + i, '\\');
			}
			if (Purified_Name[i] == '\"') {
				Purified_Name.insert(Purified_Name.begin() + i, '\\');
			}
		}

		Result += "\\\"" +  Purified_Name + "\\\",";
	}

	Result = Result.substr(0, Result.size() - 1);

	Result += "]\"}";

	Send(Result);
}

UDP_Server::UDP_Server() {
	WSADATA wsadata = WSADATA();
	WSAStartup(MAKEWORD(4, 4), &wsadata);

	Socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (Socket == INVALID_SOCKET)
		Report(Observation(ERROR, "Invalid socket" + to_string(WSAGetLastError())));

	sockaddr_in bind_address = { 0 };
	bind_address.sin_family = AF_INET;
	//bind_address.sin_addr.s_addr = inet_addr("127.0.0.1");

	int Error = inet_pton(AF_INET, "localhost", &bind_address.sin_addr.s_addr);

	bind_address.sin_port = htons(1111/*Port*/);

	Error = ::bind(Socket, (sockaddr*)&bind_address, (int)sizeof(sockaddr_in));

	if (Error < 0)
		Report(Observation(ERROR, "Invalid socket" + to_string(WSAGetLastError())));

	int length = sizeof(sockaddr_in);
	if (getsockname(Socket, (sockaddr*)&bind_address, &length) < 0)
		Report(Observation(ERROR, "Invalid socket" + to_string(WSAGetLastError())));

	Port = bind_address.sin_port;

	cout << htons(Port) << endl;

	if (listen(Socket, 5) < 0)
		Report(Observation(ERROR, "Invalid socket" + to_string(WSAGetLastError())));

	sockaddr_in client_address = { 0 };
	length = sizeof(sockaddr);
	auto client = accept(Socket, (sockaddr*)&client_address, (int*)&length);

	closesocket(Socket);

	Socket = client;

	if (client == INVALID_SOCKET)
		Report(Observation(ERROR, "Invalid socket" + to_string(WSAGetLastError())));
}

UDP_Server::~UDP_Server() {
	closesocket(Socket);
}

#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
Proxy* UDP_Server::Receive() {
	int Error = 0;
	unsigned int Size = 0;
	int Mega_Byte = 1000000;

	//recieve the upcoming file size
	Error = recv(Socket, (char*)&Size, sizeof(Size), 0);

	if (Size < 1 || Size > Mega_Byte * 100)
		Report(Observation(ERROR, "Received message size is incorrect: '" + to_string(Size) + "B'."));

	vector<char> Buffer = vector<char>(Size);

	//this recieves the file content
	Error = recv(Socket, Buffer.data(), Buffer.size(), 0);

	Proxy* Result = new Proxy(string(Buffer.data(), Size));

	if (Error <= 0)
		return nullptr;
	else
		return Result;
}

void UDP_Server::Send(char* Data, int Length) {
	int Error = 0;

	//send the upcoming file size
	//Error = send(Socket, (char*)&Length, sizeof(Length), 0);

	//this sends the file content
	Error = send(Socket, Data, Length, 0);

	if (Error <= 0) {
		//we could stop the service here
	}
}

void UDP_Server::Send(MSG_Type Wellfare, vector<Node*> MSG)
{
	string Result = "{\"Status\": " + to_string(Wellfare) + ",\"Elements\": \"[";

	for (auto i : MSG) {
		string Purified_Name = i->Name;

		for (int i = 0; i < Purified_Name.size(); i++) {
			if (Purified_Name[i] == '\n') {
				Purified_Name[i] = 'n';
				Purified_Name.insert(Purified_Name.begin() + i, '\\');
			}
			if (Purified_Name[i] == '\t') {
				Purified_Name[i] = 't';
				Purified_Name.insert(Purified_Name.begin() + i, '\\');
			}
			if (Purified_Name[i] == '\"') {
				Purified_Name.insert(Purified_Name.begin() + i, '\\');
			}
		}

		Result += "\\\"" + Purified_Name + "\\\",";
	}

	Result = Result.substr(0, Result.size() - 1);

	Result += "]\"}";

	Send(Result);
}

UDP_Server::UDP_Server() {
	//WSADATA wsadata = WSADATA();
	//WSAStartup(MAKEWORD(4, 4), &wsadata);

	Socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (Socket == -1)
		Report(Observation(ERROR, "Invalid socket"));

	sockaddr_in bind_address = { 0 };
	bind_address.sin_family = AF_INET;
	//bind_address.sin_addr.s_addr = inet_addr("127.0.0.1");

	int Error = inet_pton(AF_INET, "localhost", &bind_address.sin_addr.s_addr);

	bind_address.sin_port = htons(1111/*Port*/);

	Error = ::bind(Socket, (sockaddr*)&bind_address, (int)sizeof(sockaddr_in));

	if (Error < 0)
		Report(Observation(ERROR, "Invalid socket"));

	int length = sizeof(sockaddr_in);
	if (getsockname(Socket, (sockaddr*)&bind_address, &length) < 0)
		Report(Observation(ERROR, "Invalid socket"));

	Port = bind_address.sin_port;

	cout << htons(Port) << endl;

	if (listen(Socket, 5) < 0)
		Report(Observation(ERROR, "Invalid socket"));

	sockaddr_in client_address = { 0 };
	length = sizeof(sockaddr);
	auto client = accept(Socket, (sockaddr*)&client_address, (int*)&length);

	close(Socket);

	Socket = client;

	if (client == -1)
		Report(Observation(ERROR, "Invalid socket"));
}

UDP_Server::~UDP_Server() {
	close(Socket);
}


#endif

void Code_Analyzer(string Working_Dir) {

}

void Service::Factory()
{
	//Let the more complex multifile analysis to compute,
	//meanwhile we do our mundane autocompleting tasks in main thread.
	thread Analyze_Thread = thread(Code_Analyzer, Working_Dir);

	//Letus loopatus infinitus
	while (true) {
		Output.clear();

		//wait for the next instruction from VSC
		Proxy* Handle = Code_Completion_Handle.Receive();

		Handle_Auto_Completion(Handle);
		Handle_Code_Generation(Handle);

		Code_Completion_Handle.Send(MSG_Type::SUCCESS, Output);
	}
}

void Service::Handle_Auto_Completion(Proxy* proxy)
{
	if (proxy->Type != Document_Request_Type::COMPLETIONS)
		return;

	Parse_Code(proxy);

	//This function chooses which type of completion we must use in this case.
	Determine_Completion_Type(proxy);
}

void Service::Parse_Code(Proxy* proxy)
{
	//try to generate the AST and try to lacte the Position of the cursor from the AST.
	//try {
		//this stops from the new source code touching the real AST but it can still find it if needed.
			//It is like a read only
		DOCKER::Working_Dir.clear();
		if (proxy->Type == Document_Request_Type::ASM) {
			Singlefile_AST->Clean();
			DOCKER::Included_Files.clear();
		}
		DOCKER::Assembly_Source_File.clear();
		Reg_Random_ID_Addon = 0;
		Label_Differential_ID = 0;
		Inlined_Function_Count = 0;
		Unique_ID_Count = 0;

		DOCKER::FileName.push_back(proxy->Uri);
		FileName = new string(DOCKER::FileName.back());
		DOCKER::Update_Working_Dir(*FileName);

		sys->Service_Info = proxy->Type;

		if (sys->Info.Architecture == "x86")
			::Output = ".intel_syntax noprefix\n";
		else
			::Output = "";

		vector<Component> Input = Lexer::GetComponents(proxy->Word);

		PreProsessor Preprosessor(Input);
		Preprosessor.Defined_Constants =
		{
			{"SOURCE_FILE",         Component("\"" + sys->Info.Source_File + "\"", Flags::STRING_COMPONENT)},
			{"DESTINATION_FILE",    Component("\"" + sys->Info.Destination_File + "\"", Flags::STRING_COMPONENT)},
			{"OS",                  Component("\"" + sys->Info.OS + "\"", Flags::STRING_COMPONENT)},
			{"ARCHITECTURE",        Component("\"" + sys->Info.Architecture + "\"", Flags::STRING_COMPONENT)},
			{"FORMAT",              Component("\"" + sys->Info.Format + "\"", Flags::STRING_COMPONENT)},
			{"BITS_MODE",           Component(sys->Info.Bits_Mode, Flags::NUMBER_COMPONENT)},
			{"true",                Component("1", Flags::NUMBER_COMPONENT)},
			{"false",               Component("0", Flags::NUMBER_COMPONENT)},
		};
		Preprosessor.Factory();

		Parser parser = Parser(Singlefile_AST);
		parser.Input = Input;
		parser.Factory();

		PostProsessor postprosessor(Singlefile_AST, parser.Input);
		if (proxy->Type == Document_Request_Type::ASM) {
			Singlefile_AST->Append(Singlefile_AST->Childs, postprosessor.Input);

			vector<IR*> IRs;
			IRGenerator g(Singlefile_AST, Singlefile_AST->Childs, &IRs);

			IRPostProsessor IRpost(&IRs);

			/*if (sys->Info.Debug)
				DebugGenerator DG(IRs);*/

			BackEnd Back(IRs, ::Output);
		}

		DOCKER::FileName.pop_back();
		//The parser automatically saves the new AST buided into the AST variable.
	/*}
	catch (exception) {
	}*/
}

void Service::Handle_Code_Generation(Proxy* proxy)
{
	if (proxy->Type != Document_Request_Type::ASM)
		return;
	//try {

		Parse_Code(proxy);

		Node* Result = new Node(CLASS_NODE, ::Output, nullptr);
		
		Output.push_back(Result);
	//}
	//catch (exception) {
	//	//Report(Observation(ERROR, "Cannot parse the code", proxy->Location));
	//}
}

void Service::Determine_Completion_Type(Proxy* cursor)
{
	Cursor* C = Search_Absolute(cursor->Location.GetLine(), cursor->Location.GetCharacter(), cursor->Word, {});
	Node * Location = Find_Cursor_From_AST(C);

	if (Location) {
		if (Location->Has({ OBJECT_NODE, OBJECT_DEFINTION_NODE })) {
			for (auto i : Location->Scope->Defined) {
				Output.push_back(i);
			}
		}
		//a->int
		else if (Location->is(NODE_CASTER)) {
			//find the right side as an class type
			for (auto i : Location->Get_Scope_As(CLASS_NODE, { "static" }, Location)->Defined)
				if (i->is(CLASS_NODE))
					Output.push_back(i);
		}
		//a.x
		else if (Location->Name == ".") {
			for (auto i : Location->Find(Location->Left, Location)->Defined)
				Output.push_back(i);
		}
	}
	//if (C->Current->is(Flags::KEYWORD_COMPONENT)) {
		for (auto i : Lexer::Keywords)
			//if (Percentage_Compare(i, C->Current->Value) > Sensitivity)
				Output.push_back(new Node(KEYWORD_NODE, i, &C->Current->Location));
	//}
}

Node* Service::Find_Cursor_From_AST(Cursor* c)
{
	Node* Result = nullptr;

	Find_Trace.clear();

	Result = Singlefile_AST->Find(c->Current->Location);

	if (!Result && c->Previus.size() > 0) {
		Find_Trace.clear();
		Result = Singlefile_AST->Find(c->Previus.back()->Location);
	}

	if (!Result && c->Next.size() > 0) {
		Find_Trace.clear();
		Result = Singlefile_AST->Find(c->Next.back()->Location);
	}

	return Result;
}

//Returns fixed location of the start of the word that the cursor resides in.
Cursor* Service::Search(int Absolute, vector<Component>* Raw)
{

	Cursor* Result = new Cursor();

	int i = 0;

	vector<Component*> Linearised_Raw = Linearise(*Raw);

	for (i = 0; i < Linearised_Raw.size() && Linearised_Raw[i]->Location.GetAbsolute() < Absolute; i++);

	if (Linearised_Raw[i]->is(Flags::END_COMPONENT))
		i--;

	for (; i > 0 && Linearised_Raw[i]->Value == "\n"; i--);

	try {

		if (i - 1 >= 0)
			Result->Previus.push_back(Linearised_Raw[i - 1]);
		if (i + 1 < Linearised_Raw.size())
			Result->Next.push_back(Linearised_Raw[i + 1]);

		Result->Current = Linearised_Raw[i];

		return Result;
	}
	catch (exception) {
		//now the 'Result' index points to the next word start address.
		//this means that the cursor position is in the 'Result' - 1 location.

		Report(Observation(ERROR, "Cursor out of bouds", Position()));
	}
}

Cursor* Service::Search_Absolute(int Line, int Character, string Source, vector<Component>* Components)
{
	int Absolute = Calculate_Absolute_Position(Line, Character, Source);

	if (Components == nullptr || Components->size() == 0)
		Components = new vector<Component>(Lexer::GetComponents(Source));

	return Search(Absolute, Components);
}

int Service::Calculate_Absolute_Position(int Line, int Character, string Raw)
{
	int Result = 0;

	//make the VSC line and character into friendly types.
	int Current_Line = 1;
	int Current_Character = 1;

	Line++;
	Character++;

	for (Result = 0; Result < Raw.size(); Result++) {
		if (Current_Line == Line && Current_Character == Character)
			return Result;

		if (Raw[Result] == '\n') {
			Current_Line++;
			//new line new character counts
			Current_Character = 1;
		}
		else
			Current_Character++;
	}
}

vector<Component*> Service::Linearise(vector<Component>& Tree)
{
	vector<Component*> Result;

	for (auto &i : Tree) {
		if (i.is(Flags::PAREHTHESIS_COMPONENT)) {
			vector<Component*> Tmp = Linearise(i.Components);
			Result.insert(Result.end(), Tmp.begin(), Tmp.end());
		}
		else {
			Result.push_back(&i);
		}
	}

	return Result;
}

double Service::Percentage_Compare(string X, string Y)
{
	double Result = 0; //0%
	for (int i = 0; i < min(X.size(), Y.size()); i++) {
		if (X[i] == Y[i])
			Result += 1; //+ 1%
	}

	return round(Result / max(X.size(), Y.size()));
}

C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Cpp\UI\Usr.cpp" 
#include "../../H/UI/Usr.h"
#include "../../H/Docker/Docker.h"
#include <cstring>
#include <iostream>
#include <optional>
#include <algorithm>

//main -in ~/test.g -out ~/test.asm -os win32 -arch x86 -mode 32
void Usr::Create_Argument_Stats()
{
	Find_Evie_Executable_Position();

	for (int i = 1; i < Argument_Amount; i++) {
		Find_Destination_File(i);
		Find_Source_File(i);
		Find_OS(i);
		Find_HOST_OS(i);
		Find_Architecture(i);
		Find_Bits_Mode(i);
		Find_Debug_Type(i);
		Find_Format(i);
		Find_Lib(i);
		Find_VT_API(i);
		Find_Service(i);
	}
}

void Usr::Find_Source_File(int &i)
{
	if ((i <= Argument_Amount) && strcmp(Input[i], "-in") == 0)
	{
		Info.Source_File = Input[i + 1];
		i++;
	}
}

void Usr::Find_Destination_File(int &i)
{
	if ((i <= Argument_Amount) && strcmp(Input[i], "-out") == 0)
	{
		Info.Destination_File = Input[i + 1];
		i++;
	}
}

void Usr::Find_OS(int &i)
{
	if ((i <= Argument_Amount) && strcmp(Input[i], "-os") == 0)
	{
		Info.OS = Input[i + 1];
		i++;
	}
}

void Usr::Find_HOST_OS(int& i)
{
	if ((i <= Argument_Amount) && strcmp(Input[i], "-host") == 0)
	{
		Info.HOST_OS = Input[i + 1];
		i++;
	}
}

void Usr::Find_Architecture(int &i)
{
	if ((i <= Argument_Amount) && strcmp(Input[i], "-arch") == 0)
	{
		Info.Architecture = Input[i + 1];
		i++;
	}
}

void Usr::Find_Bits_Mode(int &i)
{
	if ((i <= Argument_Amount) && strcmp(Input[i], "-mode") == 0)
	{
		Info.Bits_Mode = to_string(atoi(Input[i + 1]) / 8);
		i++;
	}
}

void Usr::Find_Format(int &i)
{
	if ((i <= Argument_Amount) && strcmp(Input[i], "-f") == 0)
	{
		string tmp = string(Input[i + 1]);
		Info.Format = tmp.c_str();
		i++;
	}
}

void Usr::Find_Lib(int& i)
{
	if ((i <= Argument_Amount) && strcmp(Input[i], "-lib") == 0)
	{
		string tmp = string(Input[i + 1]);
		Info.Libs.push_back(tmp.c_str());
		i++;
	}
}

void Usr::Find_Repo_Dir(int& i)
{
	if ((i <= Argument_Amount) && strcmp(Input[i], "-repo-dir") == 0)
	{
		string tmp = string(Input[i + 1]);
		Info.Repo_Dir = tmp;
		i++;
	}
}

void Usr::Find_Debug_Type(int& i)
{
	if ((i <= Argument_Amount) && strcmp(Input[i], "-d") == 0)
	{
		Info.Debug = true;
	}
}

void Usr::Find_VT_API(int& i)
{
	string a = string(Input[i]);
	if ((i <= Argument_Amount) && strcmp(Input[i], "-vt") == 0)
	{
		string tmp = string(Input[i + 1]);
		Info.VT_API = tmp;
		i++;
	}
}

void Usr::Find_Reference_Count(int& i)
{
	if ((i <= Argument_Amount) && strcmp(Input[i], "-reference-count-size") == 0)
	{
		string tmp = string(Input[i + 1]);
		Info.Reference_Count_Size = atoi(tmp.c_str());
		i++;
	}
}

void Usr::Find_Evie_Executable_Position()
{
	string Argv_0 = Input[0];

	DOCKER::Update_Working_Dir(DOCKER::ReplaceAll(Argv_0, "\\", "/"), Info.Evie_Location);
}

void Usr::Find_Service(int& i)
{
	string a = string(Input[i]);
	if ((i <= Argument_Amount) && strcmp(Input[i], "-service") == 0)
	{
		Info.Is_Service = true;
	}
}

void output::Fill_Empty_Arguments()
{
	//Evie.exe -in IO/test.e

	//first check if bit mode is set or not
	if (Bits_Mode == "0")
		Bits_Mode = to_string(sizeof(void*));

	//initialize the default reference count
	if (Reference_Count_Size == 0)
		Reference_Count_Size = atoi(Bits_Mode.c_str());

	//we can always use the source files name to output files name and add the .asm at the end
	if (Destination_File == "")
		Destination_File = (string)Source_File + ".asm";

	if (Repo_Dir == "") {
		char* Env = getenv("Repo-Dir");
		if (Env != nullptr)
			Repo_Dir = Env;
		else
			Repo_Dir = "Remote";
	}



	replace(Repo_Dir.begin(), Repo_Dir.end(), '\\', '/');
}

bool is_number(const string& s)
{
    return !s.empty() && std::find_if(s.begin(), 
        s.end(), [](unsigned char c) { return !std::isdigit(c); }) == s.end();
}

optional<int> If_Int(string s) {
	if (is_number(s))
	{
		return optional<int> {
			atoi(s.c_str())
		};
	}
	return nullopt;
}

C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Tests\Unit_Tests.cpp" 
#include "H/Test_Lexer.h"
#include "H/Test_Back_End.h"
#include "../H/UI/Safe.h"
#include "../H/UI/Usr.h"

extern const string Magenta;
extern const string Reset;
string VT_API = "";

#ifdef Test
int main(int argc, const char** argv) {
	Usr tmp(argv, argc);
	VT_API = tmp.Info.VT_API;
	cout << Magenta << "Lexer tests:" << Reset << endl;
	//Lexer_Test L_Test;
	cout << Magenta << "\n\nBack end tests:" << Reset << endl;

	string Location = argv[0];

	Back_End_Test B_Test(Location);
	return 0;
}
#endif
C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Tests\Cpp\Base.cpp" 
#include "../H/Base.h"

string Base::Transform(long f) {
	if (f == Flags::COMMENT_COMPONENT) {
		return "comment";
	}
	else if (f == Flags::END_COMPONENT) {
		return "end component";
	}
	else if (f == Flags::KEYWORD_COMPONENT) {
		return "keyword";
	}
	else if (f == Flags::NUMBER_COMPONENT) {
		return "number";
	}
	else if (f == Flags::OPERATOR_COMPONENT) {
		return "operator";
	}
	else if (f == Flags::PAREHTHESIS_COMPONENT) {
		return "parenthesis";
	}
	else if (f == Flags::STRING_COMPONENT) {
		return "string";
	}
	else if (f == Flags::TEXT_COMPONENT) {
		return "text";
	}
	else if (f == Flags::UNDEFINED_COMPONENT) {
		return "undefined";
	}
	else {
		throw::runtime_error("INTERNAL ERROR!");
	}
}
C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Tests\Cpp\Test_Back_End.cpp" 
#include "../H/Test_Back_End.h"
#include "../../H/UI/Usr.h"
#include "../../H/Nodes/Node.h"
#include "../../H/BackEnd/Selector.h"
#include "../../H/UI/Safe.h"
#include "../../H/Docker/Mangler.h"
#include "../../H/Docker/Docker.h"


#ifdef _WIN32

typedef __int64(__stdcall* FARPROC)();

extern "C" FARPROC __stdcall GetProcAddress(void*, const char*);
extern "C" void*   __stdcall LoadLibraryA  (const char*);
extern "C" int     __stdcall FreeLibrary   (void*);

template<typename R, typename... T>
R Call(void* handle, const char* name, T... arguments) {
	auto f = (R(*)(T...))GetProcAddress(handle, name);

	return f(arguments...);
}
//int a = Call<int>(Handle, "Start_Test", 1, 2, 1.1);
int Back_End_Test::Run_Dll(string f) {
	auto Handle = LoadLibraryA(f.c_str());
	if (Handle == nullptr)
		throw::runtime_error("INTERNAL ERROR!");

	auto Func = (int(*)())GetProcAddress(Handle, "_Z10Start_Testv");
	//auto Func = (int(*)())GetProcAddress(Handle, "main");
	if (Func == nullptr)
		throw::runtime_error("INTERNAL ERROR!");

	int Result = Func();

	FreeLibrary(Handle);

	return Result;
}

#else 
#include <dlfcn.h>
int Back_End_Test::Run_Dll(string f) {

}
#endif

bool Use_ARM = false;
bool Generate_Debug;


extern Usr* sys;
extern Node* Global_Scope;
extern Selector* selector;
extern x86_64 X86_64;
extern int _SYSTEM_BIT_SIZE_;

extern string Output;
extern int arg_count;
extern vector<pair<string, vector<pair<string, pair<int, string>>>>> MANGLER::IDS;
extern vector<pair<string, string>> DOCKER::Working_Dir;
extern int ID;
extern string* FileName;

extern int Build(int argc, const char* argv[]);

vector<Base*> Back_End_Test::Run(string File)
{
	MANGLER::IDS.clear();
	arg_count = 0;
	DOCKER::Working_Dir.clear();
	DOCKER::Included_Files.clear();
	DOCKER::Assembly_Source_File.clear();
	Global_Scope = nullptr;
	sys = nullptr;
	selector = nullptr;
	ID = 2;
	FileName = new string("No File");

	string output = File +".asm";
	const char** argv; 
	int argc;
	string Use_Debug;
	if (Generate_Debug) 
		Use_Debug = "-d";
	if (Use_ARM) {
		argv = new const char* [10 + (Use_Debug == "-d")] { (new string(Executable_Location))->c_str(), (new string("/Tests"))->c_str(), (new string("-in"))->c_str(), File.c_str(), (new string("-out"))->c_str(), output.c_str(), (new string("-f"))->c_str(), (new string("dll"))->c_str(), (new string("-arch"))->c_str(), (new string("-arm"))->c_str(), Use_Debug.c_str() };
		argc = 10 + (Use_Debug == "-d");
		Output = "";
	}
	else {
		argv = new const char* [8 + (Use_Debug == "-d")] { (new string(Executable_Location))->c_str(), (new string("/Tests"))->c_str(), (new string("-in"))->c_str(), File.c_str(), (new string("-out"))->c_str(), output.c_str(), (new string("-f"))->c_str(), (new string("dll"))->c_str(), Use_Debug.c_str() };
		argc = 8 + (Use_Debug == "-d");
		Output = ".intel_syntax noprefix\n";
	}
	
	Build(argc, argv);

	return { new Numeric_Info{Run_Dll(output + ".dll")} };
}

void Back_End_Test::Factory()
{
	cout << Magenta << "x86_64 -Release tests:" << Reset << endl;
	Use_ARM = false;
	Generate_Debug = false;
	for (auto i : Tests) {
		Check_Assert(i.first, i.second);
	}
	cout << "\n";
	cout << Magenta << "x86_64 -Debug tests:" << Reset << endl;
	Use_ARM = false;
	Generate_Debug = true;
	for (auto i : Tests) {
		Check_Assert(i.first, i.second);
	}
	cout << "\n";		

	cout << "\n";	
	/*
	cout << Magenta << "\nARMv8_64 tests:" << Reset << endl;
	Use_ARM = true;
	for (auto i : Tests) {
		Check_Assert(i.first, i.second);
	}
	*/
}

void Back_End_Test::Check_Assert(Back_Expectation_Set expectation, string s)
{
	bool fail = false;
	vector<Base*> C = Run(s);
	if (expectation.has(NO_ORDER))
		for (auto i : C) {
			for (auto j : expectation.Expecations) {
				/*if (i.Components.size() > 0) {
					for (auto C_C : i.Components) {
						for (auto E_C : expectation.Childs) {
							if (Check_Assert(E_C, C_C, s))
								goto Child_Ok;
						}
						//no child was as expected
						fail = true;
						Report(FAIL, Lexer_Expectation_Set(expectation.Childs, expectation.F | expectation.Childs.begin()->F), "\"" + expectation.Get_Name(C_C) + "\" from '" + s + "'", i.Components);
					Child_Ok:;
					}
					goto Inside_Ok;
				}*/
				if (Check_Assert(expectation.F, i, j)) {
					goto Found;
				}
			}
			//the loop has ended but no expectation was found!
			fail = true;
			Report(FAIL, expectation, "\"" + expectation.Get_Name(i) + "\" from '" + s + "'", C);
		Found:;
		}
Inside_Ok:;
	if (!fail) {
		Report(SUCCESS, expectation, "\"" + s + "\"", C);
	}
}

bool Back_End_Test::Check_Assert(Back_Expectation_Set expectation, Base* a, string s)
{
	return false;
}

bool Back_End_Test::Check_Assert(long F, Base* a, Base* b)
{
	if (is(F, NO_NAMES)) {
		if (a->F == b->F)
			return true;
		return false;
	}
	else if (a->Type == NUMERIC_INFO) {
		if (((Numeric_Info&)*a).Val == ((Numeric_Info&)*b).Val)
			return true;
		return false;
	}
	else if (a->Type == TEXT_INFO) {
		if (((Text_Info&)*a).Val == ((Text_Info&)*b).Val)
			return true;
		return false;
	}
	return false;
}

void Back_End_Test::Init()
{
	//what we expect the function to return, file name
	Tests = {
		//{{1}, "Tests/IO/main"},	
		{{5}, "Tests/IO/Template.e"},
		{{0}, "Tests/IO/NameSpace.e"},
		{{1}, "Tests/IO/Comment.e"},
		{{5}, "Tests/IO/Func.e"},
		{{1}, "Tests/IO/Type.e"},
		{{2}, "Tests/IO/Cast.e"},
		{{100}, "Tests/IO/Conditions.e"},
		{{1}, "Tests/IO/Array.e"},
		{{-6}, "Tests/IO/Math.e"},
		{{1}, "Tests/IO/Destructor.e"},
		{{10}, "Tests/IO/Ptr.e"},
		{{4}, "Tests/IO/Global.e"},
	};
}

C:\Users\GabenRTX>type "C:\Users\GabenRTX\source\repos\Evie\Tests\Cpp\Test_Lexer.cpp" 
#include "../H/Test_Lexer.h"
#include "../../H/UI/Safe.h"

vector<Component> Lexer_Test::Run(string Case)
{
	return Lexer::GetComponents(Case);
}

void Lexer_Test::Factory()
{
	for (auto i : Tests) {
		Check_Assert(i.first, i.second);
	}
}

void Lexer_Test::Check_Assert(Lexer_Expectation_Set expectation, string s)
{
	bool fail = false;
	vector<Component> C = Run(s);
	if (expectation.has(NO_ORDER))
		for (auto i : C) {
			for (auto j : expectation.Expecations) {
				if (i.Components.size() > 0) {
					for (auto C_C : i.Components) {
						for (auto E_C : expectation.Childs) {
							if (Check_Assert(E_C, C_C, s))
								goto Child_Ok;
						}
						//no child was as expected
						fail = true;
						Report(FAIL, Lexer_Expectation_Set(expectation.Childs, expectation.F | expectation.Childs.begin()->F), "\"" + expectation.Get_Name(C_C) + "\" from '" + s + "'", i.Components);
					Child_Ok:;
					}
					goto Inside_Ok;
				}
				if (Check_Assert(expectation.F, i, j)) {
					goto Found;
				}
			}
			//the loop has ended but no expectation was found!
			fail = true;
			Report(FAIL, expectation, "\"" + expectation.Get_Name(i) + "\" from '" + s + "'", C);
		Found:;
		}
Inside_Ok:;
	if (!fail) {
		Report(SUCCESS, expectation, "\"" + s + "\"", C);
	}

}

bool Lexer_Test::Check_Assert(Lexer_Expectation_Set expectation, Component C, string s)
{
	bool fail = false;
	if (expectation.has(NO_ORDER)) {
		for (auto j : expectation.Expecations) {
			if (C.Components.size() > 0) {
				for (auto C_C : C.Components) {
					for (auto E_C : expectation.Childs) {
						if (Check_Assert(E_C, C_C, s))
							goto Child_Ok;
					}
					//no child was as expected
					fail = true;
					Report(FAIL, expectation, "\"" + expectation.Get_Name(C_C) + "\" from '" + s + "'", C.Components);
				Child_Ok:;
				}
				if (!fail)
					goto Inside_Ok;
			}
			if (Check_Assert(expectation.F, C, j)) {
				goto Found;
			}
		}
		//the loop has ended but no expectation was found!
		fail = true;
		return false; //Report(FAIL, expectation, "\"" + expectation.Get_Name(i) + "\" from '" + s + "'", C);

	Found:;
		if (!fail) {
		Inside_Ok:;
			return true; // Report(SUCCESS, expectation, "\"" + s + "\"", C);
		}
	}
}

bool Lexer_Test::Check_Assert(long F, Component a, Component b)
{
	if (is(F, NO_NAMES) && a.is(b.Flags))
		//this Flag means the only thing we are interested is the flag type that the component has
		return true;
	else if (a.is(b.Flags) && a.Value == b.Value)
		//name comparison & flag comparison
		return true;
	else
		return false;
}

void Lexer_Test::Init()
{
	Lexer::DecimalSeparator = '.';
	Lexer::ExponentSeparator = 'e';
	Lexer::SingleLineCommentIdentifier = '#';
	Lexer::StringIdentifier = '\"';
	Lexer::Keywords = {
		"type", "func", "loyal", "export", "import", "use", "if", "while", "else", "ptr", "ref", "cache", "jump", /*"size", size and deciaml and integer and format is no more a keyword because it can be also a variable name, only special in a class scoope*/ "return", "state", "const",
		"cpp", "evie", "vivid"
	};
	Tests = {
		
		{ {vector<long>{Flags::KEYWORD_COMPONENT, Flags::NUMBER_COMPONENT}}, "return 0"},
		{ {vector<long>{Flags::TEXT_COMPONENT, Flags::TEXT_COMPONENT}}, "int a"},
		{ {vector<pair<long, string>>{ {Flags::TEXT_COMPONENT, "a"}, {Flags::OPERATOR_COMPONENT, "+"}, {Flags::NUMBER_COMPONENT, "1"}}}, "a + 1"},
		{ {vector<long>{Flags::NUMBER_COMPONENT, Flags::OPERATOR_COMPONENT, Flags::TEXT_COMPONENT}}, "1.1 + a"},
		{ {vector<long>{Flags::OPERATOR_COMPONENT, Flags::TEXT_COMPONENT, Flags::OPERATOR_COMPONENT, Flags::OPERATOR_COMPONENT, Flags::OPERATOR_COMPONENT, Flags::TEXT_COMPONENT, Flags::OPERATOR_COMPONENT}}, "++a-- + --a++"},
		{ {{vector<Base*>{ new Text_Info({Flags::KEYWORD_COMPONENT, "while"}),new Lexer_Expectation_Set({Flags::TEXT_COMPONENT})}}}, "while (int)"},
		{ {{vector<Base*>{ new Text_Info({Flags::TEXT_COMPONENT, "call"}),new Lexer_Expectation_Set({Flags::TEXT_COMPONENT})}}}, "call(a)"},
		{ {{vector<Base*>{ new Text_Info({Flags::KEYWORD_COMPONENT, "import"}),new Text_Info({Flags::TEXT_COMPONENT, "function"}),new Lexer_Expectation_Set({Flags::TEXT_COMPONENT}),new Lexer_Expectation_Set({Flags::OPERATOR_COMPONENT}),new Lexer_Expectation_Set({Flags::NUMBER_COMPONENT})}}}, "import function(int, 0)"},

	};
}
